<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/usr/local/lib/haxe/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="/usr/local/lib/haxe/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="35" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<__cast params="T" get="inline" set="null" line="38" static="1">
		<f a="value">
			<c path="__cast.T"/>
			<x path="Any"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</__cast>
	<toString get="inline" set="null" line="41" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/usr/local/lib/haxe/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="35" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<__cast params="T" get="inline" set="null" line="38" static="1">
			<f a="value">
				<c path="__cast.T"/>
				<x path="Any"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</__cast>
		<toString get="inline" set="null" line="41" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/usr/local/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/usr/local/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/local/lib/haxe/std/cpp/_std/Date.hx">
		<now public="1" set="method" line="97" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="105" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="111" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<mSeconds><x path="Float"/></mSeconds>
		<getTime public="1" set="method" line="29">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<toString public="1" set="method" line="93">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="25">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/local/lib/haxe/std/cpp/_std/EReg.hx">
		<_hx_regexp_new_options set="method" static="1">
			<f a="s:options">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_new_options"</e></m></meta>
		</_hx_regexp_new_options>
		<_hx_regexp_match set="method" static="1">
			<f a="handler:string:pos:len">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_match"</e></m></meta>
		</_hx_regexp_match>
		<_hx_regexp_matched set="method" static="1">
			<f a="handle:pos">
				<d/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched"</e></m></meta>
		</_hx_regexp_matched>
		<_hx_regexp_matched_pos set="method" static="1">
			<f a="handle:match">
				<d/>
				<x path="Int"/>
				<a>
					<pos><x path="Int"/></pos>
					<len><x path="Int"/></len>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched_pos"</e></m></meta>
		</_hx_regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="61">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="65">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="149">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/regexp/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/local/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/local/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/usr/local/lib/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IntIterator" params="" file="/usr/local/lib/haxe/std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Lambda" params="" file="/usr/local/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="List" params="T" file="/usr/local/lib/haxe/std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="/usr/local/lib/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/local/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/local/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":include"><e>"hxMath.h"</e></m>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/local/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="33" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" set="method" line="38" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<fields public="1" set="method" line="66" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="75" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="80" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="84" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="92" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="105" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":analyzer"><e>ignore</e></m>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/local/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" get="inline" set="null" line="25" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m>
				<m n=":keep"/>
			</meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<downcast public="1" params="T:S" set="method" line="33" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" line="38" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m>
				<m n=":keep"/>
			</meta>
		</instance>
		<string public="1" set="method" line="42" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="50" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="54" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="58" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\t\tstatic inline String string(String &s) { return s; }"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="Single"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc>Single-precision IEEE 32bit float (4-byte).</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/usr/local/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/local/lib/haxe/std/cpp/_std/StringBuf.hx">
		<b><c path="Array"><c path="String"/></c></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<charBuf><c path="Array"><x path="cpp.Char"/></c></charBuf>
		<charBufAsString set="method" line="37"><f a=""><c path="String"/></f></charBufAsString>
		<flush set="method" line="43"><f a=""><x path="Void"/></f></flush>
		<get_length set="method" line="51"><f a=""><x path="Int"/></f></get_length>
		<toString public="1" set="method" line="92">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.SysTools" params="" file="/usr/local/lib/haxe/std/haxe/SysTools.hx">
		<winMetaCharacters final="1" public="1" set="null" expr="[&quot; &quot;.code, &quot;(&quot;.code, &quot;)&quot;.code, &quot;%&quot;.code, &quot;!&quot;.code, &quot;^&quot;.code, &quot;\&quot;&quot;.code, &quot;&lt;&quot;.code, &quot;&gt;&quot;.code, &quot;&amp;&quot;.code, &quot;|&quot;.code, &quot;\n&quot;.code, &quot;\r&quot;.code, &quot;,&quot;.code, &quot;;&quot;.code]" line="9" static="1">
			<x path="haxe.ds.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[[" ".code, "(".code, ")".code, "%".code, "!".code, "^".code, "\"".code, "<".code, ">".code, "&".code, "|".code, "\n".code, "\r".code, ",".code, ";".code]]]></e></m></meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteUnixArg public="1" set="method" line="18" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<quoteWinArg public="1" set="method" line="46" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/local/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="42" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<startsWith public="1" set="method" line="222" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="243" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="270" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="288" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="313" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="335" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="357" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="404" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="426" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/usr/local/lib/haxe/std/cpp/_std/Sys.hx">
		<println public="1" set="method" line="31" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" line="54" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<setCwd public="1" set="method" line="82" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="86" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" line="90" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<programPath public="1" set="method" line="124" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/usr/local/lib/haxe/std/cpp/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="/usr/local/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="61" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="67" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="71" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="79" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="87" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="94" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="99" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="103" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="110" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getEnumConstructs public="1" set="method" line="118" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="123" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<nativeEnumEq set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_enum_eq"</e></m></meta>
		</nativeEnumEq>
		<enumConstructor public="1" set="method" line="153" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<getEnumValueIndex set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_getEnumValueIndex"</e></m></meta>
		</getEnumValueIndex>
		<allEnums public="1" params="T" set="method" line="170" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/usr/local/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/local/lib/haxe/std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="/usr/local/lib/haxe/std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="/usr/local/lib/haxe/std/Xml.hx" private="1" module="Xml" final="1">
	<toString public="1" set="method" line="64" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Xml.XmlType_Impl_" params="" file="/usr/local/lib/haxe/std/Xml.hx" private="1" module="Xml" final="1">
		<toString public="1" set="method" line="64" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="Xml" params="" file="/usr/local/lib/haxe/std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="317">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<toString public="1" get="inline" set="null" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="cpp.ArrayBase" params="" file="/usr/local/lib/haxe/std/cpp/ArrayBase.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getElementSize public="1" set="method"><f a=""><x path="Int"/></f></getElementSize>
		<getByteCount public="1" set="method"><f a=""><x path="Int"/></f></getByteCount>
		<getBase public="1" set="method"><f a=""><c path="cpp.RawPointer"><x path="cpp.Char"/></c></f></getBase>
	</class>
	<class path="cpp.AutoCast" params="" file="/usr/local/lib/haxe/std/cpp/AutoCast.hx" extern="1"/>
	<typedef path="cpp.CallableData" params="T" file="/usr/local/lib/haxe/std/cpp/Callable.hx" module="cpp.Callable">
		<c path="cpp.CallableData.T"/>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
	</typedef>
	<abstract path="cpp.Callable" params="T" file="/usr/local/lib/haxe/std/cpp/Callable.hx">
		<from><icast field="fromFunction"><x path="cpp.Function">
	<c path="fromFunction.F"/>
	<c path="cpp.abi.Abi"/>
</x></icast></from>
		<this><t path="cpp.CallableData"><c path="cpp.Callable.T"/></t></this>
		<to><icast field="toFunction"><x path="cpp.Function">
	<c path="cpp.Callable.T"/>
	<c path="cpp.abi.Abi"/>
</x></icast></to>
		<haxe_doc><![CDATA[The generator intercepts this type and converts it to a cpp.Function<T> on cpp.]]></haxe_doc>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
		<impl><class path="cpp._Callable.Callable_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/Callable.hx" private="1" module="cpp.Callable" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="37" static="1">
		<f a="inValue">
			<c path="cpp.Callable.T"/>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<call public="1" get="accessor" set="null" static="1">
		<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
		<meta><m n=":impl"/></meta>
	</call>
	<get_call public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get_call>
	<fromFunction public="1" params="F" get="inline" set="null" line="47" static="1">
		<f a="func">
			<x path="cpp.Function">
				<c path="fromFunction.F"/>
				<c path="cpp.abi.Abi"/>
			</x>
			<x path="cpp.Callable"><c path="fromFunction.F"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromFunction>
	<toFunction public="1" get="inline" set="null" line="51" static="1">
		<f a="this">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Function">
				<c path="cpp.Callable.T"/>
				<c path="cpp.abi.Abi"/>
			</x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFunction>
	<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="54" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
	<fromStaticFunction public="1" params="T" get="inline" set="null" line="57" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
	<lt public="1" get="inline" set="null" line="60" static="1">
		<f a="this:inOther">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</lt>
	<leq public="1" get="inline" set="null" line="63" static="1">
		<f a="this:inOther">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</leq>
	<gt public="1" get="inline" set="null" line="66" static="1">
		<f a="this:inOther">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</gt>
	<geq public="1" get="inline" set="null" line="69" static="1">
		<f a="this:inOther">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</geq>
</class></impl>
	</abstract>
	<class path="cpp._Callable.Callable_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/Callable.hx" private="1" module="cpp.Callable" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="37" static="1">
			<f a="inValue">
				<c path="cpp.Callable.T"/>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<call public="1" get="accessor" set="null" static="1">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<meta><m n=":impl"/></meta>
		</call>
		<get_call public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get_call>
		<fromFunction public="1" params="F" get="inline" set="null" line="47" static="1">
			<f a="func">
				<x path="cpp.Function">
					<c path="fromFunction.F"/>
					<c path="cpp.abi.Abi"/>
				</x>
				<x path="cpp.Callable"><c path="fromFunction.F"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromFunction>
		<toFunction public="1" get="inline" set="null" line="51" static="1">
			<f a="this">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Function">
					<c path="cpp.Callable.T"/>
					<c path="cpp.abi.Abi"/>
				</x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFunction>
		<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="54" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
		<fromStaticFunction public="1" params="T" get="inline" set="null" line="57" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
		<lt public="1" get="inline" set="null" line="60" static="1">
			<f a="this:inOther">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lt>
		<leq public="1" get="inline" set="null" line="63" static="1">
			<f a="this:inOther">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</leq>
		<gt public="1" get="inline" set="null" line="66" static="1">
			<f a="this:inOther">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</gt>
		<geq public="1" get="inline" set="null" line="69" static="1">
			<f a="this:inOther">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</geq>
	</class>
	<abstract path="cpp.Char" params="" file="/usr/local/lib/haxe/std/cpp/Char.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.Char"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="cpp.ConstCharStar" params="" file="/usr/local/lib/haxe/std/cpp/ConstCharStar.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></this>
		<to>
			<icast><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
			<icast field="toString"><c path="String"/></icast>
			<icast field="toPointer"><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
		</to>
		<impl><class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromString public="1" get="inline" set="null" line="30" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="33" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="String"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<toPointer public="1" get="inline" set="null" line="36" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toPointer>
</class></impl>
	</abstract>
	<class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromString public="1" get="inline" set="null" line="30" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="33" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<toPointer public="1" get="inline" set="null" line="36" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toPointer>
	</class>
	<class path="cpp.ConstPointer" params="T" file="/usr/local/lib/haxe/std/cpp/ConstPointer.hx" extern="1">
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawConstPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.ConstPointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.ConstPointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.ConstPointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<ptr public="1"><t path="cpp.Star"><c path="cpp.ConstPointer.T"/></t></ptr>
		<value public="1" get="accessor" set="null"><c path="cpp.ConstPointer.T"/></value>
		<raw public="1" get="accessor" set="null"><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></raw>
		<constRaw public="1" get="accessor" set="null"><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></constRaw>
		<get_value public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></get_value>
		<get_constRaw public="1" set="method"><f a=""><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></f></get_constRaw>
		<get_raw public="1" set="method"><f a=""><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></f></get_raw>
		<lt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></lt>
		<leq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></leq>
		<gt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></gt>
		<geq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></geq>
		<setRaw public="1" params="O" set="method"><f a="ptr">
	<c path="cpp.RawPointer"><c path="setRaw.O"/></c>
	<x path="Void"/>
</f></setRaw>
		<reinterpret public="1" params="Other" set="method"><f a=""><c path="cpp.Pointer"><c path="reinterpret.Other"/></c></f></reinterpret>
		<rawCast public="1" params="Other" set="method"><f a=""><c path="cpp.RawPointer"><c path="rawCast.Other"/></c></f></rawCast>
		<at public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t>
</f></at>
		<inc public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></inc>
		<dec public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></dec>
		<incBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></decBy>
		<add public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></add>
		<sub public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></sub>
		<postIncVal public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></postIncVal>
		<meta>
			<m n=":coreType"/>
			<m n=":include"><e>"cpp/Pointer.h"</e></m>
			<m n=":native"><e>"cpp.Pointer"</e></m>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<class path="cpp.EnumBase" params="" file="/usr/local/lib/haxe/std/cpp/EnumBase.hx" extern="1">
		<_hx_getIndex public="1" set="method"><f a=""><x path="Int"/></f></_hx_getIndex>
		<_hx_getTag public="1" set="method"><f a=""><c path="String"/></f></_hx_getTag>
		<_hx_getParamCount public="1" set="method"><f a=""><x path="Int"/></f></_hx_getParamCount>
		<_hx_getParamI public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></_hx_getParamI>
		<_hx_getParameters public="1" set="method"><f a=""><c path="Array"><d/></c></f></_hx_getParameters>
		<getIndex public="1" get="inline" set="null" line="34"><f a=""><x path="Int"/></f></getIndex>
		<getTag public="1" get="inline" set="null" line="36"><f a=""><c path="String"/></f></getTag>
		<getParamCount public="1" get="inline" set="null" line="38"><f a=""><x path="Int"/></f></getParamCount>
		<getParamI public="1" get="inline" set="null" line="40"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></getParamI>
		<getParameters public="1" get="inline" set="null" line="42"><f a=""><c path="Array"><d/></c></f></getParameters>
		<meta><m n=":native"><e>"hx.EnumBase"</e></m></meta>
	</class>
	<class path="cpp.ErrorConstants" params="" file="/usr/local/lib/haxe/std/cpp/ErrorConstants.hx" extern="1">
		<invalidCast public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_CAST"</e></m></meta>
		</invalidCast>
		<indexOutOfBounds public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INDEX_OUT_OF_BOUNDS"</e></m></meta>
		</indexOutOfBounds>
		<invalidObject public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_OBJECT"</e></m></meta>
		</invalidObject>
		<invalidArgCount public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_ARG_COUNT"</e></m></meta>
		</invalidArgCount>
		<nullFunctionPointer public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_NULL_FUNCTION_POINTER"</e></m></meta>
		</nullFunctionPointer>
	</class>
	<abstract path="cpp.Float32" params="" file="/usr/local/lib/haxe/std/cpp/Float32.hx">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="cpp.Float32"/></this>
		<to><icast><x path="Float"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="cpp.FunctionData" params="T:ABI" file="/usr/local/lib/haxe/std/cpp/Function.hx" module="cpp.Function">
		<c path="cpp.FunctionData.T"/>
		<meta><m n=":callable"/></meta>
	</typedef>
	<abstract path="cpp.Function" params="T:ABI" file="/usr/local/lib/haxe/std/cpp/Function.hx">
		<this><t path="cpp.FunctionData">
	<c path="cpp.Function.T"/>
	<c path="cpp.Function.ABI"/>
</t></this>
		<meta>
			<m n=":include"><e>"cpp/Pointer.h"</e></m>
			<m n=":callable"/>
		</meta>
		<impl><class path="cpp._Function.Function_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/Function.hx" private="1" module="cpp.Function" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="30" static="1">
		<f a="inValue">
			<c path="cpp.Function.T"/>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<call public="1" get="accessor" set="null" static="1">
		<t path="cpp.FunctionData">
			<c path="cpp.Function.T"/>
			<c path="cpp.Function.ABI"/>
		</t>
		<meta><m n=":impl"/></meta>
	</call>
	<get_call public="1" get="inline" set="null" line="36" static="1">
		<f a="this">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
		</f>
		<meta><m n=":impl"/></meta>
	</get_call>
	<nativeGetProcAddress public="1" params="T:ABI" set="method" static="1">
		<f a="inModule:inFunction">
			<c path="String"/>
			<c path="String"/>
			<c path="cpp.AutoCast"/>
		</f>
		<meta><m n=":native"><e>"::cpp::Function_obj::getProcAddress"</e></m></meta>
	</nativeGetProcAddress>
	<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="42" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
	<nativeFromStaticFunction public="1" params="T" set="method" static="1">
		<f a="inStaticFunction">
			<c path="nativeFromStaticFunction.T"/>
			<c path="cpp.AutoCast"/>
		</f>
		<meta><m n=":native"><e>"::cpp::Function_obj::fromStaticFunction"</e></m></meta>
	</nativeFromStaticFunction>
	<fromStaticFunction public="1" params="T" get="inline" set="null" line="49" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
	<lt public="1" set="method" static="1">
		<f a="this:inOther">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</lt>
	<leq public="1" set="method" static="1">
		<f a="this:inOther">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</leq>
	<gt public="1" set="method" static="1">
		<f a="this:inOther">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</gt>
	<geq public="1" set="method" static="1">
		<f a="this:inOther">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</geq>
</class></impl>
	</abstract>
	<class path="cpp._Function.Function_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/Function.hx" private="1" module="cpp.Function" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="30" static="1">
			<f a="inValue">
				<c path="cpp.Function.T"/>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<call public="1" get="accessor" set="null" static="1">
			<t path="cpp.FunctionData">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</t>
			<meta><m n=":impl"/></meta>
		</call>
		<get_call public="1" get="inline" set="null" line="36" static="1">
			<f a="this">
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
			</f>
			<meta><m n=":impl"/></meta>
		</get_call>
		<nativeGetProcAddress public="1" params="T:ABI" set="method" static="1">
			<f a="inModule:inFunction">
				<c path="String"/>
				<c path="String"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Function_obj::getProcAddress"</e></m></meta>
		</nativeGetProcAddress>
		<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="42" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
		<nativeFromStaticFunction public="1" params="T" set="method" static="1">
			<f a="inStaticFunction">
				<c path="nativeFromStaticFunction.T"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Function_obj::fromStaticFunction"</e></m></meta>
		</nativeFromStaticFunction>
		<fromStaticFunction public="1" params="T" get="inline" set="null" line="49" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
		<lt public="1" set="method" static="1">
			<f a="this:inOther">
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lt>
		<leq public="1" set="method" static="1">
			<f a="this:inOther">
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</leq>
		<gt public="1" set="method" static="1">
			<f a="this:inOther">
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</gt>
		<geq public="1" set="method" static="1">
			<f a="this:inOther">
				<t path="cpp.FunctionData">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</t>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</geq>
	</class>
	<abstract path="cpp.Int64" params="" file="/usr/local/lib/haxe/std/cpp/Int64.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.Int64"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Lib" params="" file="/usr/local/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="34" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<do_rethrow set="method" static="1">
			<f a="inExp">
				<d/>
				<unknown/>
			</f>
			<meta>
				<m n=":noDebug"/>
				<m n=":native"><e>"HX_STACK_DO_RETHROW"</e></m>
			</meta>
		</do_rethrow>
		<println public="1" set="method" line="142" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
		<haxe_doc>Platform-specific Cpp Library. Provides some platform-specific functions
	for the C++ target, such as conversion from Haxe types to native types
	and vice-versa.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="cpp.NativeArray" params="" file="/usr/local/lib/haxe/std/cpp/NativeArray.hx" extern="1">
		<create public="1" params="T" set="method" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="Array"><c path="create.T"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_create_array_length"</e></m></meta>
		</create>
		<blit public="1" params="T" get="inline" set="null" line="37" static="1">
			<f a="ioDestArray:inDestElement:inSourceArray:inSourceElement:inElementCount">
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</blit>
		<getBase public="1" get="inline" set="null" line="41" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<c path="cpp.ArrayBase"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getBase>
		<reserve public="1" params="T" set="method" static="1">
			<f a="inArray:inElements">
				<c path="Array"><c path="reserve.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</reserve>
		<capacity public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="capacity.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</capacity>
		<getElementSize public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="getElementSize.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</getElementSize>
		<address public="1" params="T" get="inline" set="null" line="54" static="1"><f a="inArray:inIndex">
	<c path="Array"><c path="address.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="address.T"/></c>
</f></address>
		<setData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setData.T"/></c>
				<c path="cpp.Pointer"><c path="setData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setData>
		<setUnmanagedData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setUnmanagedData.T"/></c>
				<c path="cpp.ConstPointer"><c path="setUnmanagedData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setUnmanagedData>
		<zero public="1" params="T" set="method" static="1">
			<f a="ioDestArray:?inFirst:?inElements">
				<c path="Array"><c path="zero.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</zero>
		<removeAt public="1" params="T" set="method" static="1">
			<f a="ioDestArray:inIndex">
				<c path="Array"><c path="removeAt.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</removeAt>
		<memcmp public="1" params="T" set="method" static="1">
			<f a="inArrayA:inArrayB">
				<c path="Array"><c path="memcmp.T"/></c>
				<c path="Array"><c path="memcmp.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</memcmp>
		<resolveVirtualArray public="1" set="method" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_reslove_virtual_array"</e></m></meta>
		</resolveVirtualArray>
		<unsafeGet public="1" params="T" set="method" static="1">
			<f a="inDestArray:inIndex">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":native"><e>"_hx_array_unsafe_get"</e></m></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="93" static="1">
			<f a="ioDestArray:inIndex:inValue">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<c path="unsafeSet.T"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":native"><e>"_hx_array_unsafe_set"</e></m>
			</meta>
		</unsafeSet>
		<setSize public="1" params="T" set="method" static="1">
			<f a="ioArray:inSize">
				<c path="Array"><c path="setSize.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="setSize.T"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_array_set_size_exact"</e></m></meta>
		</setSize>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cpp.NativeFile" params="" file="/usr/local/lib/haxe/std/cpp/NativeFile.hx" extern="1">
		<file_open public="1" set="method" static="1">
			<f a="fname:r">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_open"</e></m></meta>
		</file_open>
		<file_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_close"</e></m></meta>
		</file_close>
		<file_write public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write"</e></m></meta>
		</file_write>
		<file_write_char public="1" set="method" static="1">
			<f a="handle:c">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write_char"</e></m></meta>
		</file_write_char>
		<file_read public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read"</e></m></meta>
		</file_read>
		<file_read_char public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read_char"</e></m></meta>
		</file_read_char>
		<file_seek public="1" set="method" static="1">
			<f a="handle:pos:kind">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_seek"</e></m></meta>
		</file_seek>
		<file_tell public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_tell"</e></m></meta>
		</file_tell>
		<file_eof public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_eof"</e></m></meta>
		</file_eof>
		<file_flush public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_flush"</e></m></meta>
		</file_flush>
		<file_contents_string public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_string"</e></m></meta>
		</file_contents_string>
		<file_contents_bytes public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_bytes"</e></m></meta>
		</file_contents_bytes>
		<file_stdin public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdin"</e></m></meta>
		</file_stdin>
		<file_stdout public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdout"</e></m></meta>
		</file_stdout>
		<file_stderr public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stderr"</e></m></meta>
		</file_stderr>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.NativeGc" params="" file="/usr/local/lib/haxe/std/cpp/NativeGc.hx" extern="1">
		<memInfo public="1" set="method" static="1">
			<f a="inWhatInfo">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_gc_mem_info"</e></m></meta>
		</memInfo>
		<allocateExtended public="1" params="T" set="method" static="1">
			<f a="cls:size">
				<x path="Class"><c path="allocateExtended.T"/></x>
				<x path="Int"/>
				<c path="allocateExtended.T"/>
			</f>
			<meta>
				<m n=":native"><e>"_hx_allocate_extended"</e></m>
				<m n=":templatedCall"/>
			</meta>
		</allocateExtended>
		<addFinalizable public="1" set="method" static="1">
			<f a="instance:inPin">
				<a><finalize set="method"><f a=""><x path="Void"/></f></finalize></a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_add_finalizable"</e></m></meta>
		</addFinalizable>
		<allocGcBytesRaw public="1" set="method" static="1">
			<f a="inBytes:isContainer">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="cpp.RawPointer"><c path="cpp.Void"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::InternalNew"</e></m></meta>
		</allocGcBytesRaw>
		<allocGcBytes public="1" get="inline" set="null" line="38" static="1"><f a="inBytes">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Void"/></c>
</f></allocGcBytes>
		<enable public="1" set="method" static="1">
			<f a="inEnable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_enable"</e></m></meta>
		</enable>
		<run public="1" set="method" static="1">
			<f a="major">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_collect"</e></m></meta>
		</run>
		<compact public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"__hxcpp_gc_compact"</e></m></meta>
		</compact>
		<nativeTrace public="1" set="method" static="1">
			<f a="sought:printInstances">
				<x path="Class"><d/></x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_gc_trace"</e></m></meta>
		</nativeTrace>
		<doNotKill public="1" set="method" static="1">
			<f a="inObject">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_gc_do_not_kill"</e></m></meta>
		</doNotKill>
		<getNextZombie public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"__hxcpp_get_next_zombie"</e></m></meta>
		</getNextZombie>
		<safePoint public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"__hxcpp_gc_safe_point"</e></m></meta>
		</safePoint>
		<enterGCFreeZone public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"__hxcpp_enter_gc_free_zone"</e></m></meta>
		</enterGCFreeZone>
		<exitGCFreeZone public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"__hxcpp_exit_gc_free_zone"</e></m></meta>
		</exitGCFreeZone>
		<setMinimumFreeSpace public="1" set="method" static="1">
			<f a="inBytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_set_minimum_free_space"</e></m></meta>
		</setMinimumFreeSpace>
		<setTargetFreeSpacePercentage public="1" set="method" static="1">
			<f a="inPercentage">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_set_target_free_space_percentage"</e></m></meta>
		</setTargetFreeSpacePercentage>
		<setMinimumWorkingMemory public="1" set="method" static="1">
			<f a="inBytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_set_minimum_working_memory"</e></m></meta>
		</setMinimumWorkingMemory>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cpp.NativeProcess" params="" file="/usr/local/lib/haxe/std/cpp/NativeProcess.hx" extern="1">
		<process_run public="1" set="method" static="1">
			<f a="cmd:vargs">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_run"</e></m></meta>
		</process_run>
		<process_run_with_show public="1" set="method" static="1">
			<f a="cmd:vargs:inShow">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_run"</e></m></meta>
		</process_run_with_show>
		<process_stdout_read public="1" set="method" static="1">
			<f a="handle:buf:pos:len">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_stdout_read"</e></m></meta>
		</process_stdout_read>
		<process_stderr_read public="1" set="method" static="1">
			<f a="handle:buf:pos:len">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_stderr_read"</e></m></meta>
		</process_stderr_read>
		<process_stdin_write public="1" set="method" static="1">
			<f a="handle:buf:pos:len">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_stdin_write"</e></m></meta>
		</process_stdin_write>
		<process_stdin_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_stdin_close"</e></m></meta>
		</process_stdin_close>
		<process_exit public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_exit"</e></m></meta>
		</process_exit>
		<process_pid public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_pid"</e></m></meta>
		</process_pid>
		<process_kill public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_kill"</e></m></meta>
		</process_kill>
		<process_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_process_close"</e></m></meta>
		</process_close>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.NativeString" params="" file="/usr/local/lib/haxe/std/cpp/NativeString.hx" extern="1">
		<raw public="1" get="inline" set="null" line="26" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</raw>
		<c_str public="1" get="inline" set="null" line="29" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</c_str>
		<fromPointer public="1" get="inline" set="null" line="32" static="1">
			<f a="inPtr">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromPointer>
		<fromGcPointer public="1" get="inline" set="null" line="35" static="1">
			<f a="inPtr:inLen">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromGcPointer>
		<parseFloat public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_float"</e></m></meta>
		</parseFloat>
		<parseSubstrFloat public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_float"</e></m></meta>
		</parseSubstrFloat>
		<parseInt public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseInt>
		<parseSubstrInt public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseSubstrInt>
		<compare public="1" set="method" static="1">
			<f a="inString0:inString1">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_compare"</e></m></meta>
		</compare>
		<utf8CharCodeAt public="1" set="method" static="1">
			<f a="inString:inIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_char_code_at"</e></m></meta>
		</utf8CharCodeAt>
		<utf8Length public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_length"</e></m></meta>
		</utf8Length>
		<utf8IsValid public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_is_valid"</e></m></meta>
		</utf8IsValid>
		<utf8Sub public="1" set="method" static="1">
			<f a="inString:charStart:inLen">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_sub"</e></m></meta>
		</utf8Sub>
		<fromPointerLen public="1" set="method" static="1">
			<f a="inPtr:len">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_create"</e></m></meta>
		</fromPointerLen>
		<utf8DecodeAdvance public="1" set="method" static="1">
			<f a="reference">
				<x path="cpp.Char"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_decode_advance"</e></m></meta>
		</utf8DecodeAdvance>
	</class>
	<class path="cpp.NativeSys" params="" file="/usr/local/lib/haxe/std/cpp/NativeSys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_print"</e></m></meta>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_println"</e></m></meta>
		</println>
		<get_env public="1" set="method" static="1">
			<f a="v">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_get_env"</e></m></meta>
		</get_env>
		<put_env public="1" set="method" static="1">
			<f a="e:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_put_env"</e></m></meta>
		</put_env>
		<sys_sleep public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_sleep"</e></m></meta>
		</sys_sleep>
		<set_time_locale public="1" set="method" static="1">
			<f a="l">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_time_locale"</e></m></meta>
		</set_time_locale>
		<get_cwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_get_cwd"</e></m></meta>
		</get_cwd>
		<set_cwd public="1" set="method" static="1">
			<f a="d">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_cwd"</e></m></meta>
		</set_cwd>
		<sys_string public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_string"</e></m></meta>
		</sys_string>
		<sys_is64 public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_is64"</e></m></meta>
		</sys_is64>
		<sys_command public="1" set="method" static="1">
			<f a="cmd">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_command"</e></m></meta>
		</sys_command>
		<sys_exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exit"</e></m></meta>
		</sys_exit>
		<sys_exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exists"</e></m></meta>
		</sys_exists>
		<file_delete public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_delete"</e></m></meta>
		</file_delete>
		<sys_rename public="1" set="method" static="1">
			<f a="path:newname">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_rename"</e></m></meta>
		</sys_rename>
		<sys_stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_stat"</e></m></meta>
		</sys_stat>
		<sys_file_type public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_file_type"</e></m></meta>
		</sys_file_type>
		<sys_create_dir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_create_dir"</e></m></meta>
		</sys_create_dir>
		<sys_remove_dir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_remove_dir"</e></m></meta>
		</sys_remove_dir>
		<sys_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_time"</e></m></meta>
		</sys_time>
		<sys_cpu_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_cpu_time"</e></m></meta>
		</sys_cpu_time>
		<sys_read_dir public="1" set="method" static="1">
			<f a="p">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_read_dir"</e></m></meta>
		</sys_read_dir>
		<file_full_path public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_full_path"</e></m></meta>
		</file_full_path>
		<sys_exe_path public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_exe_path"</e></m></meta>
		</sys_exe_path>
		<sys_env public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":native"><e>"_hx_std_sys_env"</e></m></meta>
		</sys_env>
		<sys_getch public="1" set="method" static="1">
			<f a="b">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_getch"</e></m></meta>
		</sys_getch>
		<sys_get_pid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_get_pid"</e></m></meta>
		</sys_get_pid>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<typedef path="cpp.Object" params="" file="/usr/local/lib/haxe/std/cpp/Object.hx">
		<d/>
		<meta><m n=":noPackageRestrict"/></meta>
	</typedef>
	<class path="cpp.ObjectType" params="" file="/usr/local/lib/haxe/std/cpp/ObjectType.hx" extern="1">
		<vtUnknown public="1" get="inline" set="null" expr="-1" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</vtUnknown>
		<vtInt public="1" get="inline" set="null" expr="0xff" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xff</e></m></meta>
		</vtInt>
		<vtNull public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vtNull>
		<vtFloat public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</vtFloat>
		<vtBool public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</vtBool>
		<vtString public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</vtString>
		<vtObject public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</vtObject>
		<vtArray public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</vtArray>
		<vtFunction public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</vtFunction>
		<vtEnum public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</vtEnum>
		<vtClass public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</vtClass>
		<vtInt64 public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</vtInt64>
		<vtAbstractBase public="1" get="inline" set="null" expr="0x100" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100</e></m></meta>
		</vtAbstractBase>
	</class>
	<class path="cpp.Pointer" params="T" file="/usr/local/lib/haxe/std/cpp/Pointer.hx" extern="1">
		<extends path="cpp.ConstPointer"><c path="cpp.Pointer.T"/></extends>
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.Pointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.Pointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<nativeFromHandle public="1" params="T" set="method" static="1">
			<f a="inHandle:?inKind">
				<d/>
				<c path="String"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromHandle"</e></m></meta>
		</nativeFromHandle>
		<fromHandle public="1" params="T" get="inline" set="null" line="44" static="1"><f a="inHandle:?inKind">
	<d/>
	<c path="String"/>
	<c path="cpp.Pointer"><c path="fromHandle.T"/></c>
</f></fromHandle>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.Pointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<addressOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<t path="cpp.Reference"><c path="addressOf.T"/></t>
	<c path="cpp.Pointer"><c path="addressOf.T"/></c>
</f></addressOf>
		<endOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<c path="endOf.T"/>
	<c path="cpp.Pointer"><c path="cpp.Void"/></c>
</f></endOf>
		<nativeArrayElem public="1" params="T" set="method" static="1">
			<f a="array:inElem">
				<c path="Array"><c path="nativeArrayElem.T"/></c>
				<x path="Int"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::arrayElem"</e></m></meta>
		</nativeArrayElem>
		<arrayElem public="1" params="T" get="inline" set="null" line="56" static="1"><f a="array:inElem">
	<c path="Array"><c path="arrayElem.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="arrayElem.T"/></c>
</f></arrayElem>
		<nativeOfArray public="1" params="T" set="method" static="1">
			<f a="array">
				<c path="Array"><c path="nativeOfArray.T"/></c>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::ofArray"</e></m></meta>
		</nativeOfArray>
		<ofArray public="1" params="T" get="inline" set="null" line="62" static="1"><f a="array">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="cpp.Pointer"><c path="ofArray.T"/></c>
</f></ofArray>
		<ref public="1" get="accessor" set="accessor"><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></ref>
		<get_ref public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></get_ref>
		<set_ref public="1" set="method"><f a="t">
	<c path="cpp.Pointer.T"/>
	<t path="cpp.Reference"><c path="cpp.Pointer.T"/></t>
</f></set_ref>
		<setAt public="1" set="method"><f a="inIndex:value">
	<x path="Int"/>
	<c path="cpp.Pointer.T"/>
	<x path="Void"/>
</f></setAt>
		<toUnmanagedArray public="1" get="inline" set="null" line="66"><f a="elementCount">
	<x path="Int"/>
	<c path="Array"><c path="cpp.Pointer.T"/></c>
</f></toUnmanagedArray>
		<toUnmanagedVector public="1" get="inline" set="null" line="72"><f a="elementCount">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><c path="cpp.Pointer.T"/></x>
</f></toUnmanagedVector>
		<inc public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></inc>
		<dec public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></dec>
		<incBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></decBy>
		<add public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></add>
		<sub public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></sub>
		<postIncRef public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></postIncRef>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<destroyArray public="1" set="method"><f a=""><x path="Void"/></f></destroyArray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreType"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<class path="cpp.Prime" params="" file="/usr/local/lib/haxe/std/cpp/Prime.hx">
		<_loadPrime public="1" set="method" line="34" static="1">
			<f a="lib:prim:signature:?quietFail" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ quietFail : false }</e></m>
			</meta>
		</_loadPrime>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":noPackageRestrict"/>
		</meta>
	</class>
	<class path="cpp.RawConstPointer" params="T" file="/usr/local/lib/haxe/std/cpp/RawConstPointer.hx" extern="1">
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawConstPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<class path="cpp.RawPointer" params="T" file="/usr/local/lib/haxe/std/cpp/RawPointer.hx" extern="1">
		<extends path="cpp.RawConstPointer"><c path="cpp.RawPointer.T"/></extends>
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<typedef path="cpp.Reference" params="T" file="/usr/local/lib/haxe/std/cpp/Reference.hx">
		<c path="cpp.Reference.T"/>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this and
	prevent unwanted casting.</haxe_doc>
		<meta><m n=":semantics"><e>reference</e></m></meta>
	</typedef>
	<typedef path="cpp.Star" params="T" file="/usr/local/lib/haxe/std/cpp/Star.hx">
		<x path="Null"><c path="cpp.Star.T"/></x>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this use the
	correct type.</haxe_doc>
	</typedef>
	<abstract path="cpp.UInt8" params="" file="/usr/local/lib/haxe/std/cpp/UInt8.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.UInt8"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Void" params="" file="/usr/local/lib/haxe/std/cpp/Void.hx" extern="1"><meta><m n=":native"><e>"void"</e></m></meta></class>
	<class path="cpp.abi.Abi" params="" file="/usr/local/lib/haxe/std/cpp/abi/Abi.hx" extern="1"/>
	<class path="cpp.rtti.FieldNumericIntegerLookup" params="" file="/usr/local/lib/haxe/std/cpp/rtti/FieldNumericIntegerLookup.hx" interface="1">
		<haxe_doc>If you implement this interface, then the backend will generate code that
	allows fast numeric access to fields by integer id.  This should speed up the CFFI.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="cpp.vm.Gc" params="" file="/usr/local/lib/haxe/std/cpp/vm/Gc.hx">
		<memInfo public="1" set="method" line="41" static="1">
			<f a="inWhatInfo">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Introduced hxcpp_api_level 310

		Returns stats on memory usage:
		- `MEM_INFO_USAGE` - estimate of how much is needed by program (at last collect)
		- `MEM_INFO_RESERVED` - memory allocated for possible use
		- `MEM_INFO_CURRENT` - memory in use, includes uncollected garbage.
			This will generally saw-tooth between USAGE and RESERVED
		- `MEM_INFO_LARGE` - Size of separate pool used for large allocs.  Included in all the above.</haxe_doc>
		</memInfo>
		<setFinalizer public="1" params="T" set="method" static="1">
			<f a="inObject:inFinalizer">
				<c path="setFinalizer.T"/>
				<x path="cpp.Callable"><f a="">
	<c path="setFinalizer.T"/>
	<x path="Void"/>
</f></x>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_set_finalizer"</e></m></meta>
		</setFinalizer>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="cpp.zip.Compress" params="" file="/usr/local/lib/haxe/std/cpp/zip/Compress.hx"><c path="haxe.zip.Compress"/></typedef>
	<typedef path="cpp.zip.Flush" params="" file="/usr/local/lib/haxe/std/cpp/zip/Flush.hx"><e path="haxe.zip.FlushMode"/></typedef>
	<typedef path="cpp.zip.Uncompress" params="" file="/usr/local/lib/haxe/std/cpp/zip/Uncompress.hx"><c path="haxe.zip.Uncompress"/></typedef>
	<abstract path="dsHelper.flat.f32.Float32Flat4" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat4.hx">
		<this><x path="dsHelper.flat.io.Float32Flat"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.f32._Float32Flat4.Float32Flat4_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat4.hx" private="1" module="dsHelper.flat.f32.Float32Flat4" final="1">
	<readItem public="1" get="inline" set="null" line="6" static="1">
		<f a="this:k">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="10" static="1">
		<f a="this:k:v">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</writeItem>
	<_new public="1" get="inline" set="null" line="15" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.f32.Float32Flat4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<index public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</index>
	<get_index get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_index>
	<set_index get="inline" set="null" line="24" static="1">
		<f a="this:id">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_index>
	<getArray public="1" get="inline" set="null" line="29" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getArray>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.f32._Float32Flat4.Float32Flat4_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat4.hx" private="1" module="dsHelper.flat.f32.Float32Flat4" final="1">
		<readItem public="1" get="inline" set="null" line="6" static="1">
			<f a="this:k">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="10" static="1">
			<f a="this:k:v">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</writeItem>
		<_new public="1" get="inline" set="null" line="15" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.f32.Float32Flat4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<index public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</index>
		<get_index get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_index>
		<set_index get="inline" set="null" line="24" static="1">
			<f a="this:id">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_index>
		<getArray public="1" get="inline" set="null" line="29" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getArray>
	</class>
	<abstract path="dsHelper.flat.f32.Float32Flat9" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat9.hx">
		<this><x path="dsHelper.flat.io.Float32Flat"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.f32._Float32Flat9.Float32Flat9_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat9.hx" private="1" module="dsHelper.flat.f32.Float32Flat9" final="1">
	<readItem public="1" get="inline" set="null" line="6" static="1">
		<f a="this:k">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="10" static="1">
		<f a="this:k:v">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</writeItem>
	<_new public="1" get="inline" set="null" line="15" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.f32.Float32Flat9"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<index public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</index>
	<get_index get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_index>
	<set_index get="inline" set="null" line="24" static="1">
		<f a="this:id">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_index>
	<getArray public="1" get="inline" set="null" line="29" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getArray>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.f32._Float32Flat9.Float32Flat9_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32Flat9.hx" private="1" module="dsHelper.flat.f32.Float32Flat9" final="1">
		<readItem public="1" get="inline" set="null" line="6" static="1">
			<f a="this:k">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="10" static="1">
			<f a="this:k:v">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</writeItem>
		<_new public="1" get="inline" set="null" line="15" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.f32.Float32Flat9"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<index public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</index>
		<get_index get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_index>
		<set_index get="inline" set="null" line="24" static="1">
			<f a="this:id">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_index>
		<getArray public="1" get="inline" set="null" line="29" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getArray>
	</class>
	<abstract path="dsHelper.flat.f32.Float32FlatRGBA" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatRGBA.hx">
		<this><x path="dsHelper.flat.f32.Float32Flat4"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.f32._Float32FlatRGBA.Float32FlatRGBA_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatRGBA.hx" private="1" module="dsHelper.flat.f32.Float32FlatRGBA" final="1">
	<_new public="1" get="inline" set="null" line="6" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.f32.Float32FlatRGBA"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</red>
	<get_red set="method" line="11" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<set_red set="method" line="14" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</green>
	<get_green get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<set_green get="inline" set="null" line="24" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<get_blue get="inline" set="null" line="30" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<set_blue get="inline" set="null" line="34" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<get_alpha get="inline" set="null" line="40" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<set_alpha get="inline" set="null" line="44" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<rgb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgb>
	<set_rgb get="inline" set="null" line="50" static="1">
		<f a="this:col">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgb>
	<get_rgb get="inline" set="null" line="58" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgb>
	<argb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argb>
	<set_argb get="inline" set="null" line="65" static="1">
		<f a="this:col">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argb>
	<get_argb get="inline" set="null" line="73" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argb>
	<readItem public="1" get="inline" set="null" line="81" static="1">
		<f a="this:k">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="86" static="1">
		<f a="this:k:v">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</writeItem>
	<colorTriangles public="1" get="inline" set="null" line="90" static="1">
		<f a="this:color:times">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</colorTriangles>
	<cornerColors public="1" get="inline" set="null" line="94" static="1">
		<f a="this:colorA:colorB:colorC">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</cornerColors>
	<hex public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hex>
	<hexAll public="1" get="inline" set="null" line="107" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat4"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexAll>
	<alphaChannel public="1" get="inline" set="null" line="118" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
	<redChannel public="1" get="inline" set="null" line="121" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
	<greenChannel public="1" get="inline" set="null" line="124" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
	<blueChannel public="1" get="inline" set="null" line="127" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.f32._Float32FlatRGBA.Float32FlatRGBA_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatRGBA.hx" private="1" module="dsHelper.flat.f32.Float32FlatRGBA" final="1">
		<_new public="1" get="inline" set="null" line="6" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.f32.Float32FlatRGBA"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</red>
		<get_red set="method" line="11" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<set_red set="method" line="14" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</green>
		<get_green get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<set_green get="inline" set="null" line="24" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<get_blue get="inline" set="null" line="30" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<set_blue get="inline" set="null" line="34" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="40" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<set_alpha get="inline" set="null" line="44" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<rgb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgb>
		<set_rgb get="inline" set="null" line="50" static="1">
			<f a="this:col">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgb>
		<get_rgb get="inline" set="null" line="58" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgb>
		<argb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argb>
		<set_argb get="inline" set="null" line="65" static="1">
			<f a="this:col">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argb>
		<get_argb get="inline" set="null" line="73" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argb>
		<readItem public="1" get="inline" set="null" line="81" static="1">
			<f a="this:k">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="86" static="1">
			<f a="this:k:v">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</writeItem>
		<colorTriangles public="1" get="inline" set="null" line="90" static="1">
			<f a="this:color:times">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</colorTriangles>
		<cornerColors public="1" get="inline" set="null" line="94" static="1">
			<f a="this:colorA:colorB:colorC">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</cornerColors>
		<hex public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hex>
		<hexAll public="1" get="inline" set="null" line="107" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat4"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexAll>
		<alphaChannel public="1" get="inline" set="null" line="118" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="121" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="124" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="127" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flat.f32.Float32FlatTriangle" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatTriangle.hx">
		<this><x path="dsHelper.flat.f32.Float32Flat9"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.f32._Float32FlatTriangle.Float32FlatTriangle_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatTriangle.hx" private="1" module="dsHelper.flat.f32.Float32FlatTriangle" final="1">
	<_new public="1" get="inline" set="null" line="7" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<ax public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ax>
	<get_ax set="method" line="11" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ax>
	<set_ax set="method" line="14" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ax>
	<ay public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ay>
	<get_ay set="method" line="19" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ay>
	<set_ay set="method" line="22" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ay>
	<az public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</az>
	<get_az set="method" line="27" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_az>
	<set_az set="method" line="30" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_az>
	<bx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bx>
	<get_bx set="method" line="35" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bx>
	<set_bx set="method" line="38" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bx>
	<by public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</by>
	<get_by set="method" line="43" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_by>
	<set_by set="method" line="46" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_by>
	<bz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bz>
	<get_bz set="method" line="51" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bz>
	<set_bz set="method" line="54" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bz>
	<cx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cx>
	<get_cx set="method" line="59" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cx>
	<set_cx set="method" line="62" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cx>
	<cy public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cy>
	<get_cy set="method" line="67" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cy>
	<set_cy set="method" line="70" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cy>
	<cz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cz>
	<get_cz set="method" line="75" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cz>
	<set_cz set="method" line="78" static="1">
		<f a="this:v">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cz>
	<triangle public="1" set="method" line="83" static="1">
		<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":keep"/>
		</meta>
	</triangle>
	<adjustWinding public="1" set="method" line="107" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</adjustWinding>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="111" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<set_x get="inline" set="null" line="115" static="1">
		<f a="this:x">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="124" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_y get="inline" set="null" line="128" static="1">
		<f a="this:y">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<z public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</z>
	<get_z get="inline" set="null" line="137" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_z>
	<set_z get="inline" set="null" line="141" static="1">
		<f a="this:z">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_z>
	<right public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</right>
	<get_right get="inline" set="null" line="150" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_right>
	<bottom public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottom>
	<get_bottom get="inline" set="null" line="155" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottom>
	<back public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</back>
	<get_back get="inline" set="null" line="160" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_back>
	<moveDelta set="method" line="164" static="1">
		<f a="this:dx:dy">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveDelta>
	<sign public="1" get="inline" set="null" line="172" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
	<liteHit public="1" get="inline" set="null" line="177" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</liteHit>
	<fullHit public="1" set="method" line="185" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fullHit>
	<rotate public="1" get="inline" set="null" line="190" static="1">
		<f a="this:x:y:theta">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotate>
	<rotateTrig public="1" get="inline" set="null" line="196" static="1">
		<f a="this:x:y:cos:sin">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotateTrig>
	<prettyString public="1" get="inline" set="null" line="225" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyString>
	<prettyAll public="1" get="inline" set="null" line="231" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32Flat9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyAll>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.f32._Float32FlatTriangle.Float32FlatTriangle_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/f32/Float32FlatTriangle.hx" private="1" module="dsHelper.flat.f32.Float32FlatTriangle" final="1">
		<_new public="1" get="inline" set="null" line="7" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<ax public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ax>
		<get_ax set="method" line="11" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ax>
		<set_ax set="method" line="14" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ax>
		<ay public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ay>
		<get_ay set="method" line="19" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ay>
		<set_ay set="method" line="22" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ay>
		<az public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</az>
		<get_az set="method" line="27" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_az>
		<set_az set="method" line="30" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_az>
		<bx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bx>
		<get_bx set="method" line="35" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bx>
		<set_bx set="method" line="38" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bx>
		<by public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</by>
		<get_by set="method" line="43" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_by>
		<set_by set="method" line="46" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_by>
		<bz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bz>
		<get_bz set="method" line="51" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bz>
		<set_bz set="method" line="54" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bz>
		<cx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cx>
		<get_cx set="method" line="59" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cx>
		<set_cx set="method" line="62" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cx>
		<cy public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cy>
		<get_cy set="method" line="67" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cy>
		<set_cy set="method" line="70" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cy>
		<cz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cz>
		<get_cz set="method" line="75" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cz>
		<set_cz set="method" line="78" static="1">
			<f a="this:v">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cz>
		<triangle public="1" set="method" line="83" static="1">
			<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":keep"/>
			</meta>
		</triangle>
		<adjustWinding public="1" set="method" line="107" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</adjustWinding>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="111" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<set_x get="inline" set="null" line="115" static="1">
			<f a="this:x">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="124" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_y get="inline" set="null" line="128" static="1">
			<f a="this:y">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<z public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</z>
		<get_z get="inline" set="null" line="137" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_z>
		<set_z get="inline" set="null" line="141" static="1">
			<f a="this:z">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_z>
		<right public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</right>
		<get_right get="inline" set="null" line="150" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_right>
		<bottom public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottom>
		<get_bottom get="inline" set="null" line="155" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottom>
		<back public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</back>
		<get_back get="inline" set="null" line="160" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_back>
		<moveDelta set="method" line="164" static="1">
			<f a="this:dx:dy">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveDelta>
		<sign public="1" get="inline" set="null" line="172" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<liteHit public="1" get="inline" set="null" line="177" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</liteHit>
		<fullHit public="1" set="method" line="185" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fullHit>
		<rotate public="1" get="inline" set="null" line="190" static="1">
			<f a="this:x:y:theta">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotate>
		<rotateTrig public="1" get="inline" set="null" line="196" static="1">
			<f a="this:x:y:cos:sin">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotateTrig>
		<prettyString public="1" get="inline" set="null" line="225" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyString>
		<prettyAll public="1" get="inline" set="null" line="231" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32Flat9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyAll>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flat.io.Float32Flat" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32Flat.hx">
		<from><icast field="fromArray"><t path="dsHelper.haxe.io.Float32Array"/></icast></from>
		<this><t path="dsHelper.haxe.io.Float32Array"/></this>
		<to><icast field="toArray"><x path="lime.utils.Float32Array"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.io._Float32Flat.Float32Flat_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32Flat.hx" private="1" module="dsHelper.flat.io.Float32Flat" final="1">
	<readItem public="1" get="inline" set="null" line="17" static="1">
		<f a="this:k">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
		<haxe_doc><![CDATA[* <pre><code>
     * >>> ({ 
     * ... var ff = new Float32Flat(2);
     * ... ff[0] = 1.;
     * ... ff[0] == 1.; }) == true
     * </code></pre>]]></haxe_doc>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="30" static="1">
		<f a="this:k:v">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
		<haxe_doc><![CDATA[* <pre><code>
     * >>> ({ 
     * ... var ff = new Float32Flat(2);
     * ... ff[0] = 1.;
     * ... ff[0] == 1.; }) == true
     * </code></pre>]]></haxe_doc>
	</writeItem>
	<_new public="1" get="inline" set="null" line="36" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.io.Float32Flat"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<size public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</size>
	<get_size set="method" line="44" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_size>
	<set_size set="method" line="49" static="1">
		<f a="this:id">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_size>
	<index public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</index>
	<get_index get="inline" set="null" line="54" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_index>
	<set_index get="inline" set="null" line="58" static="1">
		<f a="this:id">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_index>
	<pos public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</pos>
	<get_pos get="inline" set="null" line="64" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pos>
	<set_pos get="inline" set="null" line="68" static="1">
		<f a="this:pos_">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_pos>
	<updateLen get="inline" set="null" line="74" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</updateLen>
	<hasNext public="1" get="inline" set="null" line="79" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hasNext>
	<next public="1" get="inline" set="null" line="81" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</next>
	<increment public="1" get="inline" set="null" line="94" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A++</e></m>
		</meta>
	</increment>
	<toArray public="1" get="inline" set="null" line="99" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toArray>
	<fromArray public="1" get="inline" set="null" line="104" static="1">
		<f a="arr">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="dsHelper.flat.io.Float32Flat"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray>
	<clone public="1" get="inline" set="null" line="110" static="1">
		<f a="this">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="dsHelper.flat.io.Float32Flat"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<fill public="1" get="inline" set="null" line="116" static="1">
		<f a="this:arr">
			<t path="dsHelper.haxe.io.Float32Array"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fill>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.io._Float32Flat.Float32Flat_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32Flat.hx" private="1" module="dsHelper.flat.io.Float32Flat" final="1">
		<readItem public="1" get="inline" set="null" line="17" static="1">
			<f a="this:k">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
			<haxe_doc><![CDATA[* <pre><code>
     * >>> ({ 
     * ... var ff = new Float32Flat(2);
     * ... ff[0] = 1.;
     * ... ff[0] == 1.; }) == true
     * </code></pre>]]></haxe_doc>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="30" static="1">
			<f a="this:k:v">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
			<haxe_doc><![CDATA[* <pre><code>
     * >>> ({ 
     * ... var ff = new Float32Flat(2);
     * ... ff[0] = 1.;
     * ... ff[0] == 1.; }) == true
     * </code></pre>]]></haxe_doc>
		</writeItem>
		<_new public="1" get="inline" set="null" line="36" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.io.Float32Flat"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<size public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</size>
		<get_size set="method" line="44" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_size>
		<set_size set="method" line="49" static="1">
			<f a="this:id">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_size>
		<index public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</index>
		<get_index get="inline" set="null" line="54" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_index>
		<set_index get="inline" set="null" line="58" static="1">
			<f a="this:id">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_index>
		<pos public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</pos>
		<get_pos get="inline" set="null" line="64" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pos>
		<set_pos get="inline" set="null" line="68" static="1">
			<f a="this:pos_">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_pos>
		<updateLen get="inline" set="null" line="74" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</updateLen>
		<hasNext public="1" get="inline" set="null" line="79" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="81" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</next>
		<increment public="1" get="inline" set="null" line="94" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A++</e></m>
			</meta>
		</increment>
		<toArray public="1" get="inline" set="null" line="99" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<fromArray public="1" get="inline" set="null" line="104" static="1">
			<f a="arr">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="dsHelper.flat.io.Float32Flat"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
		<clone public="1" get="inline" set="null" line="110" static="1">
			<f a="this">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="dsHelper.flat.io.Float32Flat"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<fill public="1" get="inline" set="null" line="116" static="1">
			<f a="this:arr">
				<t path="dsHelper.haxe.io.Float32Array"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fill>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flat.io.Float32FlatDepth" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32FlatDepth.hx">
		<this><x path="dsHelper.flat.io.Float32Flat"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flat.io._Float32FlatDepth.Float32FlatDepth_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32FlatDepth.hx" private="1" module="dsHelper.flat.io.Float32FlatDepth" final="1">
	<_new public="1" get="inline" set="null" line="6" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<rangeToEnd public="1" set="method" line="11" static="1">
		<f a="this:starting:totalLen:section">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rangeToEnd>
	<rangeToStart public="1" get="inline" set="null" line="30" static="1">
		<f a="this:starting:totalLen">
			<x path="dsHelper.flat.io.Float32Flat"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rangeToStart>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flat.io._Float32FlatDepth.Float32FlatDepth_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flat/io/Float32FlatDepth.hx" private="1" module="dsHelper.flat.io.Float32FlatDepth" final="1">
		<_new public="1" get="inline" set="null" line="6" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<rangeToEnd public="1" set="method" line="11" static="1">
			<f a="this:starting:totalLen:section">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rangeToEnd>
		<rangeToStart public="1" get="inline" set="null" line="30" static="1">
			<f a="this:starting:totalLen">
				<x path="dsHelper.flat.io.Float32Flat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rangeToStart>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flatInterleave.FloatColorTriangles" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTriangles.hx">
		<this><x path="dsHelper.flatInterleave.core.Flat3x7"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flatInterleave._FloatColorTriangles.FloatColorTriangles_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTriangles.hx" private="1" module="dsHelper.flatInterleave.FloatColorTriangles" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<create public="1" get="inline" set="null" line="8" static="1"><f a="len">
	<x path="Int"/>
	<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
</f></create>
	<ax public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ax>
	<get_ax set="method" line="13" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ax>
	<set_ax set="method" line="16" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ax>
	<ay public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ay>
	<get_ay set="method" line="21" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ay>
	<set_ay set="method" line="24" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ay>
	<az public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</az>
	<get_az set="method" line="29" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_az>
	<set_az set="method" line="32" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_az>
	<redA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redA>
	<get_redA set="method" line="38" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redA>
	<set_redA set="method" line="41" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redA>
	<greenA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenA>
	<get_greenA get="inline" set="null" line="47" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenA>
	<set_greenA get="inline" set="null" line="51" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenA>
	<blueA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueA>
	<get_blueA get="inline" set="null" line="57" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueA>
	<set_blueA get="inline" set="null" line="61" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueA>
	<alphaA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaA>
	<get_alphaA get="inline" set="null" line="67" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaA>
	<set_alphaA get="inline" set="null" line="71" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaA>
	<bx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bx>
	<get_bx set="method" line="78" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bx>
	<set_bx set="method" line="81" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bx>
	<by public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</by>
	<get_by set="method" line="86" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_by>
	<set_by set="method" line="89" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_by>
	<bz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bz>
	<get_bz set="method" line="94" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bz>
	<set_bz set="method" line="97" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bz>
	<redB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redB>
	<get_redB set="method" line="103" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redB>
	<set_redB set="method" line="106" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redB>
	<greenB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenB>
	<get_greenB get="inline" set="null" line="112" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenB>
	<set_greenB get="inline" set="null" line="116" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenB>
	<blueB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueB>
	<get_blueB get="inline" set="null" line="122" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueB>
	<set_blueB get="inline" set="null" line="126" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueB>
	<alphaB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaB>
	<get_alphaB get="inline" set="null" line="132" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaB>
	<set_alphaB get="inline" set="null" line="136" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaB>
	<cx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cx>
	<get_cx set="method" line="143" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cx>
	<set_cx set="method" line="146" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cx>
	<cy public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cy>
	<get_cy set="method" line="151" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cy>
	<set_cy set="method" line="154" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cy>
	<cz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cz>
	<get_cz set="method" line="159" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cz>
	<set_cz set="method" line="162" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cz>
	<redC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redC>
	<get_redC set="method" line="168" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redC>
	<set_redC set="method" line="171" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redC>
	<greenC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenC>
	<get_greenC get="inline" set="null" line="177" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenC>
	<set_greenC get="inline" set="null" line="181" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenC>
	<blueC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueC>
	<get_blueC get="inline" set="null" line="187" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueC>
	<set_blueC get="inline" set="null" line="191" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueC>
	<alphaC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaC>
	<get_alphaC get="inline" set="null" line="197" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaC>
	<set_alphaC get="inline" set="null" line="201" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaC>
	<triangle public="1" set="method" line="207" static="1">
		<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":keep"/>
		</meta>
	</triangle>
	<adjustWinding public="1" set="method" line="231" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</adjustWinding>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="235" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<set_x get="inline" set="null" line="239" static="1">
		<f a="this:x">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="248" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_y get="inline" set="null" line="252" static="1">
		<f a="this:y">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<z public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</z>
	<get_z get="inline" set="null" line="261" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_z>
	<set_z get="inline" set="null" line="265" static="1">
		<f a="this:z">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_z>
	<right public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</right>
	<get_right get="inline" set="null" line="274" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_right>
	<bottom public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottom>
	<get_bottom get="inline" set="null" line="279" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottom>
	<back public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</back>
	<get_back get="inline" set="null" line="284" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_back>
	<moveDelta set="method" line="288" static="1">
		<f a="this:dx:dy">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveDelta>
	<sign public="1" get="inline" set="null" line="296" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
	<distHit public="1" set="method" line="300" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</distHit>
	<liteHit public="1" get="inline" set="null" line="309" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</liteHit>
	<fullHit public="1" set="method" line="317" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fullHit>
	<rotate public="1" get="inline" set="null" line="322" static="1">
		<f a="this:x:y:theta">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotate>
	<rotateTrig public="1" get="inline" set="null" line="328" static="1">
		<f a="this:x:y:cos:sin">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotateTrig>
	<colorTriangles public="1" get="inline" set="null" line="357" static="1">
		<f a="this:color:times">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</colorTriangles>
	<cornerColors public="1" get="inline" set="null" line="364" static="1">
		<f a="this:colorA:colorB:colorC">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</cornerColors>
	<rgb public="1" get="null" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgb>
	<set_rgb get="inline" set="null" line="371" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgb>
	<rgbA public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbA>
	<set_rgbA get="inline" set="null" line="379" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbA>
	<get_rgbA get="inline" set="null" line="387" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbA>
	<rgbB public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbB>
	<set_rgbB get="inline" set="null" line="394" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbB>
	<get_rgbB get="inline" set="null" line="402" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbB>
	<rgbC public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbC>
	<set_rgbC get="inline" set="null" line="409" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbC>
	<get_rgbC get="inline" set="null" line="417" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbC>
	<argb public="1" get="null" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argb>
	<set_argb get="inline" set="null" line="424" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argb>
	<argbA public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbA>
	<set_argbA get="inline" set="null" line="432" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbA>
	<get_argbA get="inline" set="null" line="440" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbA>
	<argbB public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbB>
	<set_argbB get="inline" set="null" line="448" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbB>
	<get_argbB get="inline" set="null" line="456" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbB>
	<argbC public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbC>
	<set_argbC get="inline" set="null" line="464" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbC>
	<get_argbC get="inline" set="null" line="472" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbC>
	<prettyStringVert public="1" get="inline" set="null" line="479" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyStringVert>
	<prettyAllVert public="1" get="inline" set="null" line="485" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyAllVert>
	<hex public="1" get="inline" set="null" line="496" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hex>
	<hexA public="1" get="inline" set="null" line="500" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexA>
	<hexB public="1" get="inline" set="null" line="504" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexB>
	<hexC public="1" get="inline" set="null" line="508" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexC>
	<hexAll public="1" get="inline" set="null" line="512" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexAll>
	<alphaChannel public="1" get="inline" set="null" line="523" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
	<redChannel public="1" get="inline" set="null" line="526" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
	<greenChannel public="1" get="inline" set="null" line="529" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
	<blueChannel public="1" get="inline" set="null" line="532" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flatInterleave._FloatColorTriangles.FloatColorTriangles_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTriangles.hx" private="1" module="dsHelper.flatInterleave.FloatColorTriangles" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<create public="1" get="inline" set="null" line="8" static="1"><f a="len">
	<x path="Int"/>
	<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
</f></create>
		<ax public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ax>
		<get_ax set="method" line="13" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ax>
		<set_ax set="method" line="16" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ax>
		<ay public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ay>
		<get_ay set="method" line="21" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ay>
		<set_ay set="method" line="24" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ay>
		<az public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</az>
		<get_az set="method" line="29" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_az>
		<set_az set="method" line="32" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_az>
		<redA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redA>
		<get_redA set="method" line="38" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redA>
		<set_redA set="method" line="41" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redA>
		<greenA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenA>
		<get_greenA get="inline" set="null" line="47" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenA>
		<set_greenA get="inline" set="null" line="51" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenA>
		<blueA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueA>
		<get_blueA get="inline" set="null" line="57" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueA>
		<set_blueA get="inline" set="null" line="61" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueA>
		<alphaA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaA>
		<get_alphaA get="inline" set="null" line="67" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaA>
		<set_alphaA get="inline" set="null" line="71" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaA>
		<bx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bx>
		<get_bx set="method" line="78" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bx>
		<set_bx set="method" line="81" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bx>
		<by public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</by>
		<get_by set="method" line="86" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_by>
		<set_by set="method" line="89" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_by>
		<bz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bz>
		<get_bz set="method" line="94" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bz>
		<set_bz set="method" line="97" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bz>
		<redB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redB>
		<get_redB set="method" line="103" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redB>
		<set_redB set="method" line="106" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redB>
		<greenB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenB>
		<get_greenB get="inline" set="null" line="112" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenB>
		<set_greenB get="inline" set="null" line="116" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenB>
		<blueB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueB>
		<get_blueB get="inline" set="null" line="122" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueB>
		<set_blueB get="inline" set="null" line="126" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueB>
		<alphaB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaB>
		<get_alphaB get="inline" set="null" line="132" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaB>
		<set_alphaB get="inline" set="null" line="136" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaB>
		<cx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cx>
		<get_cx set="method" line="143" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cx>
		<set_cx set="method" line="146" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cx>
		<cy public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cy>
		<get_cy set="method" line="151" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cy>
		<set_cy set="method" line="154" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cy>
		<cz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cz>
		<get_cz set="method" line="159" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cz>
		<set_cz set="method" line="162" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cz>
		<redC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redC>
		<get_redC set="method" line="168" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redC>
		<set_redC set="method" line="171" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redC>
		<greenC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenC>
		<get_greenC get="inline" set="null" line="177" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenC>
		<set_greenC get="inline" set="null" line="181" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenC>
		<blueC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueC>
		<get_blueC get="inline" set="null" line="187" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueC>
		<set_blueC get="inline" set="null" line="191" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueC>
		<alphaC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaC>
		<get_alphaC get="inline" set="null" line="197" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaC>
		<set_alphaC get="inline" set="null" line="201" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaC>
		<triangle public="1" set="method" line="207" static="1">
			<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":keep"/>
			</meta>
		</triangle>
		<adjustWinding public="1" set="method" line="231" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</adjustWinding>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="235" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<set_x get="inline" set="null" line="239" static="1">
			<f a="this:x">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="248" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_y get="inline" set="null" line="252" static="1">
			<f a="this:y">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<z public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</z>
		<get_z get="inline" set="null" line="261" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_z>
		<set_z get="inline" set="null" line="265" static="1">
			<f a="this:z">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_z>
		<right public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</right>
		<get_right get="inline" set="null" line="274" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_right>
		<bottom public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottom>
		<get_bottom get="inline" set="null" line="279" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottom>
		<back public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</back>
		<get_back get="inline" set="null" line="284" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_back>
		<moveDelta set="method" line="288" static="1">
			<f a="this:dx:dy">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveDelta>
		<sign public="1" get="inline" set="null" line="296" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<distHit public="1" set="method" line="300" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</distHit>
		<liteHit public="1" get="inline" set="null" line="309" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</liteHit>
		<fullHit public="1" set="method" line="317" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fullHit>
		<rotate public="1" get="inline" set="null" line="322" static="1">
			<f a="this:x:y:theta">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotate>
		<rotateTrig public="1" get="inline" set="null" line="328" static="1">
			<f a="this:x:y:cos:sin">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotateTrig>
		<colorTriangles public="1" get="inline" set="null" line="357" static="1">
			<f a="this:color:times">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</colorTriangles>
		<cornerColors public="1" get="inline" set="null" line="364" static="1">
			<f a="this:colorA:colorB:colorC">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</cornerColors>
		<rgb public="1" get="null" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgb>
		<set_rgb get="inline" set="null" line="371" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgb>
		<rgbA public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbA>
		<set_rgbA get="inline" set="null" line="379" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbA>
		<get_rgbA get="inline" set="null" line="387" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbA>
		<rgbB public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbB>
		<set_rgbB get="inline" set="null" line="394" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbB>
		<get_rgbB get="inline" set="null" line="402" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbB>
		<rgbC public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbC>
		<set_rgbC get="inline" set="null" line="409" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbC>
		<get_rgbC get="inline" set="null" line="417" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbC>
		<argb public="1" get="null" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argb>
		<set_argb get="inline" set="null" line="424" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argb>
		<argbA public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbA>
		<set_argbA get="inline" set="null" line="432" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbA>
		<get_argbA get="inline" set="null" line="440" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbA>
		<argbB public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbB>
		<set_argbB get="inline" set="null" line="448" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbB>
		<get_argbB get="inline" set="null" line="456" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbB>
		<argbC public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbC>
		<set_argbC get="inline" set="null" line="464" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbC>
		<get_argbC get="inline" set="null" line="472" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbC>
		<prettyStringVert public="1" get="inline" set="null" line="479" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyStringVert>
		<prettyAllVert public="1" get="inline" set="null" line="485" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyAllVert>
		<hex public="1" get="inline" set="null" line="496" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hex>
		<hexA public="1" get="inline" set="null" line="500" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexA>
		<hexB public="1" get="inline" set="null" line="504" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexB>
		<hexC public="1" get="inline" set="null" line="508" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexC>
		<hexAll public="1" get="inline" set="null" line="512" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexAll>
		<alphaChannel public="1" get="inline" set="null" line="523" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="526" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="529" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="532" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flatInterleave.FloatColorTrianglesUV" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTrianglesUV.hx">
		<from><icast><x path="dsHelper.flatInterleave.core.Flat3x9"/></icast></from>
		<this><x path="dsHelper.flatInterleave.core.Flat3x9"/></this>
		<to><icast><x path="dsHelper.flatInterleave.core.Flat3x9"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flatInterleave._FloatColorTrianglesUV.FloatColorTrianglesUV_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTrianglesUV.hx" private="1" module="dsHelper.flatInterleave.FloatColorTrianglesUV" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<create public="1" get="inline" set="null" line="8" static="1"><f a="len">
	<x path="Int"/>
	<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
</f></create>
	<ax public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ax>
	<get_ax set="method" line="13" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ax>
	<set_ax set="method" line="16" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ax>
	<ay public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ay>
	<get_ay set="method" line="21" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ay>
	<set_ay set="method" line="24" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ay>
	<az public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</az>
	<get_az set="method" line="29" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_az>
	<set_az set="method" line="32" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_az>
	<redA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redA>
	<get_redA set="method" line="38" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redA>
	<set_redA set="method" line="41" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redA>
	<greenA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenA>
	<get_greenA get="inline" set="null" line="47" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenA>
	<set_greenA get="inline" set="null" line="51" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenA>
	<blueA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueA>
	<get_blueA get="inline" set="null" line="57" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueA>
	<set_blueA get="inline" set="null" line="61" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueA>
	<alphaA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaA>
	<get_alphaA get="inline" set="null" line="67" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaA>
	<set_alphaA get="inline" set="null" line="71" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaA>
	<uA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</uA>
	<get_uA get="inline" set="null" line="77" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_uA>
	<set_uA get="inline" set="null" line="81" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_uA>
	<vA public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</vA>
	<get_vA get="inline" set="null" line="87" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_vA>
	<set_vA get="inline" set="null" line="91" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_vA>
	<bx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bx>
	<get_bx set="method" line="98" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bx>
	<set_bx set="method" line="101" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bx>
	<by public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</by>
	<get_by set="method" line="106" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_by>
	<set_by set="method" line="109" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_by>
	<bz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bz>
	<get_bz set="method" line="114" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bz>
	<set_bz set="method" line="117" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_bz>
	<redB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redB>
	<get_redB set="method" line="123" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redB>
	<set_redB set="method" line="126" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redB>
	<greenB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenB>
	<get_greenB get="inline" set="null" line="132" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenB>
	<set_greenB get="inline" set="null" line="136" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenB>
	<blueB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueB>
	<get_blueB get="inline" set="null" line="142" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueB>
	<set_blueB get="inline" set="null" line="146" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueB>
	<alphaB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaB>
	<get_alphaB get="inline" set="null" line="152" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaB>
	<set_alphaB get="inline" set="null" line="156" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaB>
	<uB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</uB>
	<get_uB get="inline" set="null" line="162" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_uB>
	<set_uB get="inline" set="null" line="166" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_uB>
	<vB public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</vB>
	<get_vB get="inline" set="null" line="172" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_vB>
	<set_vB get="inline" set="null" line="176" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_vB>
	<cx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cx>
	<get_cx set="method" line="183" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cx>
	<set_cx set="method" line="186" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cx>
	<cy public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cy>
	<get_cy set="method" line="191" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cy>
	<set_cy set="method" line="194" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cy>
	<cz public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cz>
	<get_cz set="method" line="199" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cz>
	<set_cz set="method" line="202" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cz>
	<redC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redC>
	<get_redC set="method" line="208" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redC>
	<set_redC set="method" line="211" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redC>
	<greenC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenC>
	<get_greenC get="inline" set="null" line="217" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenC>
	<set_greenC get="inline" set="null" line="221" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenC>
	<blueC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueC>
	<get_blueC get="inline" set="null" line="227" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueC>
	<set_blueC get="inline" set="null" line="231" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueC>
	<alphaC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaC>
	<get_alphaC get="inline" set="null" line="237" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaC>
	<set_alphaC get="inline" set="null" line="241" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaC>
	<uC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</uC>
	<get_uC get="inline" set="null" line="247" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_uC>
	<set_uC get="inline" set="null" line="251" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_uC>
	<vC public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</vC>
	<get_vC get="inline" set="null" line="257" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_vC>
	<set_vC get="inline" set="null" line="261" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_vC>
	<triangle public="1" set="method" line="268" static="1">
		<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":keep"/>
		</meta>
	</triangle>
	<triangleUV public="1" set="method" line="293" static="1">
		<f a="this:uA_:vA_:uB_:vB_:uC_:vC_:?windAdjust_">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":keep"/>
		</meta>
	</triangleUV>
	<adjustWinding public="1" set="method" line="313" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</adjustWinding>
	<u public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</u>
	<get_u get="inline" set="null" line="317" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_u>
	<set_u get="inline" set="null" line="321" static="1">
		<f a="this:u_">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_u>
	<v public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</v>
	<get_v get="inline" set="null" line="330" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_v>
	<set_v get="inline" set="null" line="334" static="1">
		<f a="this:v_">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_v>
	<rightU public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</rightU>
	<get_rightU get="inline" set="null" line="344" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rightU>
	<bottomV public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottomV>
	<get_bottomV get="inline" set="null" line="349" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottomV>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="355" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<set_x get="inline" set="null" line="359" static="1">
		<f a="this:x">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="368" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_y get="inline" set="null" line="372" static="1">
		<f a="this:y">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<z public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</z>
	<get_z get="inline" set="null" line="381" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_z>
	<set_z get="inline" set="null" line="385" static="1">
		<f a="this:z">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_z>
	<right public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</right>
	<get_right get="inline" set="null" line="394" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_right>
	<bottom public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottom>
	<get_bottom get="inline" set="null" line="399" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottom>
	<back public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</back>
	<get_back get="inline" set="null" line="404" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_back>
	<moveDelta set="method" line="408" static="1">
		<f a="this:dx:dy">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveDelta>
	<sign public="1" get="inline" set="null" line="416" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
	<liteHit public="1" get="inline" set="null" line="421" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</liteHit>
	<fullHit public="1" set="method" line="429" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fullHit>
	<distHit public="1" set="method" line="434" static="1">
		<f a="this:px:py">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</distHit>
	<moveDeltaUV set="method" line="442" static="1">
		<f a="this:du:dv">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveDeltaUV>
	<rotate public="1" get="inline" set="null" line="450" static="1">
		<f a="this:x:y:theta">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotate>
	<rotateTrig public="1" get="inline" set="null" line="456" static="1">
		<f a="this:x:y:cos:sin">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rotateTrig>
	<colorTriangles public="1" get="inline" set="null" line="485" static="1">
		<f a="this:color:times">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</colorTriangles>
	<cornerColors public="1" get="inline" set="null" line="489" static="1">
		<f a="this:colorA:colorB:colorC">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</cornerColors>
	<rgb public="1" get="null" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgb>
	<set_rgb get="inline" set="null" line="496" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgb>
	<rgbA public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbA>
	<set_rgbA get="inline" set="null" line="504" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbA>
	<get_rgbA get="inline" set="null" line="512" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbA>
	<rgbB public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbB>
	<set_rgbB get="inline" set="null" line="519" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbB>
	<get_rgbB get="inline" set="null" line="527" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbB>
	<rgbC public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</rgbC>
	<set_rgbC get="inline" set="null" line="534" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_rgbC>
	<get_rgbC get="inline" set="null" line="542" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rgbC>
	<argb public="1" get="null" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argb>
	<set_argb get="inline" set="null" line="549" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argb>
	<argbA public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbA>
	<set_argbA get="inline" set="null" line="558" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbA>
	<get_argbA get="inline" set="null" line="566" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbA>
	<argbB public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbB>
	<set_argbB get="inline" set="null" line="575" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbB>
	<get_argbB get="inline" set="null" line="583" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbB>
	<argbC public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbC>
	<set_argbC get="inline" set="null" line="591" static="1">
		<f a="this:col">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbC>
	<get_argbC get="inline" set="null" line="599" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbC>
	<prettyStringVert public="1" get="inline" set="null" line="606" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyStringVert>
	<prettyAllVert public="1" get="inline" set="null" line="612" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyAllVert>
	<hex public="1" get="inline" set="null" line="623" static="1">
		<f a="this:v">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hex>
	<hexA public="1" get="inline" set="null" line="627" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexA>
	<hexB public="1" get="inline" set="null" line="631" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexB>
	<hexC public="1" get="inline" set="null" line="635" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexC>
	<hexAll public="1" get="inline" set="null" line="639" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexAll>
	<prettyStringUV public="1" get="inline" set="null" line="650" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyStringUV>
	<prettyAlluv public="1" get="inline" set="null" line="656" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyAlluv>
	<prettyEverything public="1" get="inline" set="null" line="667" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prettyEverything>
	<alphaChannel public="1" get="inline" set="null" line="680" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
	<redChannel public="1" get="inline" set="null" line="683" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
	<greenChannel public="1" get="inline" set="null" line="686" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
	<blueChannel public="1" get="inline" set="null" line="689" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.flatInterleave._FloatColorTrianglesUV.FloatColorTrianglesUV_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/FloatColorTrianglesUV.hx" private="1" module="dsHelper.flatInterleave.FloatColorTrianglesUV" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<create public="1" get="inline" set="null" line="8" static="1"><f a="len">
	<x path="Int"/>
	<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
</f></create>
		<ax public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ax>
		<get_ax set="method" line="13" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ax>
		<set_ax set="method" line="16" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ax>
		<ay public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ay>
		<get_ay set="method" line="21" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ay>
		<set_ay set="method" line="24" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ay>
		<az public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</az>
		<get_az set="method" line="29" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_az>
		<set_az set="method" line="32" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_az>
		<redA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redA>
		<get_redA set="method" line="38" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redA>
		<set_redA set="method" line="41" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redA>
		<greenA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenA>
		<get_greenA get="inline" set="null" line="47" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenA>
		<set_greenA get="inline" set="null" line="51" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenA>
		<blueA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueA>
		<get_blueA get="inline" set="null" line="57" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueA>
		<set_blueA get="inline" set="null" line="61" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueA>
		<alphaA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaA>
		<get_alphaA get="inline" set="null" line="67" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaA>
		<set_alphaA get="inline" set="null" line="71" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaA>
		<uA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</uA>
		<get_uA get="inline" set="null" line="77" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_uA>
		<set_uA get="inline" set="null" line="81" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_uA>
		<vA public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</vA>
		<get_vA get="inline" set="null" line="87" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_vA>
		<set_vA get="inline" set="null" line="91" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_vA>
		<bx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bx>
		<get_bx set="method" line="98" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bx>
		<set_bx set="method" line="101" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bx>
		<by public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</by>
		<get_by set="method" line="106" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_by>
		<set_by set="method" line="109" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_by>
		<bz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bz>
		<get_bz set="method" line="114" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bz>
		<set_bz set="method" line="117" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_bz>
		<redB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redB>
		<get_redB set="method" line="123" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redB>
		<set_redB set="method" line="126" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redB>
		<greenB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenB>
		<get_greenB get="inline" set="null" line="132" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenB>
		<set_greenB get="inline" set="null" line="136" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenB>
		<blueB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueB>
		<get_blueB get="inline" set="null" line="142" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueB>
		<set_blueB get="inline" set="null" line="146" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueB>
		<alphaB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaB>
		<get_alphaB get="inline" set="null" line="152" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaB>
		<set_alphaB get="inline" set="null" line="156" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaB>
		<uB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</uB>
		<get_uB get="inline" set="null" line="162" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_uB>
		<set_uB get="inline" set="null" line="166" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_uB>
		<vB public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</vB>
		<get_vB get="inline" set="null" line="172" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_vB>
		<set_vB get="inline" set="null" line="176" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_vB>
		<cx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cx>
		<get_cx set="method" line="183" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cx>
		<set_cx set="method" line="186" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cx>
		<cy public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cy>
		<get_cy set="method" line="191" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cy>
		<set_cy set="method" line="194" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cy>
		<cz public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cz>
		<get_cz set="method" line="199" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cz>
		<set_cz set="method" line="202" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cz>
		<redC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redC>
		<get_redC set="method" line="208" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redC>
		<set_redC set="method" line="211" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redC>
		<greenC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenC>
		<get_greenC get="inline" set="null" line="217" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenC>
		<set_greenC get="inline" set="null" line="221" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenC>
		<blueC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueC>
		<get_blueC get="inline" set="null" line="227" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueC>
		<set_blueC get="inline" set="null" line="231" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueC>
		<alphaC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaC>
		<get_alphaC get="inline" set="null" line="237" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaC>
		<set_alphaC get="inline" set="null" line="241" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaC>
		<uC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</uC>
		<get_uC get="inline" set="null" line="247" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_uC>
		<set_uC get="inline" set="null" line="251" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_uC>
		<vC public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</vC>
		<get_vC get="inline" set="null" line="257" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_vC>
		<set_vC get="inline" set="null" line="261" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_vC>
		<triangle public="1" set="method" line="268" static="1">
			<f a="this:ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":keep"/>
			</meta>
		</triangle>
		<triangleUV public="1" set="method" line="293" static="1">
			<f a="this:uA_:vA_:uB_:vB_:uC_:vC_:?windAdjust_">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":keep"/>
			</meta>
		</triangleUV>
		<adjustWinding public="1" set="method" line="313" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</adjustWinding>
		<u public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</u>
		<get_u get="inline" set="null" line="317" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_u>
		<set_u get="inline" set="null" line="321" static="1">
			<f a="this:u_">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_u>
		<v public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</v>
		<get_v get="inline" set="null" line="330" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_v>
		<set_v get="inline" set="null" line="334" static="1">
			<f a="this:v_">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_v>
		<rightU public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</rightU>
		<get_rightU get="inline" set="null" line="344" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rightU>
		<bottomV public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottomV>
		<get_bottomV get="inline" set="null" line="349" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottomV>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="355" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<set_x get="inline" set="null" line="359" static="1">
			<f a="this:x">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="368" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_y get="inline" set="null" line="372" static="1">
			<f a="this:y">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<z public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</z>
		<get_z get="inline" set="null" line="381" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_z>
		<set_z get="inline" set="null" line="385" static="1">
			<f a="this:z">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_z>
		<right public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</right>
		<get_right get="inline" set="null" line="394" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_right>
		<bottom public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottom>
		<get_bottom get="inline" set="null" line="399" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottom>
		<back public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</back>
		<get_back get="inline" set="null" line="404" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_back>
		<moveDelta set="method" line="408" static="1">
			<f a="this:dx:dy">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveDelta>
		<sign public="1" get="inline" set="null" line="416" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<liteHit public="1" get="inline" set="null" line="421" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</liteHit>
		<fullHit public="1" set="method" line="429" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fullHit>
		<distHit public="1" set="method" line="434" static="1">
			<f a="this:px:py">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</distHit>
		<moveDeltaUV set="method" line="442" static="1">
			<f a="this:du:dv">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveDeltaUV>
		<rotate public="1" get="inline" set="null" line="450" static="1">
			<f a="this:x:y:theta">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotate>
		<rotateTrig public="1" get="inline" set="null" line="456" static="1">
			<f a="this:x:y:cos:sin">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rotateTrig>
		<colorTriangles public="1" get="inline" set="null" line="485" static="1">
			<f a="this:color:times">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</colorTriangles>
		<cornerColors public="1" get="inline" set="null" line="489" static="1">
			<f a="this:colorA:colorB:colorC">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</cornerColors>
		<rgb public="1" get="null" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgb>
		<set_rgb get="inline" set="null" line="496" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgb>
		<rgbA public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbA>
		<set_rgbA get="inline" set="null" line="504" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbA>
		<get_rgbA get="inline" set="null" line="512" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbA>
		<rgbB public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbB>
		<set_rgbB get="inline" set="null" line="519" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbB>
		<get_rgbB get="inline" set="null" line="527" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbB>
		<rgbC public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</rgbC>
		<set_rgbC get="inline" set="null" line="534" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_rgbC>
		<get_rgbC get="inline" set="null" line="542" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rgbC>
		<argb public="1" get="null" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argb>
		<set_argb get="inline" set="null" line="549" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argb>
		<argbA public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbA>
		<set_argbA get="inline" set="null" line="558" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbA>
		<get_argbA get="inline" set="null" line="566" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbA>
		<argbB public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbB>
		<set_argbB get="inline" set="null" line="575" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbB>
		<get_argbB get="inline" set="null" line="583" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbB>
		<argbC public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbC>
		<set_argbC get="inline" set="null" line="591" static="1">
			<f a="this:col">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbC>
		<get_argbC get="inline" set="null" line="599" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbC>
		<prettyStringVert public="1" get="inline" set="null" line="606" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyStringVert>
		<prettyAllVert public="1" get="inline" set="null" line="612" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyAllVert>
		<hex public="1" get="inline" set="null" line="623" static="1">
			<f a="this:v">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hex>
		<hexA public="1" get="inline" set="null" line="627" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexA>
		<hexB public="1" get="inline" set="null" line="631" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexB>
		<hexC public="1" get="inline" set="null" line="635" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexC>
		<hexAll public="1" get="inline" set="null" line="639" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexAll>
		<prettyStringUV public="1" get="inline" set="null" line="650" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyStringUV>
		<prettyAlluv public="1" get="inline" set="null" line="656" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyAlluv>
		<prettyEverything public="1" get="inline" set="null" line="667" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prettyEverything>
		<alphaChannel public="1" get="inline" set="null" line="680" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="683" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="686" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="689" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.flatInterleave.core.Flat3x7" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x7.hx">
		<this><x path="dsHelper.flat.io.Float32FlatDepth"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flatInterleave.core._Flat3x7.Flat3x7_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x7.hx" private="1" module="dsHelper.flatInterleave.core.Flat3x7" final="1">
	<readItem public="1" get="inline" set="null" line="8" static="1">
		<f a="this:k">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="12" static="1">
		<f a="this:k:v">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</writeItem>
	<_new public="1" get="inline" set="null" line="17" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flatInterleave.core.Flat3x7"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<index public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</index>
	<get_index get="inline" set="null" line="22" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_index>
	<set_index get="inline" set="null" line="26" static="1">
		<f a="this:id">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_index>
	<getArray public="1" get="inline" set="null" line="31" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getArray>
	<toEnd public="1" get="inline" set="null" line="35" static="1">
		<f a="this:id:len">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toEnd>
	<toStart public="1" get="inline" set="null" line="39" static="1">
		<f a="this:id:len">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toStart>
</class></impl>
	</abstract>
	<class path="dsHelper.flatInterleave.core._Flat3x7.Flat3x7_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x7.hx" private="1" module="dsHelper.flatInterleave.core.Flat3x7" final="1">
		<readItem public="1" get="inline" set="null" line="8" static="1">
			<f a="this:k">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="12" static="1">
			<f a="this:k:v">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</writeItem>
		<_new public="1" get="inline" set="null" line="17" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flatInterleave.core.Flat3x7"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<index public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</index>
		<get_index get="inline" set="null" line="22" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_index>
		<set_index get="inline" set="null" line="26" static="1">
			<f a="this:id">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_index>
		<getArray public="1" get="inline" set="null" line="31" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getArray>
		<toEnd public="1" get="inline" set="null" line="35" static="1">
			<f a="this:id:len">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toEnd>
		<toStart public="1" get="inline" set="null" line="39" static="1">
			<f a="this:id:len">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toStart>
	</class>
	<abstract path="dsHelper.flatInterleave.core.Flat3x9" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x9.hx">
		<from><icast><x path="dsHelper.flat.io.Float32FlatDepth"/></icast></from>
		<this><x path="dsHelper.flat.io.Float32FlatDepth"/></this>
		<to><icast><x path="dsHelper.flat.io.Float32FlatDepth"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="dsHelper.flatInterleave.core._Flat3x9.Flat3x9_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x9.hx" private="1" module="dsHelper.flatInterleave.core.Flat3x9" final="1">
	<readItem public="1" get="inline" set="null" line="7" static="1">
		<f a="this:k">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</readItem>
	<writeItem public="1" get="inline" set="null" line="11" static="1">
		<f a="this:k:v">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>[]</e></m>
		</meta>
	</writeItem>
	<_new public="1" get="inline" set="null" line="16" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="dsHelper.flatInterleave.core.Flat3x9"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<index public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</index>
	<get_index get="inline" set="null" line="21" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_index>
	<set_index get="inline" set="null" line="25" static="1">
		<f a="this:id">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_index>
	<getArray public="1" get="inline" set="null" line="30" static="1">
		<f a="this">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getArray>
	<toEnd public="1" get="inline" set="null" line="34" static="1">
		<f a="this:id:len">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toEnd>
	<toStart public="1" get="inline" set="null" line="38" static="1">
		<f a="this:id:len">
			<x path="dsHelper.flat.io.Float32FlatDepth"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toStart>
</class></impl>
	</abstract>
	<class path="dsHelper.flatInterleave.core._Flat3x9.Flat3x9_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/flatInterleave/core/Flat3x9.hx" private="1" module="dsHelper.flatInterleave.core.Flat3x9" final="1">
		<readItem public="1" get="inline" set="null" line="7" static="1">
			<f a="this:k">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</readItem>
		<writeItem public="1" get="inline" set="null" line="11" static="1">
			<f a="this:k:v">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</writeItem>
		<_new public="1" get="inline" set="null" line="16" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="dsHelper.flatInterleave.core.Flat3x9"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<index public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</index>
		<get_index get="inline" set="null" line="21" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_index>
		<set_index get="inline" set="null" line="25" static="1">
			<f a="this:id">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_index>
		<getArray public="1" get="inline" set="null" line="30" static="1">
			<f a="this">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getArray>
		<toEnd public="1" get="inline" set="null" line="34" static="1">
			<f a="this:id:len">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toEnd>
		<toStart public="1" get="inline" set="null" line="38" static="1">
			<f a="this:id:len">
				<x path="dsHelper.flat.io.Float32FlatDepth"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toStart>
	</class>
	<typedef path="dsHelper.haxe.io.Float32Array" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/haxe/io/Float32Array.hx">
		<x path="lime.utils.Float32Array"/>
		<haxe_doc>* switches between Lime, NME and haxe.io.Float32Array</haxe_doc>
	</typedef>
	<abstract path="dsHelper.iterArr.ArrayPairs" params="T" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayPairs.hx">
		<this><c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c></this>
		<impl><class path="dsHelper.iterArr._ArrayPairs.ArrayPairs_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayPairs.hx" private="1" module="dsHelper.iterArr.ArrayPairs" final="1">
	<_new public="1" set="method" line="3" static="1">
		<f a="arr">
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			<x path="dsHelper.iterArr.ArrayPairs"><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="5" static="1">
		<f a="this">
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<access get="inline" set="null" line="6" static="1">
		<f a="this:key">
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			<x path="Int"/>
			<a>
				<y><c path="dsHelper.iterArr.ArrayPairs.T"/></y>
				<x><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
			</a>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</access>
	<getObj public="1" get="inline" set="null" line="9" static="1">
		<f a="this:key">
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			<x path="Int"/>
			<a>
				<y><c path="dsHelper.iterArr.ArrayPairs.T"/></y>
				<x><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
			</a>
		</f>
		<meta><m n=":impl"/></meta>
	</getObj>
	<reverse public="1" get="inline" set="null" line="14" static="1">
		<f a="this">
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.iterArr._ArrayPairs.ArrayPairs_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayPairs.hx" private="1" module="dsHelper.iterArr.ArrayPairs" final="1">
		<_new public="1" set="method" line="3" static="1">
			<f a="arr">
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
				<x path="dsHelper.iterArr.ArrayPairs"><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="5" static="1">
			<f a="this">
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<access get="inline" set="null" line="6" static="1">
			<f a="this:key">
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
				<x path="Int"/>
				<a>
					<y><c path="dsHelper.iterArr.ArrayPairs.T"/></y>
					<x><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
				</a>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</access>
		<getObj public="1" get="inline" set="null" line="9" static="1">
			<f a="this:key">
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
				<x path="Int"/>
				<a>
					<y><c path="dsHelper.iterArr.ArrayPairs.T"/></y>
					<x><c path="dsHelper.iterArr.ArrayPairs.T"/></x>
				</a>
			</f>
			<meta><m n=":impl"/></meta>
		</getObj>
		<reverse public="1" get="inline" set="null" line="14" static="1">
			<f a="this">
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
				<c path="Array"><c path="dsHelper.iterArr.ArrayPairs.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="dsHelper.iterArr.ArrayTriple" params="T" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayTriple.hx">
		<this><c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c></this>
		<impl><class path="dsHelper.iterArr._ArrayTriple.ArrayTriple_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayTriple.hx" private="1" module="dsHelper.iterArr.ArrayTriple" final="1">
	<_new public="1" set="method" line="3" static="1">
		<f a="arr">
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			<x path="dsHelper.iterArr.ArrayTriple"><c path="dsHelper.iterArr.ArrayTriple.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="5" static="1">
		<f a="this">
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<access get="inline" set="null" line="6" static="1">
		<f a="this:key">
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			<x path="Int"/>
			<a>
				<c><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<b><c path="dsHelper.iterArr.ArrayTriple.T"/></b>
				<a><c path="dsHelper.iterArr.ArrayTriple.T"/></a>
			</a>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</access>
	<getObj public="1" get="inline" set="null" line="9" static="1">
		<f a="this:key">
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			<x path="Int"/>
			<a>
				<c><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<b><c path="dsHelper.iterArr.ArrayTriple.T"/></b>
				<a><c path="dsHelper.iterArr.ArrayTriple.T"/></a>
			</a>
		</f>
		<meta><m n=":impl"/></meta>
	</getObj>
	<reverse public="1" get="inline" set="null" line="14" static="1">
		<f a="this">
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="dsHelper.iterArr._ArrayTriple.ArrayTriple_Impl_" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/iterArr/ArrayTriple.hx" private="1" module="dsHelper.iterArr.ArrayTriple" final="1">
		<_new public="1" set="method" line="3" static="1">
			<f a="arr">
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<x path="dsHelper.iterArr.ArrayTriple"><c path="dsHelper.iterArr.ArrayTriple.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="5" static="1">
			<f a="this">
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<access get="inline" set="null" line="6" static="1">
			<f a="this:key">
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<x path="Int"/>
				<a>
					<c><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
					<b><c path="dsHelper.iterArr.ArrayTriple.T"/></b>
					<a><c path="dsHelper.iterArr.ArrayTriple.T"/></a>
				</a>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</access>
		<getObj public="1" get="inline" set="null" line="9" static="1">
			<f a="this:key">
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<x path="Int"/>
				<a>
					<c><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
					<b><c path="dsHelper.iterArr.ArrayTriple.T"/></b>
					<a><c path="dsHelper.iterArr.ArrayTriple.T"/></a>
				</a>
			</f>
			<meta><m n=":impl"/></meta>
		</getObj>
		<reverse public="1" get="inline" set="null" line="14" static="1">
			<f a="this">
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
				<c path="Array"><c path="dsHelper.iterArr.ArrayTriple.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="dsHelper.splitter.SpaceSplitter" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/splitter/SpaceSplitter.hx"><parse public="1" get="inline" set="null" line="5" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><c path="Array"><c path="String"/></c></c>
</f></parse></class>
	<class path="dsHelper.splitter.StringCodeIterator" params="" file="/usr/local/lib/haxeLibrary/dsHelper/git/src/dsHelper/splitter/StringCodeIterator.hx">
		<str expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</str>
		<b><c path="StringBuf"/></b>
		<pos public="1"><x path="Int"/></pos>
		<c public="1"><x path="Int"/></c>
		<last2 public="1"><c path="String"/></last2>
		<last public="1"><c path="String"/></last>
		<length public="1"><x path="Int"/></length>
		<addChar public="1" get="inline" set="null" line="17"><f a=""><x path="Void"/></f></addChar>
		<toStr public="1" get="inline" set="null" line="21"><f a=""><c path="String"/></f></toStr>
		<isRepeat public="1" get="inline" set="null" line="27"><f a=""><x path="Bool"/></f></isRepeat>
		<resetBuffer public="1" get="inline" set="null" line="33"><f a=""><x path="Void"/></f></resetBuffer>
		<reset public="1" get="inline" set="null" line="37"><f a=""><x path="Void"/></f></reset>
		<hasNext public="1" get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="45"><f a=""><x path="Int"/></f></next>
		<new public="1" set="method" line="11">
			<f a="str_:?pos_" v=":0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pos_ : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flash.Lib" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Lib.hx"><c path="nme.Lib"/></typedef>
	<typedef path="flash._Vector.VectorData" params="T" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx" private="1" module="flash.Vector"><d/></typedef>
	<typedef path="flash.Vector" params="T" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx"><x path="nme.Vector"><c path="flash.Vector.T"/></x></typedef>
	<typedef path="flash.display.Graphics" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Graphics.hx"><c path="nme.display.Graphics"/></typedef>
	<typedef path="flash.display.Sprite" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Sprite.hx"><c path="nme.display.Sprite"/></typedef>
	<typedef path="flash.events.Event" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/Event.hx"><c path="nme.events.Event"/></typedef>
	<typedef path="flash.events.KeyboardEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/KeyboardEvent.hx"><c path="nme.events.KeyboardEvent"/></typedef>
	<typedef path="flash.geom.Point" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/Point.hx"><c path="nme.geom.Point"/></typedef>
	<typedef path="flash.ui.Keyboard" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/Keyboard.hx"><c path="nme.ui.Keyboard"/></typedef>
	<typedef path="format.gif.Data" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx">
		<a>
			<version>
				<e path="format.gif.Version"/>
				<haxe_doc>* Gif version. There is only 2 Gif version exists. 87a and 89a.
   * 87a have less features and does not support any extensions.
   * Unknown version is adviced to be interpreted as newest (89a) official version.</haxe_doc>
			</version>
			<logicalScreenDescriptor>
				<t path="format.gif.LogicalScreenDescriptor"/>
				<haxe_doc>* Information about logical screen of Gif that provides basic information about Gif.</haxe_doc>
			</logicalScreenDescriptor>
			<globalColorTable>
				<x path="Null"><t path="format.gif.ColorTable"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Global color table used for Gif. Present only if Logical Screen Descriptor contained global color table flag.
   * Note that this color table not always present since frames can contain local color tables that overrides global color table.</haxe_doc>
			</globalColorTable>
			<blocks>
				<t path="List"><e path="format.gif.Block"/></t>
				<haxe_doc>* List of Gif data blocks.</haxe_doc>
			</blocks>
		</a>
		<haxe_doc>* Gif data.</haxe_doc>
	</typedef>
	<enum path="format.gif.Block" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<BFrame a="frame">
			<t path="format.gif.Frame"/>
			<haxe_doc>* Gif frame block.
   * Note that this block does not contain link to graphic control extension of Frame even if it is present. GraphicControl extension Block commonly present right before frame Block.</haxe_doc>
		</BFrame>
		<BExtension a="extension">
			<e path="format.gif.Extension"/>
			<haxe_doc>* Additional extension block. This Block does not supported in 87a Gif specification version.</haxe_doc>
		</BExtension>
		<BEOF><haxe_doc>* End of File block. Represents end of Gif data.</haxe_doc></BEOF>
		<haxe_doc>* Gif data block. Custom blocks are not supported.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.Extension" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<EGraphicControl a="gce">
			<t path="format.gif.GraphicControlExtension"/>
			<haxe_doc>* Graphic Control extension gives additional control over next frame, like frame delay, disposal method, alpha channel and other information.</haxe_doc>
		</EGraphicControl>
		<EComment a="text">
			<c path="String"/>
			<haxe_doc>* Commentary extension. Not show up as any visual, just a text in file.</haxe_doc>
		</EComment>
		<EText a="pte">
			<t path="format.gif.PlainTextExtension"/>
			<haxe_doc>* Text extension. Must work as text rendering on the image, but ignored by all major Gif decoders.</haxe_doc>
		</EText>
		<EApplicationExtension a="ext">
			<e path="format.gif.ApplicationExtension"/>
			<haxe_doc>* Application extension allow to insert additional application data into Gif. Mostly used app extension is NETSCAPE2.0 looping extension, used to set up amount of loops in frame.</haxe_doc>
		</EApplicationExtension>
		<EUnknown a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown extension.</haxe_doc>
		</EUnknown>
		<haxe_doc>* Extension block contains additional data about Gif image. This block does not supported by 87a version.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.ApplicationExtension" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<AENetscapeLooping a="loops">
			<x path="Int"/>
			<haxe_doc>* NETSCAPE2.0 looping extension. Contains only amount of animation repeats.
   * Note that there is two NETSCAPE2.0 app extensions for Gif format and the type of extension is stored in first byte of data. Looping extension have ID 1.</haxe_doc>
		</AENetscapeLooping>
		<AEUnknown a="name:version:data">
			<c path="String"/>
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown or unsupported app extension.</haxe_doc>
		</AEUnknown>
		<haxe_doc>* Application extension. Mostly used only for one reason - setting up loops count. There is exist other app extensions but they are really rare.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.gif.ColorTable" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<c path="haxe.io.Bytes"/>
		<haxe_doc>* Typical color table for Gif image.
 * Can contain 2, 4, 8, 16, 32, 64, 128 or 256 colors.
 * Data stored in RGB format. Information about alpha channel provided by Graohic Control Extension.</haxe_doc>
	</typedef>
	<typedef path="format.gif.Frame" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<y>
				<x path="Int"/>
				<haxe_doc>* Y position of image on the Logical Screen</haxe_doc>
			</y>
			<x>
				<x path="Int"/>
				<haxe_doc>* X position of image on the Logical Screen</haxe_doc>
			</x>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Is local color table sorted in order of decreasing priority?</haxe_doc>
			</sorted>
			<pixels>
				<c path="haxe.io.Bytes"/>
				<haxe_doc>* Pixel data of frame. Stored as Indexed colors, 1 byte per pixel.</haxe_doc>
			</pixels>
			<localColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of local color table</haxe_doc>
			</localColorTableSize>
			<localColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this image uses local color table?</haxe_doc>
			</localColorTable>
			<interlaced>
				<x path="Bool"/>
				<haxe_doc>* Is this image written in interlace mode?
   * Note: The pixel data already deinterlaced and this flag presented only for information purpose (and for Writer when there is one).</haxe_doc>
			</interlaced>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of image in pixels</haxe_doc>
			</height>
			<colorTable>
				<t path="format.gif.ColorTable"/>
				<haxe_doc>* Local color table used by frame. Stored as 3-byte RGB colors. If value is null, must be used global color table.</haxe_doc>
			</colorTable>
		</a>
		<haxe_doc>* Single frame of the image.
 * Actually it's a merge of 3 consequent blocks:
 * 1. Image Descriptor.
 * Contains frame informations like position, size, existing of local color table and interlaced flag.
 * 2. [Local color table].
 * Only present if Image Descriptor contains local color table flag. Overrides global color table.
 * 3. Pixel data blocks.
 * LZW compressed pixel data.</haxe_doc>
	</typedef>
	<typedef path="format.gif.GraphicControlExtension" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<userInput>
				<x path="Bool"/>
				<haxe_doc>* Is image must wait for user input, before dispose?
   * This flag may be used by user-defined program but absolutely ignored by any Gif players.</haxe_doc>
			</userInput>
			<transparentIndex>
				<x path="Int"/>
				<haxe_doc>* Index in color table that used as transparent.</haxe_doc>
			</transparentIndex>
			<hasTransparentColor>
				<x path="Bool"/>
				<haxe_doc>* Is image have transparency?</haxe_doc>
			</hasTransparentColor>
			<disposalMethod>
				<e path="format.gif.DisposalMethod"/>
				<haxe_doc>* Disposal method of frame.</haxe_doc>
			</disposalMethod>
			<delay>
				<x path="Int"/>
				<haxe_doc>* Delay, before next image appears. Delay is in centiseconds (1 centisecond = 1/100 seconds).
   * Note: Some players (like FastStone) cut fraction of elapsed time when progressing to next frame which results in small timing error.
   * Recommended to use `time -= delay` instead of `time = 0`.</haxe_doc>
			</delay>
		</a>
		<haxe_doc>* Graphic Control Extension block, used for setting up disposal method, transparency, delay and user input.</haxe_doc>
	</typedef>
	<typedef path="format.gif.PlainTextExtension" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<textGridY>
				<x path="Int"/>
				<haxe_doc>* Y position of text grid on Logical Screen.</haxe_doc>
			</textGridY>
			<textGridX>
				<x path="Int"/>
				<haxe_doc>* X position of text grid on Logical Screen.</haxe_doc>
			</textGridX>
			<textGridWidth>
				<x path="Int"/>
				<haxe_doc>* Width of text grid in pixels.</haxe_doc>
			</textGridWidth>
			<textGridHeight>
				<x path="Int"/>
				<haxe_doc>* Height of text grid in pixels.</haxe_doc>
			</textGridHeight>
			<textForegroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Foreground/character color index.</haxe_doc>
			</textForegroundColorIndex>
			<textBackgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index.</haxe_doc>
			</textBackgroundColorIndex>
			<text>
				<c path="String"/>
				<haxe_doc>* Text to render.</haxe_doc>
			</text>
			<charCellWidth>
				<x path="Int"/>
				<haxe_doc>* Width of character cell in text grid.</haxe_doc>
			</charCellWidth>
			<charCellHeight>
				<x path="Int"/>
				<haxe_doc>* Height of character cell in text grid.</haxe_doc>
			</charCellHeight>
		</a>
		<haxe_doc>* Extension for rendering text on Gif logical screen. It does not supported by major Gif decoders.
 * Font and text size decision is left to decoder. (recommended to decide based on grid/cell size)
 * Text must be rendered with one character at cell.
 * It's recommended to replace any characters less than 0x20 and greater than 0xf7 to be rendered as Space (0x20)</haxe_doc>
	</typedef>
	<typedef path="format.gif.LogicalScreenDescriptor" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of GIF image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Specification:
   * Indicates whether the Global Color Table is sorted.
     If the flag is set, the Global Color Table is sorted, in order of
     decreasing importance. Typically, the order would be decreasing
     frequency, with most frequent color first. This assists a decoder,
     with fewer available colors, in choosing the best subset of colors;
     the decoder may use an initial segment of the table to render the
     graphic.</haxe_doc>
			</sorted>
			<pixelAspectRatio>
				<x path="Float"/>
				<haxe_doc>* Factor used to compute an approximation of the aspect ratio of the pixel in the original image.</haxe_doc>
			</pixelAspectRatio>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of GIF image in pixels</haxe_doc>
			</height>
			<hasGlobalColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this file uses global color table?</haxe_doc>
			</hasGlobalColorTable>
			<globalColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of global color table.</haxe_doc>
			</globalColorTableSize>
			<colorResolution>
				<x path="Int"/>
				<haxe_doc>* Specification:
   * Number of bits per primary color available
     to the original image, minus 1. This value represents the size of
     the entire palette from which the colors in the graphic were
     selected, not the number of colors actually used in the graphic.
     For example, if the value in this field is 3, then the palette of
     the original image had 4 bits per primary color available to create
     the image.  This value should be set to indicate the richness of
     the original palette, even if not every color from the whole
     palette is available on the source machine.</haxe_doc>
			</colorResolution>
			<backgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index in global color table</haxe_doc>
			</backgroundColorIndex>
		</a>
		<haxe_doc>* Logical screen descriptor of GIF file.
 * Contains very basic information about Gif.</haxe_doc>
	</typedef>
	<enum path="format.gif.Version" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<GIF87a><haxe_doc>* First version of Gif file format from May 1987.
   * 
   * Note: The checking of unsupported blocks disabled by default to save some time. To enable supported blocks check set `yagp_strict_version_check` debug variable.</haxe_doc></GIF87a>
		<GIF89a><haxe_doc>* Second and actual version of Gif file format from July 1989.</haxe_doc></GIF89a>
		<Unknown a="version">
			<c path="String"/>
			<haxe_doc>* Unknown version of Gif file.</haxe_doc>
		</Unknown>
		<haxe_doc>* Version of Gif file.  
 * The only 2 official versions is GIF87a and GIF89a.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.DisposalMethod" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Data.hx" module="format.gif.Data">
		<UNSPECIFIED><haxe_doc>* The disposal method is unspecified. Action on demand of viewer.
   * 
   * Mostly interpreted as NO_ACTION.</haxe_doc></UNSPECIFIED>
		<NO_ACTION><haxe_doc>* No action required.</haxe_doc></NO_ACTION>
		<FILL_BACKGROUND><haxe_doc>* Fill frame rectangle with background color.
   * 
   * Usage note: 
   * Most renderers clears to transparency instead of filling background color, when frame's transparent color index not equals to background color index.</haxe_doc></FILL_BACKGROUND>
		<RENDER_PREVIOUS><haxe_doc>* Render previous state of gif as it before rendering disposing frame.</haxe_doc></RENDER_PREVIOUS>
		<UNDEFINED a="index">
			<x path="Int"/>
			<haxe_doc>* Reserved disposal methods.</haxe_doc>
		</UNDEFINED>
		<haxe_doc>* Disposal method of GIF frame.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.gif.Reader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="22"><f a=""><t path="format.gif.Data"/></f></read>
		<readBlock set="method" line="80"><f a=""><e path="format.gif.Block"/></f></readBlock>
		<readImage set="method" line="98"><f a=""><e path="format.gif.Block"/></f></readImage>
		<readPixels set="method" line="129"><f a="width:height:interlaced">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="haxe.io.Bytes"/>
</f></readPixels>
		<deinterlace set="method" line="236"><f a="input:output:step:y:offset:width:height">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></deinterlace>
		<readExtension set="method" line="247"><f a=""><e path="format.gif.Block"/></f></readExtension>
		<readApplicationExtension set="method" line="302"><f a=""><e path="format.gif.Block"/></f></readApplicationExtension>
		<readBlocks get="inline" set="null" line="315"><f a=""><c path="haxe.io.Bytes"/></f></readBlocks>
		<readColorTable set="method" line="332"><f a="size">
	<x path="Int"/>
	<t path="format.gif.ColorTable"/>
</f></readColorTable>
		<new public="1" set="method" line="16"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.gif.Tools" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/gif/Tools.hx">
		<framesCount public="1" set="method" line="16" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of frames in Gif data.</haxe_doc>
		</framesCount>
		<frame public="1" set="method" line="37" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.Frame"/>
			</f>
			<haxe_doc>* Returns frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return Frame at given index or null, if there is no frame at that index.</haxe_doc>
		</frame>
		<graphicControl public="1" set="method" line="59" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.GraphicControlExtension"/>
			</f>
			<haxe_doc>* Returns Graphic Control extension for frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return GCE extension if it is exists for given frame, null otherwise.</haxe_doc>
		</graphicControl>
		<extractBGRA public="1" set="method" line="90" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Blue-Green-Red-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractBGRA>
		<extractRGBA public="1" set="method" line="141" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Red-Green-Blue-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractRGBA>
		<extractFullBGRA public="1" set="method" line="192" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Blue-Green-Red-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullBGRA>
		<extractFullRGBA public="1" set="method" line="278" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Red-Green-Blue-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullRGBA>
		<loopCount public="1" set="method" line="363" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of animation repeats stored in Gif data.
   * This is link to Netscape Looping application extension. If this extension does not present amount of loops equals to 1.
   * @param data Gif data.
   * @return Amount of animation repeats. Zero equals to infinite amount of repeats.</haxe_doc>
		</loopCount>
		<LN2 expr="Math.log(2)" line="385" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.log(2)</e></m></meta>
		</LN2>
		<log2 public="1" get="inline" set="null" line="386" static="1">
			<f a="val">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</log2>
		<haxe_doc>* Tools for gif data.
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.mp3.SamplingRate" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<SR_8000/>
		<SR_11025/>
		<SR_12000/>
		<SR_22050/>
		<SR_24000/>
		<SR_32000/>
		<SR_44100/>
		<SR_48000/>
		<SR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Bitrate" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<BR_8/>
		<BR_16/>
		<BR_24/>
		<BR_32/>
		<BR_40/>
		<BR_48/>
		<BR_56/>
		<BR_64/>
		<BR_80/>
		<BR_96/>
		<BR_112/>
		<BR_128/>
		<BR_144/>
		<BR_160/>
		<BR_176/>
		<BR_192/>
		<BR_224/>
		<BR_256/>
		<BR_288/>
		<BR_320/>
		<BR_352/>
		<BR_384/>
		<BR_416/>
		<BR_448/>
		<BR_Free/>
		<BR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.MPEG" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Constants.hx" module="format.mp3.Constants">
		<V1 public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</V1>
		<V2 public="1" get="inline" set="null" expr="2" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</V2>
		<V25 public="1" get="inline" set="null" expr="0" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</V25>
		<Reserved public="1" expr="1" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</Reserved>
		<enum2Num public="1" set="method" line="16" static="1"><f a="m">
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="25" static="1"><f a="m">
	<x path="Int"/>
	<e path="format.mp3.MPEGVersion"/>
</f></num2Enum>
		<V1_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]" line="35" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]</e></m></meta>
		</V1_Bitrates>
		<V2_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]" line="43" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]</e></m></meta>
		</V2_Bitrates>
		<SamplingRates public="1" expr="[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]" line="51" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.SamplingRate"/></c></c>
			<meta><m n=":value"><e>[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]</e></m></meta>
		</SamplingRates>
		<srNum2Enum public="1" set="method" line="58" static="1"><f a="sr">
	<x path="Int"/>
	<e path="format.mp3.SamplingRate"/>
</f></srNum2Enum>
		<srEnum2Num public="1" set="method" line="72" static="1"><f a="sr">
	<e path="format.mp3.SamplingRate"/>
	<x path="Int"/>
</f></srEnum2Num>
		<getBitrateIdx public="1" set="method" line="87" static="1"><f a="br:mpeg:layer">
	<e path="format.mp3.Bitrate"/>
	<e path="format.mp3.MPEGVersion"/>
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></getBitrateIdx>
		<getSamplingRateIdx public="1" set="method" line="96" static="1"><f a="sr:mpeg">
	<e path="format.mp3.SamplingRate"/>
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></getSamplingRateIdx>
		<bitrateEnum2Num public="1" set="method" line="105" static="1"><f a="br">
	<e path="format.mp3.Bitrate"/>
	<x path="Int"/>
</f></bitrateEnum2Num>
		<bitrateNum2Enum public="1" set="method" line="136" static="1"><f a="br">
	<x path="Int"/>
	<e path="format.mp3.Bitrate"/>
</f></bitrateNum2Enum>
		<haxe_doc>* MPEG Version
 *
 * sored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CLayer" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Constants.hx" module="format.mp3.Constants">
		<LReserved public="1" expr="0" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</LReserved>
		<LLayer3 public="1" expr="1" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LLayer3>
		<LLayer2 public="1" expr="2" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LLayer2>
		<LLayer1 public="1" expr="3" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LLayer1>
		<enum2Num public="1" set="method" line="182" static="1"><f a="l">
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="191" static="1"><f a="l">
	<x path="Int"/>
	<e path="format.mp3.Layer"/>
</f></num2Enum>
		<haxe_doc>* Layer
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CChannelMode" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Constants.hx" module="format.mp3.Constants">
		<CStereo public="1" get="inline" set="null" expr="0" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CStereo>
		<CJointStereo public="1" get="inline" set="null" expr="1" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CJointStereo>
		<CDualChannel public="1" get="inline" set="null" expr="2" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CDualChannel>
		<CMono public="1" get="inline" set="null" expr="3" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CMono>
		<enum2Num public="1" set="method" line="214" static="1"><f a="c">
	<e path="format.mp3.ChannelMode"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="223" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.ChannelMode"/>
</f></num2Enum>
		<haxe_doc>* Sound channel mode
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CEmphasis" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Constants.hx" module="format.mp3.Constants">
		<ENone public="1" get="inline" set="null" expr="0" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ENone>
		<EMs50_15 public="1" get="inline" set="null" expr="1" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EMs50_15>
		<EReserved public="1" get="inline" set="null" expr="2" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</EReserved>
		<ECCIT_J17 public="1" get="inline" set="null" expr="3" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ECCIT_J17>
		<enum2Num public="1" set="method" line="245" static="1"><f a="c">
	<e path="format.mp3.Emphasis"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="254" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.Emphasis"/>
</f></num2Enum>
		<haxe_doc>* Emphasis
 *
 * 2 bits</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.mp3.MP3" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<sampleSize><x path="Int"/></sampleSize>
	<sampleCount><x path="Int"/></sampleCount>
	<id3v2><t path="format.mp3.ID3v2Info"/></id3v2>
	<frames><c path="Array"><t path="format.mp3.MP3Frame"/></c></frames>
</a></typedef>
	<typedef path="format.mp3.ID3v2Info" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<versionBytes><x path="Int"/></versionBytes>
	<flagByte><x path="Int"/></flagByte>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Frame" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<header><t path="format.mp3.MP3Header"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Header" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<version><e path="format.mp3.MPEGVersion"/></version>
	<samplingRate><e path="format.mp3.SamplingRate"/></samplingRate>
	<privateBit><x path="Bool"/></privateBit>
	<layer><e path="format.mp3.Layer"/></layer>
	<isPadded><x path="Bool"/></isPadded>
	<isOriginal><x path="Bool"/></isOriginal>
	<isMSStereo><x path="Bool"/></isMSStereo>
	<isIntensityStereo><x path="Bool"/></isIntensityStereo>
	<isCopyrighted><x path="Bool"/></isCopyrighted>
	<hasCrc><x path="Bool"/></hasCrc>
	<emphasis><e path="format.mp3.Emphasis"/></emphasis>
	<crc16><x path="Int"/></crc16>
	<channelMode><e path="format.mp3.ChannelMode"/></channelMode>
	<bitrate><e path="format.mp3.Bitrate"/></bitrate>
</a></typedef>
	<enum path="format.mp3.MPEGVersion" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<MPEG_V1/>
		<MPEG_V2/>
		<MPEG_V25/>
		<MPEG_Reserved/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Layer" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<LayerReserved/>
		<Layer3/>
		<Layer2/>
		<Layer1/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.ChannelMode" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<Stereo/>
		<JointStereo/>
		<DualChannel/>
		<Mono/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Emphasis" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Data.hx" module="format.mp3.Data">
		<NoEmphasis/>
		<Ms50_15/>
		<CCIT_J17/>
		<InvalidEmphasis/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.FrameType" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Reader.hx" module="format.mp3.Reader">
		<FT_MP3/>
		<FT_NONE/>
		<haxe_doc>* Used by seekFrame to retrun the type
 * of frame (possibly) found.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.Reader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<bits><c path="format.tools.BitsInput"/></bits>
		<version><x path="Int"/></version>
		<samples><x path="Int"/></samples>
		<sampleSize><x path="Int"/></sampleSize>
		<any_read><x path="Bool"/></any_read>
		<id3v2_data><c path="haxe.io.Bytes"/></id3v2_data>
		<id3v2_version><x path="Int"/></id3v2_version>
		<id3v2_flags><x path="Int"/></id3v2_flags>
		<skipID3v2 public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called after found 'ID3' signature
    * at the beginning of the file.
    *
    * Records the raw tag data.</haxe_doc>
		</skipID3v2>
		<seekFrame public="1" set="method" line="101">
			<f a=""><e path="format.mp3.FrameType"/></f>
			<haxe_doc>* Winds the input stream until the 11-bit
    * syncword is found.
    *
    * @returns Bool false if not found (this should happen at eof).</haxe_doc>
		</seekFrame>
		<readFrames public="1" set="method" line="150">
			<f a=""><c path="Array"><t path="format.mp3.MP3Frame"/></c></f>
			<haxe_doc>* Returns all valid frames. Invalid frames
    * are discarded.</haxe_doc>
		</readFrames>
		<readFrameHeader public="1" set="method" line="170">
			<f a=""><t path="format.mp3.MP3Header"/></f>
			<haxe_doc>* Returns null if header proves to be invalid.</haxe_doc>
		</readFrameHeader>
		<readFrame public="1" set="method" line="250">
			<f a=""><t path="format.mp3.MP3Frame"/></f>
			<haxe_doc>* Reads a frame from the input.
    *
    * The input position should already be just past the
    * 11 bit syncword.
    *
    * Returns null if the header is invalid or the frame was incomplete.</haxe_doc>
		</readFrame>
		<read public="1" set="method" line="280">
			<f a=""><t path="format.mp3.MP3"/></f>
			<haxe_doc>* Reads the MP3 data.
    *
    * Currently returns all valid frames.</haxe_doc>
		</read>
		<new public="1" set="method" line="62"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.Tools" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/mp3/Tools.hx">
		<getBitrate public="1" set="method" line="40" static="1">
			<f a="mpegVersion:layerIdx:bitrateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.Bitrate"/>
			</f>
			<haxe_doc>* Returns kbps</haxe_doc>
		</getBitrate>
		<getSamplingRate public="1" set="method" line="50" static="1">
			<f a="mpegVersion:samplingRateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.SamplingRate"/>
			</f>
			<haxe_doc>* Returns Hz</haxe_doc>
		</getSamplingRate>
		<isInvalidFrameHeader public="1" set="method" line="57" static="1">
			<f a="hdr">
				<t path="format.mp3.MP3Header"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Tells whether the header is invalid.</haxe_doc>
		</isInvalidFrameHeader>
		<getSampleDataSize public="1" set="method" line="74" static="1">
			<f a="mpegVersion:bitrate:samplingRate:isPadded:hasCrc">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return sample data size. Note that
    * the 4 bytes subtracted is the size of the header,
    * so this 4 bytes less the frame size.
    *
    * Also, 2 bytes are subtracted for CRC too, if present</haxe_doc>
		</getSampleDataSize>
		<getSampleDataSizeHdr public="1" set="method" line="78" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleDataSizeHdr>
		<getSampleCount public="1" set="method" line="89" static="1">
			<f a="mpegVersion">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the number of samples in the frame.</haxe_doc>
		</getSampleCount>
		<getSampleCountHdr public="1" set="method" line="94" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleCountHdr>
		<getFrameInfo public="1" set="method" line="102" static="1">
			<f a="fr">
				<t path="format.mp3.MP3Frame"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Displays frame info in human-readable format.
    * Subject to change, do not use for programmatical parsing!</haxe_doc>
		</getFrameInfo>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.png.Color" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Data.hx" module="format.png.Data">
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Header" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Data.hx" module="format.png.Data">
		<CEnd/>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Data" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Data.hx"><t path="List"><e path="format.png.Chunk"/></t></typedef>
	<class path="format.png.Reader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Tools" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1">
			<f a="data:x:y:stride:prev:p:?numChannels" v="::::::4">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ numChannels : 4 }</e></m></meta>
		</filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes:?flipY">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="653" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildIndexed public="1" set="method" line="672" static="1">
			<f a="width:height:data:palette:?level" v="::::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains a one byte palette index for each pixel and a separate palette with 3 RGB bytes per color.</haxe_doc>
		</buildIndexed>
		<buildRGB public="1" set="method" line="691" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="714" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="738" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Writer" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/png/Writer.hx">
		<o><c path="haxe.io.Output"/></o>
		<write public="1" set="method" line="39"><f a="png">
	<t path="format.png.Data"/>
	<x path="Void"/>
</f></write>
		<writeChunk set="method" line="75"><f a="id:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeChunk>
		<new public="1" set="method" line="34"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.tga.Header" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tga/Data.hx" module="format.tga.Data"><a>
	<yOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute vertical coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</yOrigin>
	<xOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute horizontal coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</xOrigin>
	<width>
		<x path="Int"/>
		<haxe_doc>This field specifies the width of the image in pixels.</haxe_doc>
	</width>
	<imageType>
		<e path="format.tga.ImageType"/>
		<haxe_doc>Image data type.</haxe_doc>
	</imageType>
	<imageOrigin><e path="format.tga.ImageOrigin"/></imageOrigin>
	<height>
		<x path="Int"/>
		<haxe_doc>This field specifies the height of the image in pixels.</haxe_doc>
	</height>
	<colorMapType>
		<x path="Int"/>
		<haxe_doc>* Indicated type of color map.
   * 0 = no color map present.
   * 1 = color map included.
   * 2-127 is reserved by Truevision
   * 128-255 may be used by app developers.</haxe_doc>
	</colorMapType>
	<colorMapLength>
		<x path="Int"/>
		<haxe_doc>Total number of color map entries included.</haxe_doc>
	</colorMapLength>
	<colorMapFirstIndex>
		<x path="Int"/>
		<haxe_doc>* Index of the first color map entry. Index refers to the starting entry in
   * loading the color map.</haxe_doc>
	</colorMapFirstIndex>
	<colorMapEntrySize>
		<x path="Int"/>
		<haxe_doc>* Establishes the number of bits per entry. Typically 15, 16, 24 or 32-bit
   * values are used.</haxe_doc>
	</colorMapEntrySize>
	<bitsPerPixel>
		<x path="Int"/>
		<haxe_doc>* This field indicates the number of bits per pixel. This number includes
   * the Attribute or Alpha channel bits. Common values are 8, 16, 24 and
   * 32 but other pixel depths could be used.</haxe_doc>
	</bitsPerPixel>
	<alphaChannelBits>
		<x path="Int"/>
		<haxe_doc>* the number of attribute bits per
   * pixel. In the case of the TrueVista, these bits
   * indicate the number of bits per pixel which are
   * designated as Alpha Channel bits. For the ICB
   * and TARGA products, these bits indicate the
   * number of overlay bits available per pixel.</haxe_doc>
	</alphaChannelBits>
</a></typedef>
	<enum path="format.tga.ImageOrigin" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tga/Data.hx" module="format.tga.Data">
		<BottomLeft/>
		<BottomRight/>
		<TopLeft/>
		<TopRight/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.tga.ImageType" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tga/Data.hx" module="format.tga.Data">
		<NoImage><haxe_doc>There is no image data present</haxe_doc></NoImage>
		<UncompressedColorMapped><haxe_doc>Uncompressed image with color-map usage</haxe_doc></UncompressedColorMapped>
		<UncompressedTrueColor><haxe_doc>True-color uncompressed image</haxe_doc></UncompressedTrueColor>
		<UncompressedBlackAndWhite><haxe_doc>Black-and-White uncompresed image</haxe_doc></UncompressedBlackAndWhite>
		<RunLengthColorMapped><haxe_doc>Run-length encoded image with color-map usage</haxe_doc></RunLengthColorMapped>
		<RunLengthTrueColor><haxe_doc>Run-length encoded true-color image</haxe_doc></RunLengthTrueColor>
		<RunLengthBlackAndWhite><haxe_doc>Run-length encoded black-and-white image</haxe_doc></RunLengthBlackAndWhite>
		<Unknown a="type">
			<x path="Int"/>
			<haxe_doc>Unknown type</haxe_doc>
		</Unknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.tga.Data" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tga/Data.hx"><a>
	<imageId><c path="String"/></imageId>
	<imageData><x path="haxe.ds.Vector"><x path="Int"/></x></imageData>
	<header><t path="format.tga.Header"/></header>
	<developerData><d/></developerData>
	<colorMapData><x path="haxe.ds.Vector"><x path="Int"/></x></colorMapData>
</a></typedef>
	<class path="format.tga.Reader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tga/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="21"><f a=""><t path="format.tga.Data"/></f></read>
		<readHeader set="method" line="37"><f a=""><t path="format.tga.Header"/></f></readHeader>
		<readColorMapData set="method" line="103"><f a="header">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readColorMapData>
		<readImageData set="method" line="109"><f a="header:colorMap">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readImageData>
		<readPixels set="method" line="136"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readPixels>
		<readMono set="method" line="206"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readMono>
		<readIndexes set="method" line="266"><f a="bitsPerPixel:amount:colorMap:offset:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readIndexes>
		<parsePixel1 set="method" line="324"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel1>
		<parsePixelGreyAlpha set="method" line="329"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixelGreyAlpha>
		<parsePixel2 set="method" line="334"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel2>
		<parsePixel3 set="method" line="342"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel3>
		<parsePixel4 set="method" line="347"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel4>
		<new public="1" set="method" line="15"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.BitsInput" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tools/BitsInput.hx">
		<i><c path="haxe.io.Input"/></i>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<readBits public="1" set="method" line="41"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readBit public="1" set="method" line="63"><f a=""><x path="Bool"/></f></readBit>
		<reset public="1" get="inline" set="null" line="72"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Deflate" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tools/Deflate.hx">
		<run public="1" set="method" line="31" static="1">
			<f a="b:?level" v=":9">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Inflate" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/tools/Inflate.hx">
		<run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.wav.WAVE" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/wav/Data.hx" module="format.wav.Data"><a>
	<header><t path="format.wav.WAVEHeader"/></header>
	<data><c path="haxe.io.Bytes"/></data>
	<cuePoints><c path="Array"><t path="format.wav.CuePoint"/></c></cuePoints>
</a></typedef>
	<typedef path="format.wav.WAVEHeader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/wav/Data.hx" module="format.wav.Data"><a>
	<samplingRate><x path="Int"/></samplingRate>
	<format><e path="format.wav.WAVEFormat"/></format>
	<channels><x path="Int"/></channels>
	<byteRate><x path="Int"/></byteRate>
	<blockAlign><x path="Int"/></blockAlign>
	<bitsPerSample><x path="Int"/></bitsPerSample>
</a></typedef>
	<typedef path="format.wav.CuePoint" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/wav/Data.hx" module="format.wav.Data"><a>
	<sampleOffset><x path="Int"/></sampleOffset>
	<id><x path="Int"/></id>
</a></typedef>
	<enum path="format.wav.WAVEFormat" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/wav/Data.hx" module="format.wav.Data">
		<WF_PCM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.wav.Reader" params="" file="/usr/local/lib/haxeLibrary/format/3,5,0/format/wav/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readInt get="inline" set="null" line="43"><f a=""><x path="Int"/></f></readInt>
		<read public="1" set="method" line="51"><f a=""><t path="format.wav.WAVE"/></f></read>
		<new public="1" set="method" line="38"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="fracs.DifferencePreference" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Angles.hx" module="fracs.Angles">
		<CLOCKWISE/>
		<ANTICLOCKWISE/>
		<SMALL/>
		<LARGE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="fracs.Angles" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Angles.hx">
		<pi2pi public="1" get="inline" set="null" line="11" static="1"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></pi2pi>
		<zeroto2pi public="1" get="inline" set="null" line="19" static="1"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></zeroto2pi>
		<zerotoMinus2pi public="1" get="inline" set="null" line="27" static="1"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></zerotoMinus2pi>
		<differencePrefer public="1" get="inline" set="null" line="36" static="1"><f a="a:b:prefer">
	<x path="Float"/>
	<x path="Float"/>
	<e path="fracs.DifferencePreference"/>
	<x path="Float"/>
</f></differencePrefer>
		<difference public="1" get="inline" set="null" line="48" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></difference>
		<differenceClockWise public="1" get="inline" set="null" line="57" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></differenceClockWise>
		<differenceAntiClockwise public="1" get="inline" set="null" line="61" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></differenceAntiClockwise>
		<differenceSmall public="1" get="inline" set="null" line="65" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></differenceSmall>
		<differenceLarge public="1" get="inline" set="null" line="80" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></differenceLarge>
		<differenceSmallLarge public="1" get="inline" set="null" line="95" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<a>
		<small><x path="Float"/></small>
		<large><x path="Float"/></large>
	</a>
</f></differenceSmallLarge>
	</class>
	<typedef path="fracs.Fractional" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" module="fracs.Fraction"><a>
	<value><x path="Null"><x path="Float"/></x></value>
	<positive><x path="Bool"/></positive>
	<numerator><x path="Int"/></numerator>
	<denominator><x path="Int"/></denominator>
</a></typedef>
	<abstract path="fracs.FractionArray" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" module="fracs.Fraction">
		<from><icast><c path="Array"><x path="fracs.Fraction"/></c></icast></from>
		<this><c path="Array"><x path="fracs.Fraction"/></c></this>
		<to>
			<icast><c path="Array"><x path="fracs.Fraction"/></c></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="fracs._Fraction.FractionArray_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" private="1" module="fracs.Fraction" final="1">
	<_new public="1" get="inline" set="null" line="14" static="1">
		<f a="?val">
			<c path="Array"><x path="fracs.Fraction"/></c>
			<x path="fracs.FractionArray"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<add public="1" get="inline" set="null" line="17" static="1">
		<f a="this:val">
			<c path="Array"><x path="fracs.Fraction"/></c>
			<x path="fracs.Fraction"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</add>
	<toString public="1" get="inline" set="null" line="22" static="1">
		<f a="this">
			<c path="Array"><x path="fracs.Fraction"/></c>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
</class></impl>
	</abstract>
	<class path="fracs._Fraction.FractionArray_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" private="1" module="fracs.Fraction" final="1">
		<_new public="1" get="inline" set="null" line="14" static="1">
			<f a="?val">
				<c path="Array"><x path="fracs.Fraction"/></c>
				<x path="fracs.FractionArray"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<add public="1" get="inline" set="null" line="17" static="1">
			<f a="this:val">
				<c path="Array"><x path="fracs.Fraction"/></c>
				<x path="fracs.Fraction"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</add>
		<toString public="1" get="inline" set="null" line="22" static="1">
			<f a="this">
				<c path="Array"><x path="fracs.Fraction"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
	</class>
	<abstract path="fracs.Fraction" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx">
		<from>
			<icast><t path="fracs.Fractional"/></icast>
			<icast field="fromString"><c path="String"/></icast>
			<icast field="fromFloat"><x path="Float"/></icast>
		</from>
		<this><t path="fracs.Fractional"/></this>
		<to>
			<icast><t path="fracs.Fractional"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<impl><class path="fracs._Fraction.Fraction_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" private="1" module="fracs.Fraction" final="1">
	<_new public="1" get="inline" set="null" line="32" static="1">
		<f a="numerator:denominator:?positive:?value" v="::true:null">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : null, positive : true }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<optimize get="inline" set="null" line="44" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta><m n=":impl"/></meta>
	</optimize>
	<optimizeFraction get="inline" set="null" line="48" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta><m n=":impl"/></meta>
	</optimizeFraction>
	<toFloat public="1" get="inline" set="null" line="53" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFloat>
	<float public="1" get="inline" set="null" line="61" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</float>
	<verbose public="1" get="inline" set="null" line="65" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</verbose>
	<fromString public="1" get="inline" set="null" line="70" static="1">
		<f a="val">
			<c path="String"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="81" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<fromFloat public="1" get="inline" set="null" line="97" static="1">
		<f a="f">
			<x path="Float"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat>
	<firstFloat public="1" get="inline" set="null" line="118" static="1"><f a="f">
	<x path="Float"/>
	<x path="fracs.Fraction"/>
</f></firstFloat>
	<byDenominator public="1" get="inline" set="null" line="125" static="1">
		<f a="this:val">
			<t path="fracs.Fractional"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</byDenominator>
	<all public="1" get="inline" set="null" line="136" static="1"><f a="f">
	<x path="Float"/>
	<x path="fracs.FractionArray"/>
</f></all>
	<similarToFraction public="1" get="inline" set="null" line="140" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="fracs.FractionArray"/>
		</f>
		<meta><m n=":impl"/></meta>
	</similarToFraction>
	<similarToValue public="1" get="inline" set="null" line="145" static="1">
		<f a="this">
			<t path="fracs.Fractional"/>
			<x path="fracs.FractionArray"/>
		</f>
		<meta><m n=":impl"/></meta>
	</similarToValue>
</class></impl>
	</abstract>
	<class path="fracs._Fraction.Fraction_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" private="1" module="fracs.Fraction" final="1">
		<_new public="1" get="inline" set="null" line="32" static="1">
			<f a="numerator:denominator:?positive:?value" v="::true:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : null, positive : true }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<optimize get="inline" set="null" line="44" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta><m n=":impl"/></meta>
		</optimize>
		<optimizeFraction get="inline" set="null" line="48" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta><m n=":impl"/></meta>
		</optimizeFraction>
		<toFloat public="1" get="inline" set="null" line="53" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFloat>
		<float public="1" get="inline" set="null" line="61" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</float>
		<verbose public="1" get="inline" set="null" line="65" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</verbose>
		<fromString public="1" get="inline" set="null" line="70" static="1">
			<f a="val">
				<c path="String"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="81" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<fromFloat public="1" get="inline" set="null" line="97" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat>
		<firstFloat public="1" get="inline" set="null" line="118" static="1"><f a="f">
	<x path="Float"/>
	<x path="fracs.Fraction"/>
</f></firstFloat>
		<byDenominator public="1" get="inline" set="null" line="125" static="1">
			<f a="this:val">
				<t path="fracs.Fractional"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</byDenominator>
		<all public="1" get="inline" set="null" line="136" static="1"><f a="f">
	<x path="Float"/>
	<x path="fracs.FractionArray"/>
</f></all>
		<similarToFraction public="1" get="inline" set="null" line="140" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="fracs.FractionArray"/>
			</f>
			<meta><m n=":impl"/></meta>
		</similarToFraction>
		<similarToValue public="1" get="inline" set="null" line="145" static="1">
			<f a="this">
				<t path="fracs.Fractional"/>
				<x path="fracs.FractionArray"/>
			</f>
			<meta><m n=":impl"/></meta>
		</similarToValue>
	</class>
	<class path="fracs.Fracs" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Fraction.hx" module="fracs.Fraction">
		<grabDecimalInput get="inline" set="null" line="153" static="1"><f a="decimalVal">
	<c path="String"/>
	<x path="Float"/>
</f></grabDecimalInput>
		<approximateFractions set="method" line="159" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.FractionArray"/>
			</f>
			<meta><m n=":allow"><e>fracs.Fraction</e></m></meta>
		</approximateFractions>
		<getMaxNumerator get="inline" set="null" line="185" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></getMaxNumerator>
		<extractDigitStr get="inline" set="null" line="218" static="1"><f a="fStr">
	<c path="String"/>
	<c path="String"/>
</f></extractDigitStr>
		<getMaxNumeratorStr get="inline" set="null" line="239" static="1"><f a="fStr">
	<c path="String"/>
	<x path="Float"/>
</f></getMaxNumeratorStr>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="fracs.Pi2pi" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Pi2pi.hx">
		<from>
			<icast field="fromFloat"><x path="Float"/></icast>
			<icast field="fromFraction"><x path="fracs.Fraction"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Float"/></this>
		<to>
			<icast><x path="Float"/></icast>
			<icast field="tofraction"><x path="fracs.Fraction"/></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<meta><m n="forward"/></meta>
		<impl><class path="fracs._Pi2pi.Pi2pi_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Pi2pi.hx" private="1" module="fracs.Pi2pi" final="1">
	<_new get="inline" set="null" line="5" static="1">
		<f a="f">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromFloat public="1" get="inline" set="null" line="10" static="1">
		<f a="f">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat>
	<additionPi public="1" set="method" line="20" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</additionPi>
	<subtractionPi public="1" set="method" line="24" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subtractionPi>
	<dividePi public="1" set="method" line="28" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</dividePi>
	<timesPi public="1" set="method" line="32" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</timesPi>
	<addition public="1" set="method" line="36" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</addition>
	<subtraction public="1" set="method" line="40" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subtraction>
	<divide public="1" set="method" line="44" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</divide>
	<times public="1" set="method" line="48" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</times>
	<degrees public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</degrees>
	<get_degrees public="1" get="inline" set="null" line="52" static="1">
		<f a="this">
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_degrees>
	<set_degrees public="1" get="inline" set="null" line="56" static="1">
		<f a="this:val">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_degrees>
	<fromFraction get="inline" set="null" line="62" static="1">
		<f a="val">
			<x path="fracs.Fraction"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFraction>
	<tofraction get="inline" set="null" line="67" static="1">
		<f a="this">
			<x path="Float"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</tofraction>
	<fromString get="inline" set="null" line="71" static="1">
		<f a="val">
			<c path="String"/>
			<x path="fracs.Pi2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="77" static="1">
		<f a="this">
			<x path="Float"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
</class></impl>
	</abstract>
	<class path="fracs._Pi2pi.Pi2pi_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/Pi2pi.hx" private="1" module="fracs.Pi2pi" final="1">
		<_new get="inline" set="null" line="5" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromFloat public="1" get="inline" set="null" line="10" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat>
		<additionPi public="1" set="method" line="20" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</additionPi>
		<subtractionPi public="1" set="method" line="24" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subtractionPi>
		<dividePi public="1" set="method" line="28" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</dividePi>
		<timesPi public="1" set="method" line="32" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</timesPi>
		<addition public="1" set="method" line="36" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</addition>
		<subtraction public="1" set="method" line="40" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subtraction>
		<divide public="1" set="method" line="44" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</divide>
		<times public="1" set="method" line="48" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</times>
		<degrees public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</degrees>
		<get_degrees public="1" get="inline" set="null" line="52" static="1">
			<f a="this">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_degrees>
		<set_degrees public="1" get="inline" set="null" line="56" static="1">
			<f a="this:val">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_degrees>
		<fromFraction get="inline" set="null" line="62" static="1">
			<f a="val">
				<x path="fracs.Fraction"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFraction>
		<tofraction get="inline" set="null" line="67" static="1">
			<f a="this">
				<x path="Float"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</tofraction>
		<fromString get="inline" set="null" line="71" static="1">
			<f a="val">
				<c path="String"/>
				<x path="fracs.Pi2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="77" static="1">
			<f a="this">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
	</class>
	<abstract path="fracs.ZeroTo2pi" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/ZeroTo2pi.hx">
		<from>
			<icast field="fromFloat"><x path="Float"/></icast>
			<icast field="fromFraction"><x path="fracs.Fraction"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Float"/></this>
		<to>
			<icast><x path="Float"/></icast>
			<icast field="tofraction"><x path="fracs.Fraction"/></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<meta><m n="forward"/></meta>
		<impl><class path="fracs._ZeroTo2pi.ZeroTo2pi_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/ZeroTo2pi.hx" private="1" module="fracs.ZeroTo2pi" final="1">
	<_new get="inline" set="null" line="5" static="1">
		<f a="f">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromFloat public="1" get="inline" set="null" line="10" static="1">
		<f a="f">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat>
	<additionPi public="1" set="method" line="20" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</additionPi>
	<subtractionPi public="1" set="method" line="24" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subtractionPi>
	<dividePi public="1" set="method" line="28" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</dividePi>
	<timesPi public="1" set="method" line="32" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</timesPi>
	<addition public="1" set="method" line="36" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</addition>
	<subtraction public="1" set="method" line="40" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subtraction>
	<divide public="1" set="method" line="44" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</divide>
	<times public="1" set="method" line="48" static="1">
		<f a="this:b">
			<x path="Float"/>
			<x path="Float"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</times>
	<degrees public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</degrees>
	<get_degrees public="1" get="inline" set="null" line="52" static="1">
		<f a="this">
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_degrees>
	<set_degrees public="1" get="inline" set="null" line="56" static="1">
		<f a="this:val">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_degrees>
	<fromFraction get="inline" set="null" line="62" static="1">
		<f a="val">
			<x path="fracs.Fraction"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFraction>
	<tofraction get="inline" set="null" line="67" static="1">
		<f a="this">
			<x path="Float"/>
			<x path="fracs.Fraction"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</tofraction>
	<fromString get="inline" set="null" line="71" static="1">
		<f a="val">
			<c path="String"/>
			<x path="fracs.ZeroTo2pi"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="77" static="1">
		<f a="this">
			<x path="Float"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
</class></impl>
	</abstract>
	<class path="fracs._ZeroTo2pi.ZeroTo2pi_Impl_" params="" file="/usr/local/lib/haxeLibrary/fracs/git/src/fracs/ZeroTo2pi.hx" private="1" module="fracs.ZeroTo2pi" final="1">
		<_new get="inline" set="null" line="5" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromFloat public="1" get="inline" set="null" line="10" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat>
		<additionPi public="1" set="method" line="20" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</additionPi>
		<subtractionPi public="1" set="method" line="24" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subtractionPi>
		<dividePi public="1" set="method" line="28" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</dividePi>
		<timesPi public="1" set="method" line="32" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</timesPi>
		<addition public="1" set="method" line="36" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</addition>
		<subtraction public="1" set="method" line="40" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subtraction>
		<divide public="1" set="method" line="44" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</divide>
		<times public="1" set="method" line="48" static="1">
			<f a="this:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</times>
		<degrees public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</degrees>
		<get_degrees public="1" get="inline" set="null" line="52" static="1">
			<f a="this">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_degrees>
		<set_degrees public="1" get="inline" set="null" line="56" static="1">
			<f a="this:val">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_degrees>
		<fromFraction get="inline" set="null" line="62" static="1">
			<f a="val">
				<x path="fracs.Fraction"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFraction>
		<tofraction get="inline" set="null" line="67" static="1">
			<f a="this">
				<x path="Float"/>
				<x path="fracs.Fraction"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</tofraction>
		<fromString get="inline" set="null" line="71" static="1">
			<f a="val">
				<c path="String"/>
				<x path="fracs.ZeroTo2pi"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="77" static="1">
			<f a="this">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
	</class>
	<class path="h2d.Object" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Object.hx">
		<nullDrawable static="1"><c path="h2d.Drawable"/></nullDrawable>
		<children><c path="Array"><c path="h2d.Object"/></c></children>
		<parentContainer><c path="h2d.Object"/></parentContainer>
		<parent public="1" set="null">
			<c path="h2d.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The x position (in pixels) of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The y position (in pixels) of the object relative to its parent.</haxe_doc>
		</y>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of horizontal scaling of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of vertical scaling of this object (default 1.0)</haxe_doc>
		</scaleY>
		<rotation public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The rotation angle of this object, in radians.</haxe_doc>
		</rotation>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<alpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
			<haxe_doc>The amount of transparency of the Object (default 1.0)</haxe_doc>
		</alpha>
		<filter public="1" set="accessor">
			<c path="h2d.filter.Filter"/>
			<haxe_doc>The post process filter for this object.
		When set, `alpha` value affects both filter and object transparency (use `Drawable.color.a` to set transparency only for the object).</haxe_doc>
		</filter>
		<blendMode public="1">
			<e path="h2d.BlendMode"/>
			<haxe_doc>The blendMode of the object (default Alpha).
		If there is no filter active, only apply to the current object (not inherited by children)
		If there is a filter active, tells how the filter is blended with background.</haxe_doc>
		</blendMode>
		<matA><x path="Float"/></matA>
		<matB><x path="Float"/></matB>
		<matC><x path="Float"/></matC>
		<matD><x path="Float"/></matD>
		<absX><x path="Float"/></absX>
		<absY><x path="Float"/></absY>
		<posChanged><x path="Bool"/></posChanged>
		<allocated><x path="Bool"/></allocated>
		<lastFrame><x path="Int"/></lastFrame>
		<getBounds public="1" set="method" line="116">
			<f a="?relativeTo:?out">
				<c path="h2d.Object"/>
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Return the bounds of the object for its whole content, recursively.
		If relativeTo is null, it will return the bounds in the absolute coordinates.
		If not, it will return the bounds relative to the specified object coordinates.
		You can pass an already allocated bounds or getBounds will allocate one for you and return it.</haxe_doc>
		</getBounds>
		<getSize public="1" set="method" line="136">
			<f a="?out">
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Similar to getBounds(parent), but instead of the full content, it will return
		the size based on the alignement of the object. For instance for a text, getBounds will return
		the full glyphs size whereas getSize() will ignore the pixels under the baseline.</haxe_doc>
		</getSize>
		<getAbsPos public="1" set="method" line="153">
			<f a=""><c path="h2d.col.Matrix"/></f>
			<haxe_doc>Returns the updated absolute position matrix.</haxe_doc>
		</getAbsPos>
		<find public="1" params="T" set="method" line="168">
			<f a="f">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="182">
			<f a="f:?arr">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<set_filter set="method" line="192"><f a="f">
	<c path="h2d.filter.Filter"/>
	<c path="h2d.filter.Filter"/>
</f></set_filter>
		<getBoundsRec set="method" line="199"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<addBounds set="method" line="232"><f a="relativeTo:out:dx:dy:width:height">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<getObjectsCount public="1" set="method" line="287">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<localToGlobal public="1" set="method" line="297">
			<f a="?pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute screen position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="310">
			<f a="pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert an absolute screen position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getScene public="1" set="method" line="322"><f a=""><c path="h2d.Scene"/></f></getScene>
		<set_visible set="method" line="328"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<addChild public="1" set="method" line="339">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="346">
			<f a="s:pos">
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<onContentChanged get="inline" set="null" line="380"><f a=""><x path="Void"/></f></onContentChanged>
		<onHierarchyMoved set="method" line="385"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<onAdd set="method" line="391"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="400"><f a=""><x path="Void"/></f></onRemove>
		<getMatrix set="method" line="408"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></getMatrix>
		<removeChild public="1" set="method" line="420">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<setParentContainer set="method" line="433"><f a="c">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></setParentContainer>
		<removeChildren public="1" set="method" line="442">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="451">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onHierarchyMoved</haxe_doc>
		</remove>
		<drawTo public="1" set="method" line="458">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draw the object and all its children into the given Texture</haxe_doc>
		</drawTo>
		<drawToTextures public="1" set="method" line="472">
			<f a="texs:outputs">
				<c path="Array"><c path="h3d.mat.Texture"/></c>
				<c path="Array"><e path="hxsl.Output"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Draw the object and all its children into the given Textures</haxe_doc>
		</drawToTextures>
		<draw set="method" line="483"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="486"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncPos set="method" line="513"><f a=""><x path="Void"/></f></syncPos>
		<calcAbsPos set="method" line="523"><f a=""><x path="Void"/></f></calcAbsPos>
		<emitTile set="method" line="567"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<clipBounds set="method" line="640">
			<f a="ctx:bounds">
				<c path="h2d.RenderContext"/>
				<c path="h2d.col.Bounds"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Clip a local bounds with our global viewport</haxe_doc>
		</clipBounds>
		<drawFilters set="method" line="702"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawFilters>
		<drawFiltered set="method" line="788"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<drawRec set="method" line="802"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<set_x get="inline" set="null" line="830"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="835"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_scaleX get="inline" set="null" line="840"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="845"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_rotation get="inline" set="null" line="850"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<move public="1" set="method" line="858">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Move the object by the specied amount along its current direction (rotation angle).</haxe_doc>
		</move>
		<setPosition public="1" get="inline" set="null" line="866">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<rotate public="1" get="inline" set="null" line="874">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate the object by the given angle (in radians)</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="881">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="889">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<getChildAt public="1" get="inline" set="null" line="897">
			<f a="n">
				<x path="Int"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="904">
			<f a="o">
				<c path="h2d.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<getObjectByName public="1" set="method" line="914">
			<f a="name">
				<c path="String"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<get_numChildren get="inline" set="null" line="924"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="931">
			<f a=""><c path="hxd.impl.ArrayIterator_h2d_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<toString set="method" line="935"><f a=""><c path="String"/></f></toString>
		<contentChanged set="method" line="945">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is called by our children if we have defined their parentContainer when they get resized</haxe_doc>
		</contentChanged>
		<constraintSize set="method" line="952">
			<f a="maxWidth:maxHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This can be called by a parent container to constraint the size of its children.
		Negative value mean that constraint is to be disable.</haxe_doc>
		</constraintSize>
		<new public="1" set="method" line="99">
			<f a="?parent">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h2d.Object is the base 2D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta><m n=":allow"><e>h2d.Tools</e></m></meta>
	</class>
	<class path="h2d.Drawable" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Drawable.hx">
		<extends path="h2d.Object"/>
		<color public="1">
			<c path="h3d.Vector"/>
			<haxe_doc>The color multiplier for the object. Can be used to adjust individually each of the four channels R,G,B,A (default [1,1,1,1])</haxe_doc>
		</color>
		<smooth public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>By enabling smoothing, scaling the object up or down will use hardware bilinear filtering resulting in less crisp aspect.
		By default smooth is null and then Scene.defaultSmooth value is used.</haxe_doc>
		</smooth>
		<tileWrap public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>By enabling tile wrapping, you can have tiles which size exceed the texture size and will repeat instead of displaying clamped pixels.</haxe_doc>
		</tileWrap>
		<colorKey public="1" set="accessor">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Setting a colorKey color value will discard all pixels that have this exact color in the tile.</haxe_doc>
		</colorKey>
		<colorMatrix public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Matrix"/></x>
			<haxe_doc>Setting a colorMatrix will apply a color transformation. See also `adjustColor`.</haxe_doc>
		</colorMatrix>
		<colorAdd public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Vector"/></x>
			<haxe_doc>Setting colorAdd will add the amount of color of each channel R,G,B,A to the object pixels.</haxe_doc>
		</colorAdd>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<set_tileWrap set="method" line="47"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileWrap>
		<get_colorAdd set="method" line="51"><f a=""><x path="Null"><c path="h3d.Vector"/></x></f></get_colorAdd>
		<set_colorAdd set="method" line="56"><f a="c">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_colorAdd>
		<drawFiltered set="method" line="72" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<set_colorKey set="method" line="79"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_colorKey>
		<adjustColor public="1" set="method" line="96">
			<f a="?col">
				<x path="Null"><t path="h3d.ColorAdjust"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the `colorMatrix` value by specifying which effects to apply. Calling adjustColor() reset the colorMatrix to `null`</haxe_doc>
		</adjustColor>
		<get_colorMatrix set="method" line="110"><f a=""><x path="Null"><c path="h3d.Matrix"/></x></f></get_colorMatrix>
		<set_colorMatrix set="method" line="115"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_colorMatrix>
		<getDebugShaderCode public="1" set="method" line="134">
			<f a="?toHxsl" v="true">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
			<haxe_doc>Return the built shader code, can be used for debugging shader assembly</haxe_doc>
		</getDebugShaderCode>
		<getShader public="1" params="T" set="method" line="150">
			<f a="stype">
				<x path="Class"><c path="getShader.T"/></x>
				<c path="getShader.T"/>
			</f>
			<haxe_doc>Return the first shader of the given shader class among the object shaders</haxe_doc>
		</getShader>
		<getShaders public="1" get="inline" set="null" line="162">
			<f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f>
			<haxe_doc>Return all object shaders</haxe_doc>
		</getShaders>
		<addShader public="1" params="T" set="method" line="169">
			<f a="s">
				<c path="addShader.T"/>
				<c path="addShader.T"/>
			</f>
			<haxe_doc>Add a shader to the object shaders</haxe_doc>
		</addShader>
		<removeShader public="1" set="method" line="178">
			<f a="s">
				<c path="hxsl.Shader"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a shader from the object shaders, returns true if found or false if it was not part of our shaders.</haxe_doc>
		</removeShader>
		<emitTile set="method" line="194" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<new set="method" line="42"><f a="parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>h2d.Drawable is the base class for all 2D objects that will draw something on screen.
	Unlike Object base class, all properties of Drawable only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Bitmap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Bitmap.hx">
		<extends path="h2d.Drawable"/>
		<tile public="1" set="accessor">
			<c path="h2d.Tile"/>
			<haxe_doc>The tile to display see `h2d.Tile` documentation for details.
		If the tile is null, a pink 5x5 bitmap will be displayed instead. Use remove() or visible=false to hide a h2d.Bitmap</haxe_doc>
		</tile>
		<width public="1" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* 	If set, rescale the tile to match the given width, keeping the aspect ratio unless height is also set.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* 	If set, rescale the tile to match the given height, keeping the aspect ratio unless width is also set.</haxe_doc>
		</height>
		<getBoundsRec set="method" line="40" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<set_width set="method" line="50"><f a="w">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_width>
		<set_height set="method" line="57"><f a="h">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_height>
		<set_tile set="method" line="64"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tile>
		<draw set="method" line="71" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="27">
			<f a="?tile:?parent">
				<c path="h2d.Tile"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a Bitmap with specified tile and parent object.</haxe_doc>
		</new>
		<haxe_doc>h2d.Bitmap is used to display a single bitmap Tile on the screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.BlendMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/BlendMode.hx">
		<None/>
		<Alpha/>
		<Add/>
		<AlphaAdd/>
		<SoftAdd/>
		<Multiply/>
		<AlphaMultiply/>
		<Erase/>
		<Screen/>
		<Sub/>
		<Max/>
		<Min/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.Kerning" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" module="h2d.Font">
		<prevChar public="1"><x path="Int"/></prevChar>
		<offset public="1"><x path="Float"/></offset>
		<next public="1"><x path="Null"><c path="h2d.Kerning"/></x></next>
		<new public="1" set="method" line="7"><f a="c:o">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.FontChar" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" module="h2d.Font">
		<t public="1"><c path="h2d.Tile"/></t>
		<width public="1"><x path="Float"/></width>
		<kerning><x path="Null"><c path="h2d.Kerning"/></x></kerning>
		<addKerning public="1" set="method" line="24"><f a="prevChar:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addKerning>
		<getKerningOffset public="1" set="method" line="30"><f a="prevChar">
	<x path="Int"/>
	<x path="Float"/>
</f></getKerningOffset>
		<clone public="1" set="method" line="40"><f a=""><c path="h2d.FontChar"/></f></clone>
		<new public="1" set="method" line="19"><f a="t:w">
	<c path="h2d.Tile"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h2d.SDFChannel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" module="h2d.Font">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>Channel reading method for SDF.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="h2d._Font.SDFChannel_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1" final="1">
	<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
	</Red>
	<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
	</Green>
	<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
	</Blue>
	<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
	</Alpha>
	<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
	</MultiChannel>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h2d._Font.SDFChannel_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1" final="1">
		<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
		</Red>
		<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
		</Green>
		<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
		</Blue>
		<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
		</Alpha>
		<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
		</MultiChannel>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="h2d.FontType" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx" module="h2d.Font">
		<BitmapFont/>
		<SignedDistanceField a="channel:alphaCutoff:smoothing">
			<x path="h2d.SDFChannel"/>
			<x path="Float"/>
			<x path="Float"/>
			<haxe_doc>Signed Distance Field font. Channel indexes are in RGBA order. See here for info: https://github.com/libgdx/libgdx/wiki/Distance-field-fonts</haxe_doc>
		</SignedDistanceField>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="h2d.Font" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Font.hx">
		<name public="1" set="null"><c path="String"/></name>
		<size public="1" set="null"><x path="Int"/></size>
		<baseLine public="1" set="null"><x path="Float"/></baseLine>
		<lineHeight public="1" set="null"><x path="Float"/></lineHeight>
		<tile public="1" set="null"><c path="h2d.Tile"/></tile>
		<tilePath public="1" set="null"><c path="String"/></tilePath>
		<type public="1"><e path="h2d.FontType"/></type>
		<charset public="1"><c path="hxd.Charset"/></charset>
		<glyphs><t path="Map">
	<x path="Int"/>
	<c path="h2d.FontChar"/>
</t></glyphs>
		<nullChar><c path="h2d.FontChar"/></nullChar>
		<defaultChar><c path="h2d.FontChar"/></defaultChar>
		<initSize><x path="Int"/></initSize>
		<offsetX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<getChar public="1" get="inline" set="null" line="111"><f a="code">
	<x path="Int"/>
	<x path="Null"><c path="h2d.FontChar"/></x>
</f></getChar>
		<setOffset public="1" set="method" line="121"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOffset>
		<clone public="1" set="method" line="133"><f a=""><c path="h2d.Font"/></f></clone>
		<resizeTo public="1" set="method" line="154">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is meant to create smoother fonts by creating them with double size while still keeping the original glyph size.</haxe_doc>
		</resizeTo>
		<hasChar public="1" set="method" line="172"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasChar>
		<dispose public="1" set="method" line="176"><f a=""><x path="Void"/></f></dispose>
		<new set="method" line="96"><f a="name:size:?type">
	<c path="String"/>
	<x path="Int"/>
	<e path="h2d.FontType"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h2d._Graphics.GraphicsPoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics"><c path="hxd.poly2tri.Point"/></typedef>
	<class path="h2d.GPoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Graphics.hx" module="h2d.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<load public="1" set="method" line="17"><f a="x:y:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></load>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl._Serializable.NoSerializeSupport" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Serializable.hx" private="1" module="hxd.impl.Serializable" interface="1"/>
	<class path="h3d.prim.Primitive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/Primitive.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<buffer public="1">
			<c path="h3d.Buffer"/>
			<haxe_doc>The primitive vertex buffer, holding its vertexes data.</haxe_doc>
		</buffer>
		<indexes public="1">
			<c path="h3d.Indexes"/>
			<haxe_doc>The primitive indexes buffer, holding its triangles indices.</haxe_doc>
		</indexes>
		<refCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Current amount of references to this Primitive.  
		Use `incref` and `decref` methods to affect this value. If it reaches 0, it will be atuomatically disposed.</haxe_doc>
		</refCount>
		<triCount public="1" set="method" line="28">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of triangles the primitive has.</haxe_doc>
		</triCount>
		<vertexCount public="1" set="method" line="35">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of vertexes the primitive has.</haxe_doc>
		</vertexCount>
		<getCollider public="1" set="method" line="42">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Return a local collider for the primitive</haxe_doc>
		</getCollider>
		<getBounds public="1" set="method" line="50">
			<f a=""><c path="h3d.col.Bounds"/></f>
			<haxe_doc>Return the bounds for the primitive</haxe_doc>
		</getBounds>
		<incref public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Increase reference count of the Primitive.</haxe_doc>
		</incref>
		<decref public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Decrease reference count of the Primitive.  
		If recount reaches zero, Primitive is automatically disposed when last referencing mesh is removed from scene.</haxe_doc>
		</decref>
		<alloc public="1" set="method" line="79">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocate the primitive on GPU. Used for internal usage.</haxe_doc>
		</alloc>
		<selectMaterial public="1" set="method" line="86">
			<f a="material">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Select the specified sub material before drawin. Used for internal usage.</haxe_doc>
		</selectMaterial>
		<buildNormalsDisplay public="1" set="method" line="89">
			<f a=""><c path="h3d.prim.Primitive"/></f>
			<meta><m n=":noCompletion"/></meta>
		</buildNormalsDisplay>
		<render public="1" set="method" line="97">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the primitive. Used for internal usage.</haxe_doc>
		</render>
		<dispose public="1" set="method" line="111">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the primitive, freeing the GPU memory it uses.</haxe_doc>
		</dispose>
		<toString public="1" set="method" line="125">
			<f a=""><x path="Null"><c path="String"/></x></f>
			<haxe_doc>Return the primitive type.</haxe_doc>
		</toString>
		<new public="1" set="method" line="7">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>h3d.prim.Primitive is the base class for all 3D primitives.
	You can't create an instance of it and need to use one of its subclasses.</haxe_doc>
	</class>
	<class path="h2d._Graphics.GraphicsContent" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<index><x path="hxd.IndexBuffer"/></index>
		<buffers><c path="Array"><a>
	<vbuf><c path="h3d.Buffer"/></vbuf>
	<idx><x path="hxd.IndexBuffer"/></idx>
	<ibuf><c path="h3d.Indexes"/></ibuf>
	<buf><x path="hxd.FloatBuffer"/></buf>
</a></c></buffers>
		<bufferDirty><x path="Bool"/></bufferDirty>
		<indexDirty><x path="Bool"/></indexDirty>
		<addIndex public="1" get="inline" set="null" line="46"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<add public="1" get="inline" set="null" line="51"><f a="x:y:u:v:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add>
		<next public="1" set="method" line="63"><f a=""><x path="Bool"/></f></next>
		<alloc public="1" set="method" line="74" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="89" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<flush public="1" get="inline" set="null" line="97"><f a=""><x path="Void"/></f></flush>
		<dispose public="1" set="method" line="114" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="125"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Graphics" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Graphics.hx">
		<extends path="h2d.Drawable"/>
		<EARCUT expr="null" line="335" static="1">
			<c path="hxd.earcut.Earcut"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</EARCUT>
		<content><c path="h2d._Graphics.GraphicsContent"/></content>
		<tmpPoints><c path="Array"><c path="h2d.GPoint"/></c></tmpPoints>
		<pindex><x path="Int"/></pindex>
		<curR><x path="Float"/></curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize><x path="Float"/></lineSize>
		<lineR><x path="Float"/></lineR>
		<lineG><x path="Float"/></lineG>
		<lineB><x path="Float"/></lineB>
		<lineA><x path="Float"/></lineA>
		<doFill><x path="Bool"/></doFill>
		<xMin><x path="Float"/></xMin>
		<yMin><x path="Float"/></yMin>
		<xMax><x path="Float"/></xMax>
		<yMax><x path="Float"/></yMax>
		<ma expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</ma>
		<mb expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mb>
		<mc expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mc>
		<md expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</md>
		<mx expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mx>
		<my expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</my>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<bevel public="1" expr="0.25">
			<x path="Float"/>
			<meta><m n=":value"><e>0.25</e></m></meta>
		</bevel>
		<onRemove set="method" line="172" override="1"><f a=""><x path="Void"/></f></onRemove>
		<clear public="1" set="method" line="177"><f a=""><x path="Void"/></f></clear>
		<getBoundsRec set="method" line="188" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<isConvex set="method" line="193"><f a="points">
	<c path="Array"><c path="h2d.GPoint"/></c>
	<x path="Bool"/>
</f></isConvex>
		<flushLine set="method" line="209"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></flushLine>
		<flushFill set="method" line="337"><f a="i0">
	<x path="Int"/>
	<x path="Void"/>
</f></flushFill>
		<flush set="method" line="368"><f a=""><x path="Void"/></f></flush>
		<beginFill public="1" set="method" line="385">
			<f a="?color:?alpha" v="0:1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0 }</e></m></meta>
		</beginFill>
		<beginTileFill public="1" set="method" line="395">
			<f a="?dx:?dy:?scaleX:?scaleY:?tile">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Position a virtual tile at the given position and scale. Every draw will display a part of this tile relative
		to these coordinates.</haxe_doc>
		</beginTileFill>
		<drawTile public="1" set="method" line="428"><f a="x:y:tile">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawTile>
		<lineStyle public="1" set="method" line="434">
			<f a="?size:?color:?alpha" v="0:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0 }</e></m></meta>
		</lineStyle>
		<moveTo public="1" get="inline" set="null" line="443"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<endFill public="1" set="method" line="448"><f a=""><x path="Void"/></f></endFill>
		<setColor public="1" get="inline" set="null" line="453">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawRect public="1" set="method" line="460"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundedRect public="1" set="method" line="477">
			<f a="x:y:w:h:radius:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawRoundedRect>
		<drawCircle public="1" set="method" line="508">
			<f a="cx:cy:radius:?nsegments" v=":::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawCircle>
		<drawEllipse public="1" set="method" line="521">
			<f a="cx:cy:radiusX:radiusY:?rotationAngle:?nsegments" v="::::0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0, rotationAngle : 0 }</e></m></meta>
		</drawEllipse>
		<drawPie public="1" set="method" line="537">
			<f a="cx:cy:radius:angleStart:angleLength:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawPie>
		<drawRectanglePie public="1" set="method" line="555">
			<f a="cx:cy:width:height:angleStart:angleLength:?nsegments" v="::::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawRectanglePie>
		<curveTo public="1" set="method" line="585">
			<f a="bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a quadratic Bezier curve using the current line style from the current drawing position to (cx, cy) and using the control point that (bx, by) specifies.
	 * IvanK Lib port ( http://lib.ivank.net )</haxe_doc>
		</curveTo>
		<cubicCurveTo public="1" set="method" line="603">
			<f a="bx:by:cx:cy:dx:dy:?nsegments" v="::::::40">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 40 }</e></m></meta>
			<haxe_doc>* Draws a cubic Bezier curve from the current drawing position to the specified anchor point.
	 * IvanK Lib port ( http://lib.ivank.net )
	 * @param bx control X for start point
	 * @param by control Y for start point
	 * @param cx control X for end point
	 * @param cy control Y for end point
	 * @param dx end X
	 * @param dy end Y
	 * @param nsegments = 40</haxe_doc>
		</cubicCurveTo>
		<lineTo public="1" get="inline" set="null" line="627"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<addVertex public="1" set="method" line="631">
			<f a="x:y:r:g:b:a:?u:?v" v="::::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0., u : 0. }</e></m></meta>
		</addVertex>
		<draw set="method" line="643" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="648" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="165"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Interactive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<set_cursor public="1" set="method">
			<f a="value">
				<e path="hxd.Cursor"/>
				<e path="hxd.Cursor"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_cursor>
		<propagateEvents public="1"><x path="Bool"/></propagateEvents>
		<cursor public="1" set="accessor"><e path="hxd.Cursor"/></cursor>
		<handleEvent public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<getInteractiveScene public="1" set="method"><f a=""><c path="hxd.InteractiveScene"/></f></getInteractiveScene>
	</class>
	<class path="h2d.Interactive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Interactive.hx">
		<extends path="h2d.Drawable"/>
		<implements path="hxd.Interactive"/>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>Width of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>Height of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</height>
		<cursor public="1" set="accessor">
			<x path="Null"><e path="hxd.Cursor"/></x>
			<haxe_doc>Cursor used when Interactive is under mouse cursor ( default : Button )</haxe_doc>
		</cursor>
		<isEllipse public="1">
			<x path="Bool"/>
			<haxe_doc>Should object collision be in rectangle or ellipse form? Ignored if `shape` is set.</haxe_doc>
		</isEllipse>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<backgroundColor public="1"><x path="Null"><x path="Int"/></x></backgroundColor>
		<enableRightButton public="1"><x path="Bool"/></enableRightButton>
		<scene><c path="h2d.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<invDet><x path="Float"/></invDet>
		<shape public="1">
			<c path="h2d.col.Collider"/>
			<haxe_doc>Detailed shape collider for Interactive.
		If set, `width` and `height` properties are ignored for collision checks.</haxe_doc>
		</shape>
		<shapeX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape X offset from Interactive.</haxe_doc>
		</shapeX>
		<shapeY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape Y offset from Interactive.</haxe_doc>
		</shapeY>
		<onAdd set="method" line="59" override="1"><f a=""><x path="Void"/></f></onAdd>
		<draw set="method" line="66" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<getBoundsRec set="method" line="70" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<onHierarchyMoved set="method" line="75" override="1"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<updateMask set="method" line="88"><f a=""><x path="Void"/></f></updateMask>
		<onRemove set="method" line="101" override="1"><f a=""><x path="Void"/></f></onRemove>
		<checkBounds set="method" line="109"><f a="e">
	<c path="hxd.Event"/>
	<x path="Bool"/>
</f></checkBounds>
		<preventClick public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="123">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="127">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<calcAbsPos set="method" line="198" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<set_cursor set="method" line="204"><f a="c">
	<x path="Null"><e path="hxd.Cursor"/></x>
	<x path="Null"><e path="hxd.Cursor"/></x>
</f></set_cursor>
		<eventToLocal set="method" line="211"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></eventToLocal>
		<startDrag public="1" set="method" line="222"><f a="callb:?onCancel">
	<f a="">
		<c path="hxd.Event"/>
		<unknown/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="232"><f a=""><x path="Void"/></f></stopDrag>
		<focus public="1" set="method" line="236"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="242"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="246"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="250"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="259">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOver`.
		Propagation can be set with `onMove` event, as well as cancelling `onMove` will prevent `onOver`.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="265">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOut`.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="269">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="280">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="287">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="294">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="297"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="300"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="303"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="306"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="309"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="312"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="315"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="318"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="51"><f a="width:height:?parent:?shape">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Scene</e></m>
		</meta>
	</class>
	<class path="h2d.Layers" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Layers.hx">
		<extends path="h2d.Object"/>
		<layersIndexes><c path="Array"><x path="Int"/></c></layersIndexes>
		<layerCount><x path="Int"/></layerCount>
		<addChild public="1" set="method" line="18" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></addChild>
		<add public="1" get="inline" set="null" line="28">
			<f a="s:layer">
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a child `h2d.Object` at `layer:Int`. 
	 * `h2d.Layers.addChildAt` can be used as an alternative.
	 * @param s `h2d.Object` child to be added.
	 * @param layer `Int` index of the layer, 0 is the bottom layer.</haxe_doc>
		</add>
		<addChildAt public="1" set="method" line="32" override="1"><f a="s:layer">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addChildAt>
		<removeChild public="1" set="method" line="47" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></removeChild>
		<under public="1" set="method" line="70">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Moves an `h2d.Object` to the bottom of its layer (rendered first, behind the other Objects in layer).
	 * @param s `h2d.Object` to be moved.</haxe_doc>
		</under>
		<over public="1" set="method" line="96">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Moves an `h2d.Object` to the top of its layer (rendered last, in front of other Objects in layer).
	 * @param s `h2d.Object` to be moved.</haxe_doc>
		</over>
		<getLayer public="1" set="method" line="120">
			<f a="layer">
				<x path="Int"/>
				<t path="Iterator"><c path="h2d.Object"/></t>
			</f>
			<haxe_doc><![CDATA[* Returns an `Iterator<h2d.Object>` contained in specified layer.  
	 * Returns empty iterator if layer does not exists.  
	 * Objects added or removed from Layers during iteration are not added/removed from the `Iterator`.
	 * @param layer `Int` index of the desired layer.
	 * @return `Iterator<Object>`]]></haxe_doc>
		</getLayer>
		<getChildLayer public="1" set="method" line="137">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the layer on which the child `h2d.Object` resides.  
	 * @param s `h2d.Object` 
	 * @return `Int` index of the layer where `s:h2d.Object` resides or -1 if it's not a child.</haxe_doc>
		</getChildLayer>
		<drawLayer set="method" line="146"><f a="ctx:layer">
	<c path="h2d.RenderContext"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<ysort public="1" set="method" line="165">
			<f a="layer">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sorts specified layer based on Y value of it's children.
	 * @param layer `Int` index of the layer.</haxe_doc>
		</ysort>
		<new public="1" set="method" line="12"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* `h2d.Layers` allows to hierarchically organize objects on different layers and supports Y-sorting.</haxe_doc>
	</class>
	<class path="h2d.Mask" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Mask.hx">
		<extends path="h2d.Object"/>
		<maskWith public="1" set="method" line="11" static="1">
			<f a="ctx:object:width:height:?scrollX:?scrollY" v="::::0:0">
				<c path="h2d.RenderContext"/>
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ scrollY : 0, scrollX : 0 }</e></m>
				<m n=":access"><e>h2d.RenderContext</e></m>
			</meta>
			<haxe_doc>Masks render zone based off object position and given dimensions.
		Should call `Mask.unmask()` afterwards.</haxe_doc>
		</maskWith>
		<unmask public="1" set="method" line="39" static="1">
			<f a="ctx">
				<c path="h2d.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Unmasks prviously masked area from `Mask.maskWith`.</haxe_doc>
		</unmask>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<scrollX public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Horizontal scroll offset of the Mask content in pixels. Can be clamped by `scrollBounds`.</haxe_doc>
		</scrollX>
		<scrollY public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Vertical scroll offset of the Mask content in pixels. Can be clamped by `scrollBounds`.</haxe_doc>
		</scrollY>
		<scrollBounds public="1">
			<c path="h2d.col.Bounds"/>
			<haxe_doc>Optional scroll boundaries that prevent content from overscroll.</haxe_doc>
		</scrollBounds>
		<scrollTo public="1" set="method" line="72">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scroll Mask content to specified offset.</haxe_doc>
		</scrollTo>
		<scrollBy public="1" set="method" line="80">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scroll Mask content by specified offset relative to current scroll offset.</haxe_doc>
		</scrollBy>
		<onHierarchyMoved set="method" line="85" override="1"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<onAdd set="method" line="91" override="1"><f a=""><x path="Void"/></f></onAdd>
		<updateMask set="method" line="96"><f a=""><x path="Void"/></f></updateMask>
		<set_scrollX set="method" line="109"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollX>
		<set_scrollY set="method" line="115"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollY>
		<calcAbsPos set="method" line="121" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<getBoundsRec set="method" line="128" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<drawRec set="method" line="150" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new public="1" set="method" line="63"><f a="width:height:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h2d._RenderContext.RenderZoneStack" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/RenderContext.hx" private="1" module="h2d.RenderContext"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<w><x path="Float"/></w>
	<hasRZ><x path="Bool"/></hasRZ>
	<h><x path="Float"/></h>
</a></typedef>
	<class path="h3d.impl.RenderContext" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/RenderContext.hx">
		<engine public="1"><c path="h3d.Engine"/></engine>
		<time public="1"><x path="Float"/></time>
		<elapsedTime public="1"><x path="Float"/></elapsedTime>
		<frame public="1"><x path="Int"/></frame>
		<textures public="1"><c path="h3d.impl.TextureCache"/></textures>
		<dispose public="1" set="method" line="19"><f a=""><x path="Void"/></f></dispose>
		<new set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h2d.RenderContext" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<BUFFERING get="inline" set="null" expr="false" line="7" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</BUFFERING>
		<globalAlpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</globalAlpha>
		<buffer public="1"><x path="hxd.FloatBuffer"/></buffer>
		<bufPos public="1"><x path="Int"/></bufPos>
		<scene public="1"><c path="h2d.Scene"/></scene>
		<defaultSmooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</defaultSmooth>
		<killAlpha public="1"><x path="Bool"/></killAlpha>
		<front2back public="1"><x path="Bool"/></front2back>
		<onBeginDraw public="1"><f a="">
	<c path="h2d.Drawable"/>
	<x path="Bool"/>
</f></onBeginDraw>
		<onEnterFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></onEnterFilter>
		<onLeaveFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></onLeaveFilter>
		<tmpBounds public="1" expr="new h2d.col.Bounds()">
			<c path="h2d.col.Bounds"/>
			<meta><m n=":value"><e>new h2d.col.Bounds()</e></m></meta>
		</tmpBounds>
		<texture><c path="h3d.mat.Texture"/></texture>
		<baseShader><c path="h3d.shader.Base2d"/></baseShader>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<compiledShader><c path="hxsl.RuntimeShader"/></compiledShader>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<fixedBuffer><c path="h3d.Buffer"/></fixedBuffer>
		<pass><c path="h3d.mat.Pass"/></pass>
		<currentShaders><c path="hxsl.ShaderList"/></currentShaders>
		<baseShaderList><c path="hxsl.ShaderList"/></baseShaderList>
		<currentObj><c path="h2d.Drawable"/></currentObj>
		<stride><x path="Int"/></stride>
		<targetsStack><c path="Array"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<w><x path="Int"/></w>
	<t><c path="h3d.mat.Texture"/></t>
	<rzY><x path="Float"/></rzY>
	<rzX><x path="Float"/></rzX>
	<rzW><x path="Float"/></rzW>
	<rzH><x path="Float"/></rzH>
	<hasRZ><x path="Bool"/></hasRZ>
	<h><x path="Int"/></h>
</a></c></targetsStack>
		<targetsStackIndex><x path="Int"/></targetsStackIndex>
		<renderZoneStack expr="[]">
			<c path="Array"><t path="h2d._RenderContext.RenderZoneStack"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</renderZoneStack>
		<renderZoneIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</renderZoneIndex>
		<hasUVPos><x path="Bool"/></hasUVPos>
		<filterStack><c path="Array"><c path="h2d.Object"/></c></filterStack>
		<inFilter><c path="h2d.Object"/></inFilter>
		<inFilterBlend><e path="h2d.BlendMode"/></inFilterBlend>
		<curX><x path="Int"/></curX>
		<curY><x path="Int"/></curY>
		<curWidth><x path="Int"/></curWidth>
		<curHeight><x path="Int"/></curHeight>
		<hasRenderZone><x path="Bool"/></hasRenderZone>
		<renderX><x path="Float"/></renderX>
		<renderY><x path="Float"/></renderY>
		<renderW><x path="Float"/></renderW>
		<renderH><x path="Float"/></renderH>
		<currentBlend><e path="h2d.BlendMode"/></currentBlend>
		<baseFlipY><x path="Float"/></baseFlipY>
		<targetFlipY><x path="Float"/></targetFlipY>
		<dispose public="1" set="method" line="75" override="1"><f a=""><x path="Void"/></f></dispose>
		<hasBuffering public="1" get="inline" set="null" line="80"><f a=""><x path="Bool"/></f></hasBuffering>
		<begin public="1" set="method" line="84"><f a=""><x path="Void"/></f></begin>
		<allocTarget public="1" set="method" line="110">
			<f a="name:?filter" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ filter : false }</e></m></meta>
		</allocTarget>
		<clear public="1" set="method" line="116"><f a="color">
	<x path="Null"><x path="Int"/></x>
	<x path="Void"/>
</f></clear>
		<initShaders set="method" line="120"><f a="shaders">
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></initShaders>
		<end public="1" set="method" line="132"><f a=""><x path="Void"/></f></end>
		<pushFilter public="1" set="method" line="140"><f a="spr">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></pushFilter>
		<popFilter public="1" set="method" line="148"><f a=""><x path="Void"/></f></popFilter>
		<pushTarget public="1" set="method" line="158">
			<f a="t:?startX:?startY:?width:?height" v=":0:0:-1:-1">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, startY : 0, startX : 0 }</e></m></meta>
		</pushTarget>
		<pushTargets public="1" set="method" line="190"><f a="texs">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></pushTargets>
		<popTarget public="1" set="method" line="198">
			<f a="?restore" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ restore : true }</e></m></meta>
		</popTarget>
		<pushRenderZone public="1" set="method" line="242"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pushRenderZone>
		<popRenderZone public="1" set="method" line="260"><f a=""><x path="Void"/></f></popRenderZone>
		<clipRenderZone public="1" set="method" line="274">
			<f a="x:y:w:h">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Same as pushRenderZone, but clips news zone to existing one before pushing it. Used so that
	 * any call to clipRenderZone respects the already set zone ,and can't render outside it.</haxe_doc>
		</clipRenderZone>
		<setRZ set="method" line="290"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRZ>
		<clearRZ get="inline" set="null" line="314"><f a=""><x path="Void"/></f></clearRZ>
		<setRenderZone public="1" get="inline" set="null" line="320">
			<f a="x:y:w:h">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use pushRenderZone"</e></m></meta>
		</setRenderZone>
		<clearRenderZone public="1" get="inline" set="null" line="325">
			<f a=""><x path="Void"/></f>
			<meta><m n=":deprecated"><e>"Use popRenderZone"</e></m></meta>
		</clearRenderZone>
		<drawLayer set="method" line="329"><f a="layer">
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<drawScene public="1" set="method" line="333"><f a=""><x path="Void"/></f></drawScene>
		<flush public="1" get="inline" set="null" line="337"><f a=""><x path="Void"/></f></flush>
		<_flush set="method" line="341"><f a=""><x path="Void"/></f></_flush>
		<beforeDraw public="1" set="method" line="353"><f a=""><x path="Void"/></f></beforeDraw>
		<setupColor get="inline" set="null" line="384"><f a="obj">
	<c path="h2d.Drawable"/>
	<x path="Void"/>
</f></setupColor>
		<beginDrawObject public="1" set="method" line="395">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawObject>
		<beginDrawBatch public="1" set="method" line="405">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawBatch>
		<drawTile public="1" set="method" line="410">
			<f a="obj:tile">
				<c path="h2d.Drawable"/>
				<c path="h2d.Tile"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</drawTile>
		<beginDraw set="method" line="479">
			<f a="obj:texture:isRelative:?hasUVPos" v=":::false">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ hasUVPos : false }</e></m>
				<m n=":access"><e>h2d.Drawable</e></m>
			</meta>
		</beginDraw>
		<new public="1" set="method" line="56"><f a="scene">
	<c path="h2d.Scene"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.ScaleModeAlign" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Scene.hx" module="h2d.Scene">
		<Left><haxe_doc>Anchor Scene viewport horizontally to left side of the window. When passed to verticalAlign it will be treated as Center.</haxe_doc></Left>
		<Right><haxe_doc>Anchor Scene viewport horizontally to right side of the window. When passed to verticalAlign it will be treated as Center.</haxe_doc></Right>
		<Center><haxe_doc>Anchor to the center of window.</haxe_doc></Center>
		<Top><haxe_doc>Anchor Scene viewport vertically to the top of a window. When passed to horizontalAlign it will be treated as Center.</haxe_doc></Top>
		<Bottom><haxe_doc>Anchor Scene viewport vertically to the bottom of a window. When passed to horizontalAlign it will be treated as Center.</haxe_doc></Bottom>
		<haxe_doc>Viewport alignment when scaling mode supports it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h2d.ScaleMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Scene.hx" module="h2d.Scene">
		<Resize><haxe_doc>Matches scene size to window size. `width` and `height` of Scene will match window size. Default scaling mode.</haxe_doc></Resize>
		<Stretch a="width:height">
			<x path="Int"/>
			<x path="Int"/>
			<haxe_doc>Sets constant Scene size and stretches it to cover entire window. This behavior is same as old `setFixedSize` method.</haxe_doc>
		</Stretch>
		<LetterBox a="width:height:?integerScale:?horizontalAlign:?verticalAlign">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<e path="h2d.ScaleModeAlign"/>
			<e path="h2d.ScaleModeAlign"/>
			<haxe_doc>Sets constant scene size and upscales it with preserving aspect-ratio to fit the window.
		If `integerScale` is `true` - scaling will be performed  with only integer increments (1x, 2x, 3x, ...). Default: `false`
		`horizontalAlign` controls viewport anchoring horizontally. Accepted values are `Left`, `Center` and `Right`. Default: `Center`
		`verticalAlign` controls viewport anchoring vertically. Accepted values are `Top`, `Center` and `Bottom`. Default: `Center`
		With `800x600` window, `LetterBox(320, 260)` will result in center-aligned Scene of size `320x260` upscaled to fit into screen.</haxe_doc>
		</LetterBox>
		<Fixed a="width:height:zoom:?horizontalAlign:?verticalAlign">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<e path="h2d.ScaleModeAlign"/>
			<e path="h2d.ScaleModeAlign"/>
			<haxe_doc>Sets constant Scene size, scale and alignment. Does not perform any adaptation to the screen apart from alignment.
		`horizontalAlign` controls viewport anchoring horizontally. Accepted values are `Left`, `Center` and `Right`. Default: `Center`
		`verticalAlign` controls viewport anchoring vertically. Accepted values are `Top`, `Center` and `Bottom`. Default: `Center`
		With `800x600` window, `Fixed(200, 150, 2, Left, Center)` will result in Scene size of `200x150`, and visually upscaled to `400x300`, and aligned to middle-left of the window.</haxe_doc>
		</Fixed>
		<Zoom a="level">
			<x path="Float"/>
			<haxe_doc>Upscales/downscales Scene according to `level` and matches Scene size to `ceil(window size / level)`.
		With `800x600` window, `Zoom(2)` will result in `400x300` Scene size upscaled to fill entire window.</haxe_doc>
		</Zoom>
		<AutoZoom a="minWidth:minHeight:?integerScaling">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<haxe_doc>Ensures that Scene size will be of minimum specified size.
		Automatically calculates zoom level based on provided size according to `min(window width / min width, window height / min height)`, then applies same scaling as `Zoom(level)`.
		Behavior is similiar to LetterBox, however instead of letterboxing effect, Scene size will change to cover the letterboxed parts.
		`minWidth` or `minHeight` can be set to `0` in order to force scaling adjustment account only for either horizontal of vertical window size.
		If `integerScale` is `true` - scaling will be performed  with only integer increments (1x, 2x, 3x, ...). Default: `false`
		With `800x600` window, `AutoZoom(320, 260, false)` will result in Scene size of `347x260`. `AutoZoom(320, 260, true)` will result in size of `400x300`.</haxe_doc>
		</AutoZoom>
		<haxe_doc>Scaling mode of the 2D Scene.
	See `ScaleMode2D` sample for showcase.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.InteractiveScene" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<setEvents public="1" set="method"><f a="s">
	<c path="hxd.SceneEvents"/>
	<x path="Void"/>
</f></setEvents>
		<handleEvent public="1" set="method"><f a="e:last">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<c path="hxd.Interactive"/>
</f></handleEvent>
		<dispatchEvent public="1" set="method"><f a="e:to">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></dispatchEvent>
		<dispatchListeners public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<isInteractiveVisible public="1" set="method"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Bool"/>
</f></isInteractiveVisible>
	</class>
	<class path="h3d.IDrawable" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/IDrawable.hx" interface="1"><render public="1" set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></class>
	<class path="h2d.Scene" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Scene.hx">
		<extends path="h2d.Layers"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current width (in pixels) of the scene. Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</width>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current height (in pixels) of the scene. Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</height>
		<viewportX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Horizontal viewport offset relative to top-left corner of the window. Can change if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</viewportX>
		<viewportY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Vertical viewport offset relative to top-left corner of the window. Can change if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</viewportY>
		<offsetX public="1">
			<x path="Float"/>
			<haxe_doc>Physical vertical viewport offset relative to the center of the window. Assigned if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Float"/>
			<haxe_doc>Physical horizontal viewport offset relative to the center of the window. Assigned if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</offsetY>
		<ratioX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Horizontal ratio of the window used by the Scene (including scaling). Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</ratioX>
		<ratioY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Vertical ratio of the window used by the Scene (including scaling). Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</ratioY>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse X coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse Y coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseY>
		<zoom public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
			<haxe_doc><![CDATA[The zoom factor of the scene, allows to set a fixed x2, x4 etc. zoom for pixel art
		When setting a zoom > 0, the scene resize will be automaticaly managed.]]></haxe_doc>
		</zoom>
		<scaleMode public="1" set="accessor" expr="Resize">
			<e path="h2d.ScaleMode"/>
			<meta><m n=":value"><e>Resize</e></m></meta>
			<haxe_doc>Scene scaling mode. ( default : Resize )
		Important thing to keep in mind - Scene does not clip rendering to it's scaled size and
		graphics can render outside of it. However `drawTile` does check for those bounds and
		will clip out tiles that are outside of the scene bounds.</haxe_doc>
		</scaleMode>
		<defaultSmooth public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Set the default value for `h2d.Drawable.smooth` (default: false)</haxe_doc>
		</defaultSmooth>
		<renderer public="1" get="accessor" set="accessor">
			<c path="h2d.RenderContext"/>
			<haxe_doc>The scene current renderer. Can be customized.</haxe_doc>
		</renderer>
		<interactive><c path="Array"><c path="h2d.Interactive"/></c></interactive>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<ctx><c path="h2d.RenderContext"/></ctx>
		<window><c path="hxd.Window"/></window>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h2d.Interactive</e></m></meta>
		</events>
		<shapePoint><c path="h2d.col.Point"/></shapePoint>
		<get_defaultSmooth get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></get_defaultSmooth>
		<set_defaultSmooth get="inline" set="null" line="181"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_defaultSmooth>
		<setEvents public="1" set="method" line="184">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</setEvents>
		<get_zoom set="method" line="188">
			<f a=""><x path="Int"/></f>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
		</get_zoom>
		<set_zoom set="method" line="195">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
		</set_zoom>
		<set_scaleMode set="method" line="200"><f a="v">
	<e path="h2d.ScaleMode"/>
	<e path="h2d.ScaleMode"/>
</f></set_scaleMode>
		<get_renderer set="method" line="206"><f a=""><c path="h2d.RenderContext"/></f></get_renderer>
		<set_renderer set="method" line="207"><f a="v">
	<c path="h2d.RenderContext"/>
	<c path="h2d.RenderContext"/>
</f></set_renderer>
		<setFixedSize public="1" set="method" line="213">
			<f a="w:h">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"setFixedSize is deprecated, use scaleMode = Stretch(w, h) instead"</e></m></meta>
			<haxe_doc>Set the fixed size for the scene, will prevent automatic scene resizing when screen size changes.</haxe_doc>
		</setFixedSize>
		<checkResize public="1" set="method" line="218">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</checkResize>
		<screenXToViewport get="inline" set="null" line="309"><f a="mx">
	<x path="Float"/>
	<x path="Float"/>
</f></screenXToViewport>
		<screenYToViewport get="inline" set="null" line="313"><f a="my">
	<x path="Float"/>
	<x path="Float"/>
</f></screenYToViewport>
		<get_mouseX set="method" line="317"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="325"><f a=""><x path="Float"/></f></get_mouseY>
		<dispatchListeners public="1" set="method" line="334">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<isInteractiveVisible public="1" set="method" line="343">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<getInteractive public="1" set="method" line="355">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Interactive"/>
			</f>
			<haxe_doc>Return the topmost visible Interactive at the specific coordinates</haxe_doc>
		</getInteractive>
		<screenToViewport set="method" line="390"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></screenToViewport>
		<dispatchEvent public="1" set="method" line="396">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<handleEvent public="1" set="method" line="409">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<c path="hxd.Interactive"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<addEventListener public="1" set="method" line="471">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="478">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<startDrag public="1" set="method" line="492">
			<f a="onEvent:?onCancel:?refEvent">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Start a drag and drop operation, sending all events to `onEvent` instead of the scene until `stopDrag()` is called.
		@param	onCancel	If defined, will be called when stopDrag is called
		@param	refEvent	For touch events, only capture events that matches the reference event touchId</haxe_doc>
		</startDrag>
		<stopDrag public="1" set="method" line="502">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the current drag and drop operation</haxe_doc>
		</stopDrag>
		<getFocus public="1" set="method" line="509">
			<f a=""><c path="h2d.Interactive"/></f>
			<haxe_doc>Get the currently focused Interactive</haxe_doc>
		</getFocus>
		<addEventTarget set="method" line="522">
			<f a="i">
				<c path="h2d.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="574">
			<f a="i:?notify" v=":false">
				<c path="h2d.Interactive"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ notify : false }</e></m>
				<m n=":allow"><e>h2d</e></m>
			</meta>
		</removeEventTarget>
		<dispose public="1" set="method" line="583">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the scene and all its children, freeing used GPU memory</haxe_doc>
		</dispose>
		<setElapsedTime public="1" set="method" line="593">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<drawImplTo set="method" line="597"><f a="s:texs:?outputs">
	<c path="h2d.Object"/>
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></drawImplTo>
		<syncOnly public="1" set="method" line="618">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<render public="1" set="method" line="631">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<sync set="method" line="643" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<onAdd set="method" line="649" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="656" override="1"><f a=""><x path="Void"/></f></onRemove>
		<captureBitmap public="1" set="method" line="665">
			<f a="?target">
				<c path="h2d.Tile"/>
				<c path="h2d.Bitmap"/>
			</f>
			<haxe_doc>Capture the scene into a texture and render the resulting Bitmap</haxe_doc>
		</captureBitmap>
		<new public="1" set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new scene. A default 2D scene is already available in `hxd.App.s2d`</haxe_doc>
		</new>
		<haxe_doc>h2d.Scene is the root class for a 2D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Tile" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/Tile.hx">
		<fromColor public="1" set="method" line="197" static="1">
			<f a="color:?width:?height:?alpha" v=":1:1:1.">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., height : 1, width : 1 }</e></m></meta>
		</fromColor>
		<fromBitmap public="1" set="method" line="205" static="1"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<c path="h2d.Tile"/>
</f></fromBitmap>
		<autoCut public="1" set="method" line="210" static="1"><f a="bmp:width:?height">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<a>
		<tiles><c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c></tiles>
		<main><c path="h2d.Tile"/></main>
	</a>
</f></autoCut>
		<fromTexture public="1" set="method" line="241" static="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<c path="h2d.Tile"/>
</f></fromTexture>
		<fromPixels public="1" set="method" line="245" static="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<c path="h2d.Tile"/>
</f></fromPixels>
		<isEmpty set="method" line="252" static="1"><f a="b:px:py:width:height:bg">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Null"><a>
	<w><x path="Int"/></w>
	<h><x path="Int"/></h>
	<dy><x path="Int"/></dy>
	<dx><x path="Int"/></dx>
</a></x>
</f></isEmpty>
		<innerTex><c path="h3d.mat.Texture"/></innerTex>
		<u><x path="Float"/></u>
		<v><x path="Float"/></v>
		<u2><x path="Float"/></u2>
		<v2><x path="Float"/></v2>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<ix public="1" get="accessor" set="null"><x path="Int"/></ix>
		<get_ix get="inline" set="null" line="21"><f a=""><x path="Int"/></f></get_ix>
		<iy public="1" get="accessor" set="null"><x path="Int"/></iy>
		<get_iy get="inline" set="null" line="24"><f a=""><x path="Int"/></f></get_iy>
		<iwidth public="1" get="accessor" set="null"><x path="Int"/></iwidth>
		<get_iwidth get="inline" set="null" line="27"><f a=""><x path="Int"/></f></get_iwidth>
		<iheight public="1" get="accessor" set="null"><x path="Int"/></iheight>
		<get_iheight get="inline" set="null" line="30"><f a=""><x path="Int"/></f></get_iheight>
		<getTexture public="1" get="inline" set="null" line="43"><f a=""><c path="h3d.mat.Texture"/></f></getTexture>
		<isDisposed public="1" set="method" line="47"><f a=""><x path="Bool"/></f></isDisposed>
		<setTexture set="method" line="51"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<switchTexture public="1" get="inline" set="null" line="61"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></switchTexture>
		<sub public="1" set="method" line="65">
			<f a="x:y:w:h:?dx:?dy" v="::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
		</sub>
		<center public="1" set="method" line="69"><f a=""><c path="h2d.Tile"/></f></center>
		<setCenterRatio public="1" get="inline" set="null" line="73">
			<f a="?px:?py" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ py : 0.5, px : 0.5 }</e></m></meta>
		</setCenterRatio>
		<flipX public="1" set="method" line="78"><f a=""><x path="Void"/></f></flipX>
		<flipY public="1" set="method" line="83"><f a=""><x path="Void"/></f></flipY>
		<setPosition public="1" set="method" line="88"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="100"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<scaleToSize public="1" set="method" line="110"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scaleToSize>
		<scrollDiscrete public="1" set="method" line="115"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollDiscrete>
		<dispose public="1" set="method" line="125"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="130"><f a=""><c path="h2d.Tile"/></f></clone>
		<split public="1" set="method" line="143">
			<f a="?frames:?vertical:?subpixel" v="0:false:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ subpixel : false, vertical : false, frames : 0 }</e></m></meta>
			<haxe_doc>Split horizontaly or verticaly the number of given frames</haxe_doc>
		</split>
		<gridFlatten public="1" set="method" line="165">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.
		Unlike grid which is X/Y ordered, gridFlatten returns a single dimensional array ordered in Y/X.</haxe_doc>
		</gridFlatten>
		<grid public="1" set="method" line="172">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.</haxe_doc>
		</grid>
		<toString public="1" set="method" line="176"><f a=""><c path="String"/></f></toString>
		<upload set="method" line="180"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<x path="Void"/>
</f></upload>
		<new set="method" line="32">
			<f a="tex:x:y:w:h:?dx:?dy" v=":::::0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0, dx : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d</e></m>
		</meta>
	</class>
	<class path="h2d.col.Bounds" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/Bounds.hx">
		<fromValues public="1" get="inline" set="null" line="234" static="1"><f a="x0:y0:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.col.Bounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="243" static="1"><f a="min:max">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Bounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<toIBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IBounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIBounds>
		<intersects public="1" get="inline" set="null" line="28"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="36"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="43"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="50"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="57"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="64"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="69"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="74"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="81"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="88"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="99"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="108"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="115"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="122"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<rotate public="1" set="method" line="133"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<offset public="1" get="inline" set="null" line="144"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="151"><f a=""><c path="h2d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="155"><f a=""><c path="h2d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="159"><f a=""><c path="h2d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="163"><f a=""><c path="h2d.col.Point"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="167"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="171"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="178"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="185"><f a=""><c path="h2d.col.Bounds"/></f></clone>
		<get_x get="inline" set="null" line="194"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="198"><f a=""><x path="Float"/></f></get_y>
		<set_x get="inline" set="null" line="202"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="207"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_width get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_width>
		<get_height get="inline" set="null" line="216"><f a=""><x path="Float"/></f></get_height>
		<set_width get="inline" set="null" line="220"><f a="w">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height get="inline" set="null" line="225"><f a="h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<toString public="1" set="method" line="230"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Collider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/Collider.hx" interface="1"><contains public="1" set="method"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains></class>
	<class path="h2d.col.IBounds" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/IBounds.hx">
		<fromValues public="1" get="inline" set="null" line="203" static="1"><f a="x0:y0:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="212" static="1"><f a="min:max">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IBounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Int"/></xMin>
		<yMin public="1"><x path="Int"/></yMin>
		<xMax public="1"><x path="Int"/></xMax>
		<yMax public="1"><x path="Int"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<toBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toBounds>
		<intersects public="1" get="inline" set="null" line="26"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="30"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="34"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="41"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="48"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="55"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="62"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="67"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="72"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="79"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="86"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="97"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="106"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></load>
		<offset public="1" get="inline" set="null" line="113"><f a="dx:dy">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="120"><f a=""><c path="h2d.col.IPoint"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="124"><f a=""><c path="h2d.col.IPoint"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="128"><f a=""><c path="h2d.col.IPoint"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="132"><f a=""><c path="h2d.col.IPoint"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="136"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="140"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="154"><f a=""><c path="h2d.col.IBounds"/></f></clone>
		<get_x get="inline" set="null" line="163"><f a=""><x path="Int"/></f></get_x>
		<get_y get="inline" set="null" line="167"><f a=""><x path="Int"/></f></get_y>
		<set_x get="inline" set="null" line="171"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<set_y get="inline" set="null" line="176"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<get_width get="inline" set="null" line="181"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="185"><f a=""><x path="Int"/></f></get_height>
		<set_width get="inline" set="null" line="189"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height get="inline" set="null" line="194"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<toString public="1" set="method" line="199"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.IPoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/IPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<toPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Point"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></add>
		<equals public="1" get="inline" set="null" line="40"><f a="other">
	<c path="h2d.col.IPoint"/>
	<x path="Bool"/>
</f></equals>
		<dot public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></dot>
		<lengthSq public="1" get="inline" set="null" line="48"><f a=""><x path="Int"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="52"><f a=""><x path="Float"/></f></length>
		<set public="1" get="inline" set="null" line="56"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<clone public="1" get="inline" set="null" line="61"><f a=""><c path="h2d.col.IPoint"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Matrix" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/Matrix.hx">
		<tmp expr="new Matrix()" line="9" static="1">
			<c path="h2d.col.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<identity public="1" get="inline" set="null" line="22"><f a=""><x path="Void"/></f></identity>
		<initTranslate public="1" get="inline" set="null" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initTranslate>
		<initScale public="1" get="inline" set="null" line="33"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initScale>
		<initRotate public="1" get="inline" set="null" line="38"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotate>
		<initSkew public="1" get="inline" set="null" line="49"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initSkew>
		<invert public="1" set="method" line="60"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="64"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse public="1" set="method" line="68"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></inverse>
		<transform public="1" get="inline" set="null" line="81"><f a="pt">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></transform>
		<translate public="1" get="inline" set="null" line="85"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<translateX public="1" get="inline" set="null" line="90"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></translateX>
		<translateY public="1" get="inline" set="null" line="94"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></translateY>
		<prependTranslate public="1" get="inline" set="null" line="98"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslate>
		<prependTranslateX public="1" get="inline" set="null" line="103"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslateX>
		<prependTranslateY public="1" get="inline" set="null" line="107"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslateY>
		<multiply public="1" set="method" line="111"><f a="a:b">
	<c path="h2d.col.Matrix"/>
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<getScale public="1" get="inline" set="null" line="122"><f a="?p">
	<c path="h2d.col.Point"/>
	<x path="Null"><c path="h2d.col.Point"/></x>
</f></getScale>
		<scale public="1" get="inline" set="null" line="135"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<scaleX public="1" get="inline" set="null" line="144"><f a="sx">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleX>
		<scaleY public="1" get="inline" set="null" line="150"><f a="sy">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleY>
		<rotate public="1" set="method" line="156"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<skew public="1" set="method" line="161"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
		<skewX public="1" set="method" line="175"><f a="sx">
	<x path="Float"/>
	<x path="Void"/>
</f></skewX>
		<skewY public="1" set="method" line="184"><f a="sy">
	<x path="Float"/>
	<x path="Void"/>
</f></skewY>
		<clone public="1" set="method" line="193"><f a=""><c path="h2d.col.Matrix"/></f></clone>
		<getPosition public="1" get="inline" set="null" line="204"><f a="?p">
	<c path="h2d.col.Point"/>
	<x path="Null"><c path="h2d.col.Point"/></x>
</f></getPosition>
		<toString public="1" set="method" line="210"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Affine 2D 2x3 matrix</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Point" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toIPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IPoint"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></add>
		<equals public="1" get="inline" set="null" line="40"><f a="other">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></equals>
		<dot public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<rotate public="1" get="inline" set="null" line="48"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<lengthSq public="1" get="inline" set="null" line="57"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="61"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="65"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="72"><f a=""><x path="Void"/></f></normalizeFast>
		<set public="1" get="inline" set="null" line="79"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<load public="1" get="inline" set="null" line="84"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></load>
		<scale public="1" get="inline" set="null" line="89"><f a="f">
	<x path="Float"/>
	<c path="h2d.col.Point"/>
</f></scale>
		<clone public="1" get="inline" set="null" line="95"><f a=""><c path="h2d.col.Point"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.filter.Filter" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h2d/filter/Filter.hx">
		<autoBounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoBounds>
		<boundsExtend public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</boundsExtend>
		<smooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</smooth>
		<enable public="1" get="accessor" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":isVar"/>
			</meta>
		</enable>
		<get_enable set="method" line="16"><f a=""><x path="Bool"/></f></get_enable>
		<set_enable set="method" line="17"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enable>
		<sync public="1" set="method" line="19"><f a="ctx:s">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></sync>
		<bind public="1" set="method" line="22"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></bind>
		<unbind public="1" set="method" line="25"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></unbind>
		<getBounds public="1" set="method" line="28"><f a="s:bounds">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></getBounds>
		<draw public="1" set="method" line="36"><f a="ctx:input">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></draw>
		<new set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The base filter class, you can extend it in order to define your own filters, although ShaderFilter will be the most straightforward way to define simple custom filter.</haxe_doc>
	</class>
	<enum path="h3d.BufferFlag" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<Dynamic><haxe_doc>Indicate that the buffer content will be often modified.</haxe_doc></Dynamic>
		<Triangles><haxe_doc>The buffer contains only triangles. Imply Managed. Make sure the position is aligned on 3 vertices multiples.</haxe_doc></Triangles>
		<Quads><haxe_doc>The buffer contains only quads. Imply Managed. Make sure the position is aligned on 4 vertices multiples.</haxe_doc></Quads>
		<Managed><haxe_doc>Will allocate the memory as part of an shared buffer pool, preventing a lot of small GPU buffers to be allocated.</haxe_doc></Managed>
		<RawFormat><haxe_doc>Directly map the buffer content to the shader inputs, without assuming [pos:vec3,normal:vec3,uv:vec2] default prefix.</haxe_doc></RawFormat>
		<NoAlloc><haxe_doc>Used internaly</haxe_doc></NoAlloc>
		<UniformBuffer><haxe_doc>Used for shader input buffer</haxe_doc></UniformBuffer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.Buffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Buffer.hx">
		<GUID public="1" expr="0" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</GUID>
		<ofFloats public="1" set="method" line="139" static="1"><f a="v:stride:?flags">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<c path="h3d.Buffer"/>
</f></ofFloats>
		<ofSubFloats public="1" set="method" line="146" static="1"><f a="v:stride:vertices:?flags">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<c path="h3d.Buffer"/>
</f></ofSubFloats>
		<id public="1"><x path="Int"/></id>
		<buffer public="1" set="null"><c path="h3d.impl.ManagedBuffer"/></buffer>
		<position public="1" set="null"><x path="Int"/></position>
		<vertices public="1" set="null"><x path="Int"/></vertices>
		<next public="1" set="null"><c path="h3d.Buffer"/></next>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<isDisposed public="1" set="method" line="68"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="72"><f a=""><x path="Void"/></f></dispose>
		<totalVertices public="1" set="method" line="83">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the total number of vertices including the potential next buffers if it is split.</haxe_doc>
		</totalVertices>
		<uploadVector public="1" set="method" line="93">
			<f a="buf:bufPos:vertices:?startVertice" v=":::0">
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</uploadVector>
		<uploadBytes public="1" set="method" line="110"><f a="data:dataPos:vertices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="122">
			<f a="bytes:bytesPosition:vertices:?startVertice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</readBytes>
		<new public="1" set="method" line="48"><f a="vertices:stride:?flags">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.BufferOffset" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<buffer public="1"><c path="h3d.Buffer"/></buffer>
		<offset public="1"><x path="Int"/></offset>
		<next public="1"><c path="h3d.BufferOffset"/></next>
		<clone public="1" get="inline" set="null" line="176"><f a=""><c path="h3d.BufferOffset"/></f></clone>
		<dispose public="1" set="method" line="184"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="168"><f a="buffer:offset">
	<c path="h3d.Buffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Camera" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Camera.hx">
		<zoom public="1"><x path="Float"/></zoom>
		<screenRatio public="1">
			<x path="Float"/>
			<haxe_doc>The screenRatio represents the W/H screen ratio.</haxe_doc>
		</screenRatio>
		<fovY public="1">
			<x path="Float"/>
			<haxe_doc>The vertical FieldOfView, in degrees.
		Usually cameras are using an horizontal FOV, but the value will change depending on the screen ratio.
		For instance a 4:3 screen will have a lower horizontal FOV than a 16:9 one, however the vertical FOV remains constant.
		Use setFovX to initialize fovY based on an horizontal FOV and an initial screen ratio.</haxe_doc>
		</fovY>
		<zNear public="1"><x path="Float"/></zNear>
		<zFar public="1"><x path="Float"/></zFar>
		<orthoBounds public="1">
			<c path="h3d.col.Bounds"/>
			<haxe_doc>Set orthographic bounds.</haxe_doc>
		</orthoBounds>
		<rightHanded public="1"><x path="Bool"/></rightHanded>
		<mproj public="1"><c path="h3d.Matrix"/></mproj>
		<mcam public="1"><c path="h3d.Matrix"/></mcam>
		<m public="1"><c path="h3d.Matrix"/></m>
		<pos public="1"><c path="h3d.Vector"/></pos>
		<up public="1"><c path="h3d.Vector"/></up>
		<target public="1"><c path="h3d.Vector"/></target>
		<viewX public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewX>
		<viewY public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewY>
		<follow public="1"><a>
	<target><c path="h3d.scene.Object"/></target>
	<pos><c path="h3d.scene.Object"/></pos>
</a></follow>
		<frustum public="1" set="null"><c path="h3d.col.Frustum"/></frustum>
		<minv><c path="h3d.Matrix"/></minv>
		<mcamInv><c path="h3d.Matrix"/></mcamInv>
		<mprojInv><c path="h3d.Matrix"/></mprojInv>
		<needInv><x path="Bool"/></needInv>
		<setFovX public="1" set="method" line="71">
			<f a="fovX:withRatio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the vertical fov based on a given horizontal fov (in degrees) for a specified screen ratio.</haxe_doc>
		</setFovX>
		<getFovX public="1" set="method" line="79">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Calculate the current horizontal fov (in degrees).</haxe_doc>
		</getFovX>
		<clone public="1" set="method" line="86"><f a=""><c path="h3d.Camera"/></f></clone>
		<getInverseViewProj public="1" set="method" line="98">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view and projection. Cache the result until the next update().</haxe_doc>
		</getInverseViewProj>
		<getInverseProj public="1" set="method" line="110">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix projection. Cache the result until the next update().</haxe_doc>
		</getInverseProj>
		<getInverseView public="1" set="method" line="123">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view only. Cache the result until the next update().</haxe_doc>
		</getInverseView>
		<setCubeMap public="1" set="method" line="136">
			<f a="face:?position">
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Setup camera for cubemap rendering on the given face.</haxe_doc>
		</setCubeMap>
		<unproject public="1" set="method" line="158">
			<f a="screenX:screenY:camZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Transforms a 2D screen position into the 3D one according to the current camera.
		The screenX and screenY values must be in the [-1,1] range.
		The camZ value represents the normalized z in the frustum in the [0,1] range.
		[unproject] can be used to get the ray from the camera position to a given screen position by using two different camZ values.
		For instance the 3D ray between unproject(0,0,0) and unproject(0,0,1) is the center axis of the 3D frustum.</haxe_doc>
		</unproject>
		<rayFromScreen public="1" set="method" line="164"><f a="pixelX:pixelY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></rayFromScreen>
		<update public="1" set="method" line="171"><f a=""><x path="Void"/></f></update>
		<getFrustumCorners public="1" set="method" line="204">
			<f a="?zMax" v="1.">
				<x path="Float"/>
				<c path="Array"><c path="h3d.Vector"/></c>
			</f>
			<meta><m n=":value"><e>{ zMax : 1. }</e></m></meta>
		</getFrustumCorners>
		<lostUp public="1" set="method" line="211"><f a=""><x path="Bool"/></f></lostUp>
		<movePosAxis public="1" set="method" line="217">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</movePosAxis>
		<moveTargetAxis public="1" set="method" line="225">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</moveTargetAxis>
		<forward public="1" set="method" line="233">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</forward>
		<backward public="1" set="method" line="242">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</backward>
		<makeCameraMatrix set="method" line="251"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeCameraMatrix>
		<makeFrustumMatrix set="method" line="284"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeFrustumMatrix>
		<project public="1" set="method" line="342">
			<f a="x:y:z:screenWidth:screenHeight:?snapToPixel" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ snapToPixel : true }</e></m></meta>
			<haxe_doc>Project a 3D point into the 2D screen. Make sure to update() the camera if it's been moved before using that.</haxe_doc>
		</project>
		<load public="1" set="method" line="354"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></load>
		<new public="1" set="method" line="51">
			<f a="?fovY:?zoom:?screenRatio:?zNear:?zFar:?rightHanded" v="25.:1.:1.333333:0.02:4000.:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rightHanded : false, zFar : 4000., zNear : 0.02, screenRatio : 1.333333, zoom : 1., fovY : 25. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d._Engine.TargetTmp" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Engine.hx" private="1" module="h3d.Engine">
		<t public="1"><c path="h3d.mat.Texture"/></t>
		<textures public="1"><c path="Array"><c path="h3d.mat.Texture"/></c></textures>
		<next public="1"><c path="h3d._Engine.TargetTmp"/></next>
		<layer public="1"><x path="Int"/></layer>
		<mipLevel public="1"><x path="Int"/></mipLevel>
		<new public="1" set="method" line="10"><f a="t:n:l:m">
	<c path="h3d.mat.Texture"/>
	<c path="h3d._Engine.TargetTmp"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Engine" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Engine.hx">
		<SOFTWARE_DRIVER public="1" expr="false" line="56" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</SOFTWARE_DRIVER>
		<ANTIALIASING public="1" expr="0" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ANTIALIASING>
		<CURRENT expr="null" line="87" static="1">
			<c path="h3d.Engine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</CURRENT>
		<getCurrent public="1" get="inline" set="null" line="94" static="1"><f a=""><c path="h3d.Engine"/></f></getCurrent>
		<driver public="1" set="null"><c path="h3d.impl.Driver"/></driver>
		<mem public="1" set="null"><c path="h3d.impl.MemoryManager"/></mem>
		<hardware public="1" set="null"><x path="Bool"/></hardware>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<debug public="1" set="accessor"><x path="Bool"/></debug>
		<drawTriangles public="1" set="null"><x path="Int"/></drawTriangles>
		<drawCalls public="1" set="null"><x path="Int"/></drawCalls>
		<shaderSwitches public="1" set="null"><x path="Int"/></shaderSwitches>
		<backgroundColor public="1" expr="0xFF000000">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</backgroundColor>
		<autoResize public="1"><x path="Bool"/></autoResize>
		<fullScreen public="1" set="accessor"><x path="Bool"/></fullScreen>
		<fps public="1" get="accessor" set="null"><x path="Float"/></fps>
		<realFps><x path="Float"/></realFps>
		<lastTime><x path="Float"/></lastTime>
		<antiAlias><x path="Int"/></antiAlias>
		<tmpVector expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta><m n=":value"><e>new h3d.Vector()</e></m></meta>
		</tmpVector>
		<window><c path="hxd.Window"/></window>
		<targetTmp><c path="h3d._Engine.TargetTmp"/></targetTmp>
		<targetStack><c path="h3d._Engine.TargetTmp"/></targetStack>
		<currentTargetTex><c path="h3d.mat.Texture"/></currentTargetTex>
		<currentTargetLayer><x path="Int"/></currentTargetLayer>
		<currentTargetMip><x path="Int"/></currentTargetMip>
		<needFlushTarget><x path="Bool"/></needFlushTarget>
		<nullTexture><c path="h3d.mat.Texture"/></nullTexture>
		<textureColorCache expr="new Map&lt;Int,h3d.mat.Texture&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,h3d.mat.Texture>()]]></e></m></meta>
		</textureColorCache>
		<ready public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<resCache expr="new Map&lt;{ },Dynamic&gt;()">
			<x path="haxe.ds.Map">
				<a/>
				<d/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<{ },Dynamic>()]]></e></m>
				<m n=":allow"><e>hxd.res</e></m>
			</meta>
		</resCache>
		<setDriver public="1" set="method" line="89"><f a="d">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></setDriver>
		<setCurrent public="1" get="inline" set="null" line="98"><f a=""><x path="Void"/></f></setCurrent>
		<init public="1" set="method" line="102"><f a=""><x path="Void"/></f></init>
		<driverName public="1" set="method" line="106">
			<f a="?details" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ details : false }</e></m></meta>
		</driverName>
		<selectShader public="1" set="method" line="110"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="116"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="120"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<selectBuffer set="method" line="124"><f a="buf">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></selectBuffer>
		<renderTriBuffer public="1" get="inline" set="null" line="132">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderTriBuffer>
		<renderQuadBuffer public="1" get="inline" set="null" line="136">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderQuadBuffer>
		<renderBuffer set="method" line="141">
			<f a="b:indexes:vertPerTri:?startTri:?drawTri" v=":::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderBuffer>
		<renderIndexed public="1" set="method" line="176">
			<f a="b:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderIndexed>
		<renderMultiBuffers public="1" set="method" line="191">
			<f a="buffers:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.BufferOffset"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderMultiBuffers>
		<renderInstanced public="1" set="method" line="207"><f a="buffers:indexes:commands">
	<c path="h3d.BufferOffset"/>
	<c path="h3d.Indexes"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></renderInstanced>
		<set_debug set="method" line="219"><f a="d">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_debug>
		<onCreate set="method" line="225"><f a="disposed">
	<x path="Bool"/>
	<x path="Void"/>
</f></onCreate>
		<onContextLost public="1" set="dynamic" line="250"><f a=""><x path="Void"/></f></onContextLost>
		<onReady public="1" set="dynamic" line="253"><f a=""><x path="Void"/></f></onReady>
		<onWindowResize set="method" line="256"><f a=""><x path="Void"/></f></onWindowResize>
		<set_fullScreen set="method" line="265"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullScreen>
		<onResized public="1" set="dynamic" line="273"><f a=""><x path="Void"/></f></onResized>
		<resize public="1" set="method" line="276"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<begin public="1" set="method" line="285"><f a=""><x path="Bool"/></f></begin>
		<hasFeature public="1" set="method" line="302"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<end public="1" set="method" line="306"><f a=""><x path="Void"/></f></end>
		<getCurrentTarget public="1" set="method" line="310"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></getCurrentTarget>
		<pushTarget public="1" set="method" line="314">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</pushTarget>
		<updateNeedFlush set="method" line="329"><f a=""><x path="Void"/></f></updateNeedFlush>
		<pushTargets public="1" set="method" line="337"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></pushTargets>
		<popTarget public="1" set="method" line="343"><f a=""><x path="Void"/></f></popTarget>
		<flushTarget get="inline" set="null" line="356"><f a=""><x path="Void"/></f></flushTarget>
		<doFlushTarget set="method" line="360"><f a=""><x path="Void"/></f></doFlushTarget>
		<clearF public="1" set="method" line="377"><f a="color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clearF>
		<clear public="1" set="method" line="382"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setRenderZone public="1" set="method" line="393">
			<f a="?x:?y:?width:?height" v="0:0:-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Sets up a scissored zone to eliminate pixels outside the given range.
	 * Call with no parameters to reset to full viewport.</haxe_doc>
		</setRenderZone>
		<render public="1" set="method" line="398"><f a="obj">
	<a><render set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></a>
	<x path="Bool"/>
</f></render>
		<dispose public="1" set="method" line="415"><f a=""><x path="Void"/></f></dispose>
		<get_fps set="method" line="420"><f a=""><x path="Float"/></f></get_fps>
		<new set="method" line="60">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>hxd.Window</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Indexes" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Indexes.hx">
		<alloc public="1" set="method" line="46" static="1">
			<f a="i:?startPos:?length" v=":0:-1">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Indexes"/>
			</f>
			<meta><m n=":value"><e>{ length : -1, startPos : 0 }</e></m></meta>
		</alloc>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<ibuf><t path="h3d.impl.IndexBuffer"/></ibuf>
		<is32 public="1" set="null"><x path="Bool"/></is32>
		<count public="1" set="null"><x path="Int"/></count>
		<isDisposed public="1" set="method" line="25"><f a=""><x path="Bool"/></f></isDisposed>
		<upload public="1" set="method" line="29">
			<f a="indexes:pos:count:?bufferPos" v=":::0">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferPos : 0 }</e></m></meta>
		</upload>
		<uploadBytes public="1" set="method" line="33"><f a="bytes:dataPos:indices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="37">
			<f a="bytes:bytesPosition:indices:?startIndice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startIndice : 0 }</e></m></meta>
		</readBytes>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="15">
			<f a="count:?is32" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ is32 : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
			<m n=":allow"><e>h3d.Engine</e></m>
		</meta>
	</class>
	<typedef path="h3d.ColorAdjust" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Matrix.hx" module="h3d.Matrix"><a>
	<saturation>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</saturation>
	<lightness>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</lightness>
	<hue>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</hue>
	<gain>
		<x path="Null"><a>
	<color><x path="Int"/></color>
	<alpha><x path="Float"/></alpha>
</a></x>
		<meta><m n=":optional"/></meta>
	</gain>
	<contrast>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</contrast>
</a></typedef>
	<class path="h3d.Matrix" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Matrix.hx">
		<tmp expr="new Matrix()" line="15" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<lumR get="inline" set="null" expr="0.212671" line="572" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.212671</e></m></meta>
		</lumR>
		<lumG get="inline" set="null" expr="0.71516" line="573" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.71516</e></m></meta>
		</lumG>
		<lumB get="inline" set="null" expr="0.072169" line="574" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.072169</e></m></meta>
		</lumB>
		<SQ13 get="inline" set="null" expr="0.57735026918962576450914878050196" line="576" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.57735026918962576450914878050196</e></m></meta>
		</SQ13>
		<I public="1" set="method" line="737" static="1"><f a=""><c path="h3d.Matrix"/></f></I>
		<L public="1" set="method" line="743" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Matrix"/>
</f></L>
		<T public="1" set="method" line="749" static="1">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</T>
		<R public="1" set="method" line="755" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Matrix"/>
</f></R>
		<S public="1" set="method" line="761" static="1">
			<f a="?x:?y:?z" v="1.:1.:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 1.0, y : 1., x : 1. }</e></m></meta>
		</S>
		<lookAtX public="1" set="method" line="770" static="1">
			<f a="dir:?up:?m">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Build a rotation Matrix so the X axis will look at the given direction, and the Z axis will be the Up vector ([0,0,1] by default)</haxe_doc>
		</lookAtX>
		<_11 public="1"><x path="Float"/></_11>
		<_12 public="1"><x path="Float"/></_12>
		<_13 public="1"><x path="Float"/></_13>
		<_14 public="1"><x path="Float"/></_14>
		<_21 public="1"><x path="Float"/></_21>
		<_22 public="1"><x path="Float"/></_22>
		<_23 public="1"><x path="Float"/></_23>
		<_24 public="1"><x path="Float"/></_24>
		<_31 public="1"><x path="Float"/></_31>
		<_32 public="1"><x path="Float"/></_32>
		<_33 public="1"><x path="Float"/></_33>
		<_34 public="1"><x path="Float"/></_34>
		<_41 public="1"><x path="Float"/></_41>
		<_42 public="1"><x path="Float"/></_42>
		<_43 public="1"><x path="Float"/></_43>
		<_44 public="1"><x path="Float"/></_44>
		<tx public="1" get="accessor" set="accessor"><x path="Float"/></tx>
		<ty public="1" get="accessor" set="accessor"><x path="Float"/></ty>
		<tz public="1" get="accessor" set="accessor"><x path="Float"/></tz>
		<get_tx get="inline" set="null" line="41"><f a=""><x path="Float"/></f></get_tx>
		<get_ty get="inline" set="null" line="42"><f a=""><x path="Float"/></f></get_ty>
		<get_tz get="inline" set="null" line="43"><f a=""><x path="Float"/></f></get_tz>
		<set_tx get="inline" set="null" line="44"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<set_ty get="inline" set="null" line="45"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<set_tz get="inline" set="null" line="46"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tz>
		<equal public="1" set="method" line="48"><f a="other">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></equal>
		<zero public="1" set="method" line="55"><f a=""><x path="Void"/></f></zero>
		<identity public="1" set="method" line="62"><f a=""><x path="Void"/></f></identity>
		<initRotationX public="1" set="method" line="69"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationX>
		<initRotationY public="1" set="method" line="78"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationY>
		<initRotationZ public="1" set="method" line="87"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationZ>
		<initTranslation public="1" set="method" line="96">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</initTranslation>
		<initScale public="1" set="method" line="103">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</initScale>
		<initRotationAxis public="1" set="method" line="110"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationAxis>
		<initRotation public="1" set="method" line="135"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<translate public="1" set="method" line="162">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</translate>
		<scale public="1" set="method" line="177">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</scale>
		<rotate public="1" set="method" line="192"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<rotateAxis public="1" set="method" line="198"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateAxis>
		<getPosition public="1" get="inline" set="null" line="204"><f a="?v">
	<c path="h3d.Vector"/>
	<x path="Null"><c path="h3d.Vector"/></x>
</f></getPosition>
		<setPosition public="1" get="inline" set="null" line="210"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setPosition>
		<prependTranslation public="1" set="method" line="217">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</prependTranslation>
		<getScale public="1" get="inline" set="null" line="228"><f a="?v">
	<c path="h3d.Vector"/>
	<x path="Null"><c path="h3d.Vector"/></x>
</f></getScale>
		<prependRotation public="1" set="method" line="242"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotation>
		<prependRotationAxis public="1" set="method" line="248"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotationAxis>
		<prependScale public="1" set="method" line="254">
			<f a="?sx:?sy:?sz" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sz : 1., sy : 1., sx : 1. }</e></m></meta>
		</prependScale>
		<multiply3x4 public="1" set="method" line="261">
			<f a="a:b">
				<c path="h3d.Matrix"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</multiply3x4>
		<multiply3x4inline public="1" get="inline" set="null" line="265"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply3x4inline>
		<multiply public="1" set="method" line="296"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<multiplyValue public="1" set="method" line="327"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></multiplyValue>
		<invert public="1" get="inline" set="null" line="346"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="350"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse3x4 public="1" set="method" line="354"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></inverse3x4>
		<initInverse public="1" set="method" line="388"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse>
		<initInverse3x3 public="1" set="method" line="437"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse3x3>
		<front public="1" get="inline" set="null" line="477"><f a=""><c path="h3d.Vector"/></f></front>
		<right public="1" get="inline" set="null" line="483"><f a=""><c path="h3d.Vector"/></f></right>
		<up public="1" get="inline" set="null" line="489"><f a=""><c path="h3d.Vector"/></f></up>
		<transpose public="1" set="method" line="495"><f a=""><x path="Void"/></f></transpose>
		<clone public="1" set="method" line="505"><f a=""><c path="h3d.Matrix"/></f></clone>
		<load public="1" set="method" line="514"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></load>
		<loadValues public="1" set="method" line="521"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></loadValues>
		<getFloats public="1" set="method" line="528"><f a=""><c path="Array"><x path="Float"/></c></f></getFloats>
		<getEulerAngles public="1" set="method" line="535">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Extracts Euler rotation angles from rotation matrix</haxe_doc>
		</getEulerAngles>
		<toString public="1" set="method" line="561"><f a=""><c path="String"/></f></toString>
		<colorHue public="1" set="method" line="577"><f a="hue">
	<x path="Float"/>
	<x path="Void"/>
</f></colorHue>
		<colorSaturate public="1" set="method" line="603"><f a="sat">
	<x path="Float"/>
	<x path="Void"/>
</f></colorSaturate>
		<colorContrast public="1" set="method" line="625"><f a="contrast">
	<x path="Float"/>
	<x path="Void"/>
</f></colorContrast>
		<colorLightness public="1" set="method" line="643"><f a="lightness">
	<x path="Float"/>
	<x path="Void"/>
</f></colorLightness>
		<colorGain public="1" set="method" line="649"><f a="color:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorGain>
		<colorBits public="1" set="method" line="667"><f a="bits:blend">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorBits>
		<colorAdd public="1" get="inline" set="null" line="715"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></colorAdd>
		<colorSet public="1" get="inline" set="null" line="721">
			<f a="c:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</colorSet>
		<adjustColor public="1" set="method" line="727"><f a="col">
	<t path="h3d.ColorAdjust"/>
	<x path="Void"/>
</f></adjustColor>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.Quat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Quat.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<set public="1" get="inline" set="null" line="19"><f a="x:y:z:w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<identity public="1" get="inline" set="null" line="26"><f a=""><x path="Void"/></f></identity>
		<lengthSq public="1" get="inline" set="null" line="31"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="35"><f a=""><x path="Float"/></f></length>
		<load public="1" get="inline" set="null" line="39"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></load>
		<clone public="1" set="method" line="46"><f a=""><c path="h3d.Quat"/></f></clone>
		<initMoveTo public="1" set="method" line="50"><f a="from:to">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initMoveTo>
		<initDirection public="1" set="method" line="66"><f a="dir">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initDirection>
		<initRotateAxis public="1" set="method" line="108"><f a="x:y:z:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotateAxis>
		<initRotateMatrix public="1" set="method" line="118"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initRotateMatrix>
		<normalize public="1" set="method" line="151"><f a=""><x path="Void"/></f></normalize>
		<initRotation public="1" set="method" line="165"><f a="ax:ay:az">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<multiply public="1" set="method" line="180"><f a="q1:q2">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></multiply>
		<toEuler public="1" set="method" line="191"><f a=""><c path="h3d.Vector"/></f></toEuler>
		<lerp public="1" get="inline" set="null" line="195">
			<f a="q1:q2:v:?nearest" v=":::false">
				<c path="h3d.Quat"/>
				<c path="h3d.Quat"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nearest : false }</e></m></meta>
		</lerp>
		<slerp public="1" set="method" line="211"><f a="q1:q2:v">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Float"/>
	<x path="Void"/>
</f></slerp>
		<conjugate public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></conjugate>
		<negate public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Negate the quaternion: this will not change the actual angle, use `conjugate` for that.</haxe_doc>
		</negate>
		<dot public="1" get="inline" set="null" line="250"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Float"/>
</f></dot>
		<getDirection public="1" get="inline" set="null" line="254"><f a=""><c path="h3d.Vector"/></f></getDirection>
		<toMatrix public="1" set="method" line="261">
			<f a="?m">
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Save to a Left-Handed matrix</haxe_doc>
		</toMatrix>
		<toString public="1" set="method" line="291"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="12">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.Vector" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/Vector.hx">
		<fromColor public="1" get="inline" set="null" line="256" static="1">
			<f a="c:?scale" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1.0 }</e></m></meta>
		</fromColor>
		<fromArray public="1" get="inline" set="null" line="261" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Vector"/>
</f></fromArray>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<distance public="1" get="inline" set="null" line="22"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distance>
		<distanceSq public="1" get="inline" set="null" line="26"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distanceSq>
		<sub public="1" get="inline" set="null" line="33"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></sub>
		<add public="1" get="inline" set="null" line="37"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></add>
		<cross public="1" get="inline" set="null" line="42"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></cross>
		<reflect public="1" get="inline" set="null" line="46"><f a="n">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></reflect>
		<dot3 public="1" get="inline" set="null" line="51"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot3>
		<dot4 public="1" get="inline" set="null" line="55"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot4>
		<lengthSq public="1" get="inline" set="null" line="59"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="63"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="67"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="75"><f a=""><x path="Void"/></f></normalizeFast>
		<getNormalized public="1" get="inline" set="null" line="82"><f a=""><c path="h3d.Vector"/></f></getNormalized>
		<set public="1" get="inline" set="null" line="88">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</set>
		<load public="1" get="inline" set="null" line="95"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></load>
		<scale3 public="1" get="inline" set="null" line="102"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></scale3>
		<project public="1" get="inline" set="null" line="108"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></project>
		<lerp public="1" get="inline" set="null" line="119"><f a="v1:v2:k">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerp>
		<transform3x4 public="1" get="inline" set="null" line="130"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x4>
		<transform3x3 public="1" get="inline" set="null" line="139"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" get="inline" set="null" line="148"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<clone public="1" get="inline" set="null" line="159"><f a=""><c path="h3d.Vector"/></f></clone>
		<toPoint public="1" get="inline" set="null" line="163"><f a=""><c path="h3d.col.Point"/></f></toPoint>
		<toString public="1" set="method" line="167"><f a=""><c path="String"/></f></toString>
		<r public="1" get="accessor" set="accessor"><x path="Float"/></r>
		<g public="1" get="accessor" set="accessor"><x path="Float"/></g>
		<b public="1" get="accessor" set="accessor"><x path="Float"/></b>
		<a public="1" get="accessor" set="accessor"><x path="Float"/></a>
		<get_r get="inline" set="null" line="178"><f a=""><x path="Float"/></f></get_r>
		<get_g get="inline" set="null" line="179"><f a=""><x path="Float"/></f></get_g>
		<get_b get="inline" set="null" line="180"><f a=""><x path="Float"/></f></get_b>
		<get_a get="inline" set="null" line="181"><f a=""><x path="Float"/></f></get_a>
		<set_r get="inline" set="null" line="182"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_r>
		<set_g get="inline" set="null" line="183"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_g>
		<set_b get="inline" set="null" line="184"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<set_a get="inline" set="null" line="185"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<setColor public="1" get="inline" set="null" line="187"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<makeColor public="1" set="method" line="194">
			<f a="hue:?saturation:?brightness" v=":1.:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ brightness : 0.5, saturation : 1. }</e></m></meta>
		</makeColor>
		<toColor public="1" get="inline" set="null" line="230"><f a=""><x path="Int"/></f></toColor>
		<toColorHSL public="1" set="method" line="234"><f a=""><c path="h3d.Vector"/></f></toColorHSL>
		<new public="1" get="inline" set="null" line="15">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<haxe_doc>A 4 floats vector. Everytime a Vector is returned, it means a copy is created.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.anim.AnimatedObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Animation.hx" module="h3d.anim.Animation">
		<objectName public="1"><c path="String"/></objectName>
		<targetObject public="1"><c path="h3d.scene.Object"/></targetObject>
		<targetSkin public="1"><c path="h3d.scene.Skin"/></targetSkin>
		<targetJoint public="1"><x path="Int"/></targetJoint>
		<clone public="1" set="method" line="16"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.anim.Animation" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Animation.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<EPSILON get="inline" set="null" expr="0.000001" line="24" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000001</e></m></meta>
		</EPSILON>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<resourcePath public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</resourcePath>
		<frameCount public="1" set="null">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</frameCount>
		<sampling public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</sampling>
		<frame public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</frame>
		<speed public="1">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</speed>
		<onAnimEnd public="1"><f a=""><x path="Void"/></f></onAnimEnd>
		<onEvent public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onEvent>
		<pause public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</pause>
		<loop public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</loop>
		<events public="1" set="null"><c path="Array"><c path="Array"><c path="String"/></c></c></events>
		<isInstance><x path="Bool"/></isInstance>
		<objects><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></objects>
		<isSync><x path="Bool"/></isSync>
		<lastEvent><x path="Int"/></lastEvent>
		<getDuration public="1" set="method" line="58"><f a=""><x path="Float"/></f></getDuration>
		<getIFrame get="inline" set="null" line="62"><f a=""><x path="Int"/></f></getIFrame>
		<unbind public="1" set="method" line="69"><f a="objectName">
	<c path="String"/>
	<x path="Void"/>
</f></unbind>
		<setEvents public="1" set="method" line="84">
			<f a="el">
				<t path="Iterable"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Register a callback function that will be called once when a frame is reached.</haxe_doc>
		</setEvents>
		<addEvent public="1" set="method" line="92"><f a="frame:data">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></addEvent>
		<getEvents public="1" set="method" line="101"><f a=""><c path="Array"><c path="Array"><c path="String"/></c></c></f></getEvents>
		<getObjects public="1" set="method" line="103"><f a=""><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></f></getObjects>
		<setFrame public="1" set="method" line="105"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></setFrame>
		<clone set="method" line="112"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<c path="h3d.anim.Animation"/>
</f></clone>
		<initInstance set="method" line="124"><f a=""><x path="Void"/></f></initInstance>
		<createInstance public="1" set="method" line="129"><f a="base">
	<c path="h3d.scene.Object"/>
	<c path="h3d.anim.Animation"/>
</f></createInstance>
		<bind public="1" set="method" line="142">
			<f a="base">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene.Skin.skinData</e></m></meta>
			<haxe_doc>If one of the animated object has been changed, it is necessary to call bind() so the animation can keep with the change.</haxe_doc>
		</bind>
		<getPropValue public="1" set="method" line="175">
			<f a="objectName:propName">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>Returns the current value of animation property for the given object, or null if not found.</haxe_doc>
		</getPropValue>
		<sync public="1" set="method" line="183">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ decompose : false }</e></m></meta>
			<haxe_doc>Synchronize the target object matrix.
		If decompose is true, then the rotation quaternion is stored in [m12,m13,m21,m23] instead of mixed with the scale.</haxe_doc>
		</sync>
		<isPlaying set="method" line="188"><f a=""><x path="Bool"/></f></isPlaying>
		<endFrame set="method" line="192"><f a=""><x path="Int"/></f></endFrame>
		<update public="1" set="method" line="196"><f a="dt">
	<x path="Float"/>
	<x path="Float"/>
</f></update>
		<initAndBind set="method" line="260"><f a="obj">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></initAndBind>
		<toString public="1" set="method" line="267"><f a=""><c path="String"/></f></toString>
		<new set="method" line="46"><f a="name:frameCount:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="h3d.anim.DataLayout" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/BufferAnimation.hx" module="h3d.anim.BufferAnimation">
		<Position/>
		<Rotation/>
		<Scale/>
		<UV/>
		<Alpha/>
		<Property/>
		<SingleFrame/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.anim.BufferObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/BufferAnimation.hx" module="h3d.anim.BufferAnimation">
		<extends path="h3d.anim.AnimatedObject"/>
		<layout public="1"><x path="haxe.EnumFlags"><e path="h3d.anim.DataLayout"/></x></layout>
		<dataOffset public="1"><x path="Int"/></dataOffset>
		<propCurrentValue public="1"><x path="Float"/></propCurrentValue>
		<propName public="1"><c path="String"/></propName>
		<matrix public="1"><c path="h3d.Matrix"/></matrix>
		<getStride public="1" set="method" line="28"><f a=""><x path="Int"/></f></getStride>
		<clone public="1" set="method" line="39" override="1"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="23"><f a="objectName:dataOffset">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.BufferAnimation" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/BufferAnimation.hx">
		<extends path="h3d.anim.Animation"/>
		<syncFrame><x path="Float"/></syncFrame>
		<data><t path="hxd.impl.Float32Array"/></data>
		<stride><x path="Int"/></stride>
		<setData public="1" set="method" line="58"><f a="data:stride">
	<t path="hxd.impl.Float32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setData>
		<addObject public="1" set="method" line="63"><f a="objName:offset">
	<c path="String"/>
	<x path="Int"/>
	<c path="h3d.anim.BufferObject"/>
</f></addObject>
		<getPropValue public="1" set="method" line="69" override="1"><f a="objName:propName">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getPropValue>
		<getFrames get="inline" set="null" line="76"><f a=""><c path="Array"><c path="h3d.anim.BufferObject"/></c></f></getFrames>
		<clone set="method" line="80" override="1"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<x path="Null"><c path="h3d.anim.Animation"/></x>
</f></clone>
		<endFrame set="method" line="89" override="1"><f a=""><x path="Int"/></f></endFrame>
		<initInstance set="method" line="95" override="1"><f a=""><x path="Void"/></f></initInstance>
		<sortByFrameCountDesc set="method" line="119"><f a="o1:o2">
	<c path="h3d.anim.BufferObject"/>
	<c path="h3d.anim.BufferObject"/>
	<x path="Int"/>
</f></sortByFrameCountDesc>
		<uvLerp get="inline" set="null" line="123"><f a="v1:v2:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></uvLerp>
		<sync public="1" set="method" line="135" override="1">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ decompose : false }</e></m>
				<m n=":access"><e>h3d.scene.Skin</e></m>
				<m n=":noDebug"/>
			</meta>
		</sync>
		<new public="1" set="method" line="53"><f a="name:frame:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearFrame" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<tz public="1"><x path="Float"/></tz>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<toMatrix public="1" set="method" line="17"><f a=""><c path="h3d.Matrix"/></f></toMatrix>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<extends path="h3d.anim.AnimatedObject"/>
		<hasPosition public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</hasPosition>
		<hasRotation public="1"><x path="Bool"/></hasRotation>
		<hasScale public="1"><x path="Bool"/></hasScale>
		<frames public="1"><x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x></frames>
		<alphas public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></alphas>
		<uvs public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></uvs>
		<propName public="1"><c path="String"/></propName>
		<propValues public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></propValues>
		<matrix public="1"><c path="h3d.Matrix"/></matrix>
		<propCurrentValue public="1"><x path="Float"/></propCurrentValue>
		<clone public="1" set="method" line="37" override="1"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="26"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearAnimation" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/LinearAnimation.hx">
		<extends path="h3d.anim.Animation"/>
		<syncFrame><x path="Float"/></syncFrame>
		<addCurve public="1" set="method" line="60"><f a="objName:frames:hasPos:hasRot:hasScale">
	<c path="String"/>
	<x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addCurve>
		<addAlphaCurve public="1" set="method" line="69"><f a="objName:alphas">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addAlphaCurve>
		<addUVCurve public="1" set="method" line="75"><f a="objName:uvs">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addUVCurve>
		<addPropCurve public="1" set="method" line="81"><f a="objName:propName:values">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addPropCurve>
		<getPropValue public="1" set="method" line="88" override="1"><f a="objName:propName">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getPropValue>
		<getFrames get="inline" set="null" line="95"><f a=""><c path="Array"><c path="h3d.anim.LinearObject"/></c></f></getFrames>
		<clone set="method" line="99" override="1"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<x path="Null"><c path="h3d.anim.Animation"/></x>
</f></clone>
		<endFrame set="method" line="106" override="1"><f a=""><x path="Int"/></f></endFrame>
		<initInstance set="method" line="112" override="1"><f a=""><x path="Void"/></f></initInstance>
		<sortByFrameCountDesc set="method" line="130"><f a="o1:o2">
	<c path="h3d.anim.LinearObject"/>
	<c path="h3d.anim.LinearObject"/>
	<x path="Int"/>
</f></sortByFrameCountDesc>
		<uvLerp get="inline" set="null" line="134"><f a="v1:v2:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></uvLerp>
		<sync public="1" set="method" line="146" override="1">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ decompose : false }</e></m>
				<m n=":access"><e>h3d.scene.Skin</e></m>
				<m n=":noDebug"/>
			</meta>
		</sync>
		<new public="1" set="method" line="55"><f a="name:frame:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Joint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Skin.hx" module="h3d.anim.Skin">
		<index public="1"><x path="Int"/></index>
		<name public="1"><c path="String"/></name>
		<bindIndex public="1"><x path="Int"/></bindIndex>
		<splitIndex public="1"><x path="Int"/></splitIndex>
		<defMat public="1"><c path="h3d.Matrix"/></defMat>
		<transPos public="1"><c path="h3d.Matrix"/></transPos>
		<parent public="1"><c path="h3d.anim.Joint"/></parent>
		<subs public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></subs>
		<retargetAnim public="1">
			<x path="Bool"/>
			<haxe_doc>When animated, we will use the default bind pose translation instead of the animated translation,
		enabling retargeting on a skeleton with different proportions</haxe_doc>
		</retargetAnim>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Permut" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<joints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
		<triangles public="1"><c path="Array"><x path="Int"/></c></triangles>
		<material public="1"><x path="Int"/></material>
		<indexedJoints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></indexedJoints>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Influence" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<j public="1"><c path="h3d.anim.Joint"/></j>
		<w public="1"><x path="Float"/></w>
		<new public="1" set="method" line="39"><f a="j:w">
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Skin" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/anim/Skin.hx">
		<name public="1"><c path="String"/></name>
		<vertexCount public="1" set="null"><x path="Int"/></vertexCount>
		<bonesPerVertex public="1" set="null"><x path="Int"/></bonesPerVertex>
		<vertexJoints public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></vertexJoints>
		<vertexWeights public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></vertexWeights>
		<rootJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></rootJoints>
		<namedJoints public="1" set="null"><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Joint"/>
</t></namedJoints>
		<allJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></allJoints>
		<boundJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></boundJoints>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<splitJoints public="1" set="null"><c path="Array"><a>
	<material><x path="Int"/></material>
	<joints><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
</a></c></splitJoints>
		<triangleGroups public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></triangleGroups>
		<envelop><c path="Array"><c path="Array"><c path="h3d.anim._Skin.Influence"/></c></c></envelop>
		<setJoints public="1" set="method" line="77"><f a="joints:roots">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Void"/>
</f></setJoints>
		<addInfluence public="1" get="inline" set="null" line="86"><f a="vid:j:w">
	<x path="Int"/>
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addInfluence>
		<sortInfluences set="method" line="93"><f a="i1:i2">
	<c path="h3d.anim._Skin.Influence"/>
	<c path="h3d.anim._Skin.Influence"/>
	<x path="Int"/>
</f></sortInfluences>
		<isSplit public="1" get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></isSplit>
		<initWeights public="1" set="method" line="101"><f a=""><x path="Void"/></f></initWeights>
		<sortByBindIndex set="method" line="133"><f a="j1:j2">
	<c path="h3d.anim.Joint"/>
	<c path="h3d.anim.Joint"/>
	<x path="Int"/>
</f></sortByBindIndex>
		<isSub set="method" line="137"><f a="a:b">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Bool"/>
</f></isSub>
		<merge set="method" line="149"><f a="permuts">
	<c path="Array"><c path="h3d.anim._Skin.Permut"/></c>
	<x path="Bool"/>
</f></merge>
		<jointsDiff set="method" line="161"><f a="p1:p2">
	<c path="h3d.anim._Skin.Permut"/>
	<c path="h3d.anim._Skin.Permut"/>
	<x path="Int"/>
</f></jointsDiff>
		<split public="1" set="method" line="182"><f a="maxBones:index:triangleMaterials">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Null"><c path="Array"><x path="Int"/></c></x>
	<x path="Bool"/>
</f></split>
		<new public="1" set="method" line="66"><f a="name:vertexCount:bonesPerVertex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Collider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Collider.hx" interface="1">
		<extends path="hxd.impl._Serializable.NoSerializeSupport"/>
		<rayIntersection public="1" set="method">
			<f a="r:bestMatch">
				<c path="h3d.col.Ray"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the distance of intersection between the ray and the collider, or negative if no collision.
		If bestMatch is false, only negative/positive value needs to be returned, with no additional precision.</haxe_doc>
		</rayIntersection>
		<contains public="1" set="method"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method"><f a="f:?localMatrix">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
	</class>
	<class path="h3d.col.Bounds" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Bounds.hx">
		<implements path="h3d.col.Collider"/>
		<fromPoints public="1" get="inline" set="null" line="361" static="1"><f a="min:max">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Bounds"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="368" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Bounds"/>
</f></fromValues>
		<xMin public="1"><x path="Float"/></xMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMin public="1"><x path="Float"/></yMin>
		<yMax public="1"><x path="Float"/></yMax>
		<zMin public="1"><x path="Float"/></zMin>
		<zMax public="1"><x path="Float"/></zMax>
		<xSize public="1" get="accessor" set="accessor"><x path="Float"/></xSize>
		<ySize public="1" get="accessor" set="accessor"><x path="Float"/></ySize>
		<zSize public="1" get="accessor" set="accessor"><x path="Float"/></zSize>
		<inFrustum public="1" get="inline" set="null" line="21"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" get="inline" set="null" line="27"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<testPlane get="inline" set="null" line="33"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Float"/>
</f></testPlane>
		<rayIntersection public="1" set="method" line="45"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustumDetails public="1" set="method" line="73">
			<f a="mvp:?checkZ" v=":true">
				<c path="h3d.Matrix"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ checkZ : true }</e></m></meta>
			<haxe_doc>* Check if the camera model-view-projection Matrix intersects with the Bounds. Returns -1 if outside, 0 if interests and 1 if fully inside.
	 * @param	mvp : the model-view-projection matrix to test against
	 * @param	checkZ : tells if we will check against the near/far plane</haxe_doc>
		</inFrustumDetails>
		<transform3x3 public="1" set="method" line="126"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" set="method" line="156"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<collide public="1" get="inline" set="null" line="189"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<contains public="1" get="inline" set="null" line="193"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<add public="1" get="inline" set="null" line="197"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></add>
		<addPoint public="1" get="inline" set="null" line="206"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="215"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<intersection public="1" set="method" line="224"><f a="a:b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></intersection>
		<offset public="1" get="inline" set="null" line="239"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setMin public="1" get="inline" set="null" line="248"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="254"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<load public="1" set="method" line="260"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="269"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="279"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<getMin public="1" get="inline" set="null" line="294"><f a=""><c path="h3d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="298"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="302"><f a=""><c path="h3d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="306"><f a=""><c path="h3d.col.Point"/></f></getMax>
		<get_xSize get="inline" set="null" line="310"><f a=""><x path="Float"/></f></get_xSize>
		<get_ySize get="inline" set="null" line="311"><f a=""><x path="Float"/></f></get_ySize>
		<get_zSize get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_zSize>
		<set_xSize get="inline" set="null" line="313"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_xSize>
		<set_ySize get="inline" set="null" line="314"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ySize>
		<set_zSize get="inline" set="null" line="315"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zSize>
		<isEmpty public="1" get="inline" set="null" line="317"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="330"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="339"><f a=""><c path="h3d.col.Bounds"/></f></clone>
		<toString public="1" set="method" line="350"><f a=""><c path="String"/></f></toString>
		<toSphere public="1" get="inline" set="null" line="354"><f a=""><c path="h3d.col.Sphere"/></f></toSphere>
		<new public="1" get="inline" set="null" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.OptimizedCollider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<a public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</a>
		<b public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</b>
		<rayIntersection public="1" set="method" line="26"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="32"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="36"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="40"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="21"><f a="a:b">
	<c path="h3d.col.Collider"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.GroupCollider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<colliders public="1"><c path="Array"><c path="h3d.col.Collider"/></c></colliders>
		<rayIntersection public="1" set="method" line="61"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="73"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="80"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="87"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="57"><f a="colliders">
	<c path="Array"><c path="h3d.col.Collider"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.FPoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/FPoint.hx">
		<x public="1"><t path="hxd.impl.Float32"/></x>
		<y public="1"><t path="hxd.impl.Float32"/></y>
		<z public="1"><t path="hxd.impl.Float32"/></z>
		<sub public="1" get="inline" set="null" line="16"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></sub>
		<add public="1" get="inline" set="null" line="20"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></add>
		<cross public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></cross>
		<dot public="1" get="inline" set="null" line="28"><f a="p">
	<c path="h3d.col.FPoint"/>
	<x path="Float"/>
</f></dot>
		<toString public="1" set="method" line="32"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
	</class>
	<class path="h3d.col.Frustum" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Frustum.hx">
		<pleft public="1"><c path="h3d.col.Plane"/></pleft>
		<pright public="1"><c path="h3d.col.Plane"/></pright>
		<ptop public="1"><c path="h3d.col.Plane"/></ptop>
		<pbottom public="1"><c path="h3d.col.Plane"/></pbottom>
		<pnear public="1"><c path="h3d.col.Plane"/></pnear>
		<pfar public="1"><c path="h3d.col.Plane"/></pfar>
		<checkNearFar public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</checkNearFar>
		<clone public="1" set="method" line="24"><f a=""><c path="h3d.col.Frustum"/></f></clone>
		<loadMatrix public="1" set="method" line="36"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></loadMatrix>
		<transform public="1" set="method" line="51"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="71"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<hasPoint public="1" set="method" line="91"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></hasPoint>
		<hasSphere public="1" set="method" line="103"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></hasSphere>
		<hasBounds public="1" set="method" line="116"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></hasBounds>
		<new public="1" set="method" line="13"><f a="?mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Ray" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Ray.hx">
		<fromPoints public="1" get="inline" set="null" line="137" static="1"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Ray"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="149" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></fromValues>
		<px public="1"><x path="Float"/></px>
		<py public="1"><x path="Float"/></py>
		<pz public="1"><x path="Float"/></pz>
		<lx public="1"><x path="Float"/></lx>
		<ly public="1"><x path="Float"/></ly>
		<lz public="1"><x path="Float"/></lz>
		<clone public="1" get="inline" set="null" line="17"><f a=""><c path="h3d.col.Ray"/></f></clone>
		<load public="1" get="inline" set="null" line="28"><f a="r">
	<c path="h3d.col.Ray"/>
	<x path="Void"/>
</f></load>
		<normalize set="method" line="37"><f a=""><x path="Void"/></f></normalize>
		<transform public="1" get="inline" set="null" line="46"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPos public="1" get="inline" set="null" line="60"><f a=""><c path="h3d.col.Point"/></f></getPos>
		<getDir public="1" get="inline" set="null" line="64"><f a=""><c path="h3d.col.Point"/></f></getDir>
		<getPoint public="1" get="inline" set="null" line="68"><f a="distance">
	<x path="Float"/>
	<c path="h3d.col.Point"/>
</f></getPoint>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<intersect public="1" get="inline" set="null" line="76"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Null"><c path="h3d.col.Point"/></x>
</f></intersect>
		<collideFrustum public="1" get="inline" set="null" line="88"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></collideFrustum>
		<collide public="1" get="inline" set="null" line="113"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<new public="1" get="inline" set="null" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.ObjectCollider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/ObjectCollider.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<implements path="h3d.col.Collider"/>
		<TMP_RAY expr="new Ray()" line="7" static="1">
			<c path="h3d.col.Ray"/>
			<meta><m n=":value"><e>new Ray()</e></m></meta>
		</TMP_RAY>
		<TMP_MAT expr="new Matrix()" line="8" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</TMP_MAT>
		<obj public="1">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
		</obj>
		<collider public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</collider>
		<rayIntersection public="1" set="method" line="15"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="33"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="41"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="49"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="10"><f a="obj:collider">
	<c path="h3d.scene.Object"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Plane" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Plane.hx">
		<fromPoints public="1" get="inline" set="null" line="99" static="1"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromPoints>
		<fromNormalPoint public="1" get="inline" set="null" line="106" static="1"><f a="n:p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromNormalPoint>
		<X public="1" get="inline" set="null" line="110" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" line="114" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" line="118" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Z>
		<frustumLeft public="1" get="inline" set="null" line="122" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumLeft>
		<frustumRight public="1" get="inline" set="null" line="126" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumRight>
		<frustumBottom public="1" get="inline" set="null" line="130" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumBottom>
		<frustumTop public="1" get="inline" set="null" line="134" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumTop>
		<frustumNear public="1" get="inline" set="null" line="138" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumNear>
		<frustumFar public="1" get="inline" set="null" line="142" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumFar>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<getNormal public="1" get="inline" set="null" line="23">
			<f a=""><c path="h3d.col.Point"/></f>
			<haxe_doc>Returns the plan normal</haxe_doc>
		</getNormal>
		<getNormalDistance public="1" get="inline" set="null" line="27"><f a=""><x path="Float"/></f></getNormalDistance>
		<load public="1" get="inline" set="null" line="31"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="38"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="45"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transformInverseTranspose get="inline" set="null" line="52"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transformInverseTranspose>
		<normalize public="1" get="inline" set="null" line="64">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Normalize the plan, so we can use distance().</haxe_doc>
		</normalize>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<distance public="1" get="inline" set="null" line="79">
			<f a="p">
				<c path="h3d.col.Point"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the signed distance between a point an the plane. This requires the plan to be normalized. If the distance is negative it means that we are "under" the plan.</haxe_doc>
		</distance>
		<side public="1" get="inline" set="null" line="83"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<project public="1" get="inline" set="null" line="87"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></project>
		<projectTo public="1" get="inline" set="null" line="92"><f a="p:out">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></projectTo>
		<new public="1" get="inline" set="null" line="13"><f a="nx:ny:nz:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.Point" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<scale public="1" get="inline" set="null" line="16"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<inFrustum public="1" get="inline" set="null" line="22"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<set public="1" get="inline" set="null" line="26"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<multiply public="1" get="inline" set="null" line="32"><f a="f">
	<x path="Float"/>
	<c path="h3d.col.Point"/>
</f></multiply>
		<sub public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="40"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></add>
		<cross public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></cross>
		<equals public="1" get="inline" set="null" line="48"><f a="other">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></equals>
		<lengthSq public="1" get="inline" set="null" line="52"><f a=""><x path="Float"/></f></lengthSq>
		<setLength public="1" get="inline" set="null" line="56"><f a="len">
	<x path="Float"/>
	<x path="Void"/>
</f></setLength>
		<length public="1" get="inline" set="null" line="63"><f a=""><x path="Float"/></f></length>
		<dot public="1" get="inline" set="null" line="67"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<distanceSq public="1" get="inline" set="null" line="71"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="78"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<normalize public="1" set="method" line="82"><f a=""><c path="h3d.col.Point"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="91"><f a=""><c path="h3d.col.Point"/></f></normalizeFast>
		<lerp public="1" get="inline" set="null" line="100"><f a="p1:p2:k">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerp>
		<transform public="1" get="inline" set="null" line="109"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" get="inline" set="null" line="118"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<toVector public="1" get="inline" set="null" line="127"><f a=""><c path="h3d.Vector"/></f></toVector>
		<clone public="1" get="inline" set="null" line="131"><f a=""><c path="h3d.col.Point"/></f></clone>
		<load public="1" get="inline" set="null" line="135"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></load>
		<toString public="1" set="method" line="141"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.TriPlane" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Polygon.hx" module="h3d.col.Polygon">
		<implements path="h3d.col.Collider"/>
		<next public="1" expr="null">
			<c path="h3d.col.TriPlane"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<p0x><x path="Float"/></p0x>
		<p0y><x path="Float"/></p0y>
		<p0z><x path="Float"/></p0z>
		<d1x><x path="Float"/></d1x>
		<d1y><x path="Float"/></d1y>
		<d1z><x path="Float"/></d1z>
		<d2x><x path="Float"/></d2x>
		<d2y><x path="Float"/></d2y>
		<d2z><x path="Float"/></d2z>
		<dot00><x path="Float"/></dot00>
		<dot01><x path="Float"/></dot01>
		<dot11><x path="Float"/></dot11>
		<invDenom><x path="Float"/></invDenom>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<init public="1" get="inline" set="null" line="32"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></init>
		<clone public="1" get="inline" set="null" line="57"><f a=""><c path="h3d.col.TriPlane"/></f></clone>
		<load public="1" get="inline" set="null" line="65"><f a="tp">
	<c path="h3d.col.TriPlane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="85"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<contains public="1" get="inline" set="null" line="95"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<side public="1" get="inline" set="null" line="99"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<inFrustum public="1" set="method" line="103"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="108"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" get="inline" set="null" line="113"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<isPointInTriangle get="inline" set="null" line="129"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInTriangle>
		<getPoints public="1" set="method" line="143"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col.Polygon</e></m>
		</meta>
	</class>
	<class path="h3d.col.Polygon" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Polygon.hx">
		<implements path="h3d.col.Collider"/>
		<triPlanes><c path="h3d.col.TriPlane"/></triPlanes>
		<addBuffers public="1" set="method" line="165">
			<f a="vertexes:indexes:?stride" v="::3">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : 3 }</e></m></meta>
		</addBuffers>
		<isConvex public="1" set="method" line="186"><f a=""><x path="Bool"/></f></isConvex>
		<clone public="1" set="method" line="191"><f a=""><c path="h3d.col.Polygon"/></f></clone>
		<transform public="1" set="method" line="198"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPoints public="1" set="method" line="206"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<getBounds public="1" set="method" line="216"><f a="?bnds">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBounds>
		<contains public="1" set="method" line="229"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="241"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" set="method" line="255"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="260"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="162"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.PolygonBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/PolygonBuffer.hx">
		<implements path="h3d.col.Collider"/>
		<buffer><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></buffer>
		<indexes><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<startIndex><x path="Int"/></startIndex>
		<triCount><x path="Int"/></triCount>
		<source public="1"><a>
	<geometryName><c path="String"/></geometryName>
	<entry><c path="hxd.fs.FileEntry"/></entry>
</a></source>
		<setData public="1" set="method" line="14">
			<f a="buffer:indexes:?startIndex:?triCount" v="::0:-1">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triCount : -1, startIndex : 0 }</e></m></meta>
		</setData>
		<contains public="1" set="method" line="21"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="44"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="49"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" set="method" line="55"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.SkinCollider" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/SkinCollider.hx">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<obj>
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</obj>
		<col>
			<c path="h3d.col.PolygonBuffer"/>
			<meta><m n=":s"/></meta>
		</col>
		<transform><c path="h3d.col.PolygonBuffer"/></transform>
		<lastFrame><x path="Int"/></lastFrame>
		<contains public="1" set="method" line="19"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="24"><f a="p:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="31"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" set="method" line="36"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<applyTransform set="method" line="41"><f a=""><x path="Void"/></f></applyTransform>
		<new public="1" set="method" line="12"><f a="obj:col">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.col.PolygonBuffer</e></m>
			<m n=":access"><e>h3d.scene.Skin</e></m>
		</meta>
	</class>
	<class path="h3d.col.Sphere" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/col/Sphere.hx">
		<implements path="h3d.col.Collider"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<load public="1" get="inline" set="null" line="14">
			<f a="?sx:?sy:?sz:?sr" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sr : 0., sz : 0., sy : 0., sx : 0. }</e></m></meta>
		</load>
		<getCenter public="1" get="inline" set="null" line="21"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<contains public="1" get="inline" set="null" line="25"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="32"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" get="inline" set="null" line="50"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inFrustumMatrix set="method" line="55"><f a="f:m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustumMatrix>
		<inSphere public="1" get="inline" set="null" line="72"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<toString public="1" set="method" line="76"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z:?r" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ r : 0., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.impl.IndexBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.VertexBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Texture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.DepthBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Query" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<enum path="h3d.impl.Feature" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<StandardDerivatives/>
		<FloatTextures/>
		<AllocDepthBuffer/>
		<HardwareAccelerated/>
		<MultipleRenderTargets/>
		<Queries/>
		<SRGBTextures/>
		<ShaderModel3/>
		<BottomLeftCoords/>
		<Wireframe/>
		<InstancedRendering/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.impl.QueryKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<TimeStamp><haxe_doc>The result will give the GPU Timestamp (in nanoseconds, 1e-9 seconds) at the time the endQuery is performed</haxe_doc></TimeStamp>
		<Samples><haxe_doc>The result will give the number of samples that passes the depth buffer between beginQuery/endQuery range</haxe_doc></Samples>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="h3d.impl.RenderFlag" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<CameraHandness><haxe_doc>0 = LeftHanded (default), 1 = RightHanded. Affects the meaning of triangle culling value.</haxe_doc></CameraHandness>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="h3d.impl.InputNames" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<UID expr="0" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<CACHE expr="new Map&lt;String,InputNames&gt;()" line="128" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="h3d.impl.InputNames"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,InputNames>()]]></e></m></meta>
		</CACHE>
		<get public="1" set="method" line="129" static="1"><f a="names">
	<c path="Array"><c path="String"/></c>
	<x path="Null"><c path="h3d.impl.InputNames"/></x>
</f></get>
		<id public="1" set="null"><x path="Int"/></id>
		<names public="1" set="null"><c path="Array"><c path="String"/></c></names>
		<new set="method" line="123"><f a="names">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.Driver" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/Driver.hx">
		<logEnable public="1"><x path="Bool"/></logEnable>
		<hasFeature public="1" set="method" line="144"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setRenderFlag public="1" set="method" line="148"><f a="r:value">
	<e path="h3d.impl.RenderFlag"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderFlag>
		<isSupportedFormat public="1" set="method" line="151"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="155"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="159"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="162"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<log public="1" get="inline" set="null" line="165"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<generateMipMaps public="1" set="method" line="171"><f a="texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></generateMipMaps>
		<getNativeShaderCode public="1" set="method" line="175"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<logImpl set="method" line="179"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<clear public="1" set="method" line="182"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="185"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<capturePixels public="1" set="method" line="188"><f a="tex:layer:mipLevel:?region">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
	<c path="hxd.Pixels"/>
</f></capturePixels>
		<getDriverName public="1" set="method" line="193"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="197">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="200"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="203"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="207"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="210"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<getShaderInputNames public="1" set="method" line="213"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="217"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="220"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="223"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<drawInstanced public="1" set="method" line="226"><f a="ibuf:commands">
	<t path="h3d.impl.IndexBuffer"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></drawInstanced>
		<setRenderZone public="1" set="method" line="229"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="232">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="235"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<allocDepthBuffer public="1" set="method" line="238"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<t path="h3d.impl.DepthBuffer"/>
</f></allocDepthBuffer>
		<disposeDepthBuffer public="1" set="method" line="242"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<x path="Void"/>
</f></disposeDepthBuffer>
		<getDefaultDepthBuffer public="1" set="method" line="245"><f a=""><c path="h3d.mat.DepthBuffer"/></f></getDefaultDepthBuffer>
		<present public="1" set="method" line="249"><f a=""><x path="Void"/></f></present>
		<end public="1" set="method" line="252"><f a=""><x path="Void"/></f></end>
		<setDebug public="1" set="method" line="255"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="258"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="262"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="266"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<allocInstanceBuffer public="1" set="method" line="270"><f a="b:bytes">
	<c path="h3d.impl.InstanceBuffer"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></allocInstanceBuffer>
		<disposeTexture public="1" set="method" line="273"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="276"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="279"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<disposeInstanceBuffer public="1" set="method" line="282"><f a="b">
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></disposeInstanceBuffer>
		<uploadIndexBuffer public="1" set="method" line="285"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="288"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="291"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="294"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="297"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="300"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<readVertexBytes public="1" set="method" line="303"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readVertexBytes>
		<readIndexBytes public="1" set="method" line="307"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readIndexBytes>
		<copyTexture public="1" set="method" line="314">
			<f a="from:to">
				<c path="h3d.mat.Texture"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if we could copy the texture, false otherwise (not supported by driver or mismatch in size/format)</haxe_doc>
		</copyTexture>
		<allocQuery public="1" set="method" line="320"><f a="queryKind">
	<e path="h3d.impl.QueryKind"/>
	<t path="h3d.impl.Query"/>
</f></allocQuery>
		<deleteQuery public="1" set="method" line="324"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></deleteQuery>
		<beginQuery public="1" set="method" line="327"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></beginQuery>
		<endQuery public="1" set="method" line="330"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></endQuery>
		<queryResultAvailable public="1" set="method" line="333"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Bool"/>
</f></queryResultAvailable>
		<queryResult public="1" set="method" line="337"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Float"/>
</f></queryResult>
	</class>
	<class path="h3d.impl.InstanceBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/InstanceBuffer.hx">
		<data><d/></data>
		<driver><c path="h3d.impl.Driver"/></driver>
		<indexCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</indexCount>
		<triCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triCount>
		<commandCount public="1" set="null"><x path="Int"/></commandCount>
		<setCommand public="1" set="method" line="15"><f a="commandCount:indexCount">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCommand>
		<setBuffer public="1" set="method" line="29">
			<f a="commandCount:bytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bytes are structures of 5 i32 with the following values:
		- indexCount : number of indexes per instance
		- instanceCount : number of indexed draws
		- startIndexLocation : offset in indexes
		- baseVertexLocation : offset in buffer
		- startInstanceLocation : offset in per instance buffer</haxe_doc>
		</setBuffer>
		<dispose public="1" set="method" line="45"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>h3d.impl.Driver</e></m></meta>
	</class>
	<class path="h3d.impl.LogDriver" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/LogDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<debug public="1" set="method" line="359" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></debug>
		<d><c path="h3d.impl.Driver"/></d>
		<loggedShaders expr="new Map&lt;Int,Bool&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Bool>()]]></e></m></meta>
		</loggedShaders>
		<currentShader><c path="hxsl.RuntimeShader"/></currentShader>
		<logLines public="1" expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</logLines>
		<logImpl set="method" line="17" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<hasFeature public="1" set="method" line="24" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="28" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="32" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="41" override="1"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="46" override="1"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="51" override="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<getDriverName public="1" set="method" line="56" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="60" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="68" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="73" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getNativeShaderCode public="1" set="method" line="168" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<selectMaterial public="1" set="method" line="172" override="1"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<sizeOf set="method" line="177"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></sizeOf>
		<uploadShaderBuffers public="1" set="method" line="190" override="1"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<textureInfos set="method" line="236"><f a="buf:tid">
	<x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x>
	<x path="Int"/>
	<c path="String"/>
</f></textureInfos>
		<getShaderInputNames public="1" set="method" line="250" override="1"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="254" override="1"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="259" override="1"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="264" override="1"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<setRenderZone public="1" set="method" line="269" override="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="274" override="1">
			<f a="tex:?face:?mipMap" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipMap : 0, face : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="279" override="1"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<end public="1" set="method" line="284" override="1"><f a=""><x path="Void"/></f></end>
		<present public="1" set="method" line="289" override="1"><f a=""><x path="Void"/></f></present>
		<setDebug public="1" set="method" line="294" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="299" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="304" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="309" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<disposeTexture public="1" set="method" line="314" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="319" override="1"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="324" override="1"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<uploadIndexBuffer public="1" set="method" line="329" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="334" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="339" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="344" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="349" override="1"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="354" override="1"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<new public="1" set="method" line="11"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl._ManagedBuffer.FreeCell" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/ManagedBuffer.hx" private="1" module="h3d.impl.ManagedBuffer">
		<pos><x path="Int"/></pos>
		<count><x path="Int"/></count>
		<next><c path="h3d.impl._ManagedBuffer.FreeCell"/></next>
		<new set="method" line="8"><f a="pos:count:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.impl._ManagedBuffer.FreeCell"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.impl.ManagedBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/ManagedBuffer.hx">
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<stride public="1" set="null"><x path="Int"/></stride>
		<size public="1" set="null"><x path="Int"/></size>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<vbuf><t path="h3d.impl.VertexBuffer"/></vbuf>
		<freeList><c path="h3d.impl._ManagedBuffer.FreeCell"/></freeList>
		<next><c path="h3d.impl.ManagedBuffer"/></next>
		<uploadVertexBuffer public="1" set="method" line="44">
			<f a="start:vertices:buf:?bufPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufPos : 0 }</e></m></meta>
		</uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="48">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</uploadVertexBytes>
		<readVertexBytes public="1" set="method" line="52">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</readVertexBytes>
		<alloc public="1" set="method" line="56"><f a="vertices:align">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Buffer"/>
</f></alloc>
		<getFreeVertices public="1" set="method" line="72"><f a=""><x path="Int"/></f></getFreeVertices>
		<allocPosition set="method" line="82"><f a="nvert:align">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></allocPosition>
		<allocBuffer set="method" line="107"><f a="b">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></allocBuffer>
		<freeBuffer set="method" line="123">
			<f a="b">
				<c path="h3d.Buffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Buffer.dispose</e></m></meta>
		</freeBuffer>
		<dispose public="1" set="method" line="174"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="30"><f a="stride:size:?flags">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
		</meta>
	</class>
	<class path="h3d.impl.MemoryManager" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/MemoryManager.hx">
		<MAX_MEMORY get="inline" set="null" expr="4096 * (1024. * 1024.)" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4096 * (1024. * 1024.)</e></m></meta>
		</MAX_MEMORY>
		<MAX_BUFFERS get="inline" set="null" expr="1 &lt;&lt; 16" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[1 << 16]]></e></m></meta>
		</MAX_BUFFERS>
		<SIZE get="inline" set="null" expr="65533" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65533</e></m></meta>
		</SIZE>
		<ALL_FLAGS expr="Type.allEnums(Buffer.BufferFlag)" line="8" static="1">
			<c path="Array"><e path="h3d.BufferFlag"/></c>
			<meta><m n=":value"><e>Type.allEnums(Buffer.BufferFlag)</e></m></meta>
		</ALL_FLAGS>
		<driver>
			<c path="h3d.impl.Driver"/>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</driver>
		<buffers><c path="Array"><c path="h3d.impl.ManagedBuffer"/></c></buffers>
		<indexes><c path="Array"><c path="h3d.Indexes"/></c></indexes>
		<textures><c path="Array"><c path="h3d.mat.Texture"/></c></textures>
		<depths><c path="Array"><c path="h3d.mat.DepthBuffer"/></c></depths>
		<triIndexes public="1" set="null"><c path="h3d.Indexes"/></triIndexes>
		<quadIndexes public="1" set="null"><c path="h3d.Indexes"/></quadIndexes>
		<usedMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</usedMemory>
		<texMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texMemory>
		<bufferCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufferCount>
		<init public="1" set="method" line="27"><f a=""><x path="Void"/></f></init>
		<initIndexes set="method" line="35"><f a=""><x path="Void"/></f></initIndexes>
		<garbage public="1" set="dynamic" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call user-defined garbage function that will cleanup some unused allocated objects.
		Might be called several times if we need to allocate a lot of memory</haxe_doc>
		</garbage>
		<cleanManagedBuffers public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clean empty (unused) buffers</haxe_doc>
		</cleanManagedBuffers>
		<allocManaged set="method" line="85">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</allocManaged>
		<freeManaged set="method" line="110">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</freeManaged>
		<allocBuffer set="method" line="131">
			<f a="b:stride">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":allow"><e>h3d.Buffer</e></m>
				<m n=":access"><e>h3d.Buffer</e></m>
			</meta>
		</allocBuffer>
		<deleteIndexes set="method" line="211">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</deleteIndexes>
		<allocIndexes set="method" line="219">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</allocIndexes>
		<bpp set="method" line="228"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></bpp>
		<cleanTextures public="1" set="method" line="232">
			<f a="?force" v="true">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</cleanTextures>
		<sortByLRU set="method" line="244"><f a="t1:t2">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></sortByLRU>
		<deleteTexture set="method" line="249">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.dispose</e></m></meta>
		</deleteTexture>
		<allocTexture set="method" line="256">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.alloc</e></m></meta>
		</allocTexture>
		<allocDepth set="method" line="270">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.alloc</e></m></meta>
		</allocDepth>
		<deleteDepth set="method" line="284">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.dispose</e></m></meta>
		</deleteDepth>
		<onContextLost public="1" set="method" line="292"><f a=""><x path="Void"/></f></onContextLost>
		<dispose public="1" set="method" line="297"><f a=""><x path="Void"/></f></dispose>
		<freeMemorySize set="method" line="325"><f a=""><x path="Int"/></f></freeMemorySize>
		<stats public="1" set="method" line="341"><f a=""><a>
	<totalMemory><x path="Float"/></totalMemory>
	<textureMemory><x path="Float"/></textureMemory>
	<textureCount><x path="Int"/></textureCount>
	<managedMemory><x path="Int"/></managedMemory>
	<freeManagedMemory><x path="Int"/></freeManagedMemory>
	<bufferCount><x path="Int"/></bufferCount>
</a></f></stats>
		<allocStats public="1" set="method" line="370">
			<f a=""><c path="Array"><a>
	<tex><x path="Bool"/></tex>
	<stacks><c path="Array"><a>
	<stack><c path="String"/></stack>
	<size><x path="Int"/></size>
	<count><x path="Int"/></count>
</a></c></stacks>
	<size><x path="Int"/></size>
	<position><c path="String"/></position>
	<count><x path="Int"/></count>
</a></c></f>
			<meta><m n=":access"><e>h3d.Buffer</e></m></meta>
			<haxe_doc>* Return statistics for currently allocated buffers and textures. Requires -D track-alloc compilation flag</haxe_doc>
		</allocStats>
		<new public="1" set="method" line="23"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.NullDriver" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/NullDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<cur><c path="hxsl.RuntimeShader"/></cur>
		<hasFeature public="1" set="method" line="11" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="15" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<logImpl set="method" line="19" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<isDisposed public="1" set="method" line="27" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<getDriverName public="1" set="method" line="31" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="35" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<selectShader public="1" set="method" line="39" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getShaderInputNames public="1" set="method" line="45" override="1"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<allocTexture public="1" set="method" line="53" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="57" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="61" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.impl.Step" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/RendererFX.hx" module="h3d.impl.RendererFX">
		<BeforeLighting/>
		<BeforeTonemappingFX/>
		<BeforeTonemapping/>
		<AfterTonemapping/>
		<AfterUI/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.impl.RendererFX" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/RendererFX.hx" interface="1">
		<enabled public="1"><x path="Bool"/></enabled>
		<apply public="1" set="method"><f a="r:step">
	<c path="h3d.scene.Renderer"/>
	<e path="h3d.impl.Step"/>
	<x path="Void"/>
</f></apply>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="h3d.impl.TextureCache" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/impl/TextureCache.hx">
		<cache><c path="Array"><c path="h3d.mat.Texture"/></c></cache>
		<position expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<defaultDepthBuffer><c path="h3d.mat.DepthBuffer"/></defaultDepthBuffer>
		<ctx><c path="h3d.impl.RenderContext"/></ctx>
		<defaultFormat public="1"><e path="hxd.PixelFormat"/></defaultFormat>
		<get public="1" get="inline" set="null" line="19">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</get>
		<getNamed public="1" set="method" line="23"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></getNamed>
		<set public="1" set="method" line="30"><f a="t:index">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<begin public="1" set="method" line="34"><f a=""><x path="Void"/></f></begin>
		<lookupTarget set="method" line="43"><f a="name:width:height:format:isCube">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
	<c path="h3d.mat.Texture"/>
</f></lookupTarget>
		<allocTarget public="1" set="method" line="70">
			<f a="name:width:height:?defaultDepth:?format:?isCube" v=":::true::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<x path="Bool"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ isCube : false, defaultDepth : true }</e></m></meta>
		</allocTarget>
		<allocTargetScale public="1" set="method" line="81">
			<f a="name:scale:?defaultDepth:?format" v="::true:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : true }</e></m></meta>
		</allocTargetScale>
		<allocTileTarget public="1" set="method" line="86">
			<f a="name:tile:?defaultDepth:?format" v="::false:">
				<c path="String"/>
				<c path="h2d.Tile"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : false }</e></m></meta>
		</allocTileTarget>
		<dispose public="1" set="method" line="90"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="11"><f a="ctx">
	<c path="h3d.impl.RenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl.AnyProps" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/AnyProps.hx">
		<props public="1" set="accessor"><x path="Any"/></props>
		<set_props set="method" line="7"><f a="p">
	<x path="Any"/>
	<x path="Any"/>
</f></set_props>
		<setDefaultProps public="1" set="method" line="13"><f a="kind">
	<c path="String"/>
	<x path="Void"/>
</f></setDefaultProps>
		<getDefaultProps public="1" set="method" line="17"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="21"><f a=""><x path="Void"/></f></refreshProps>
	</class>
	<class path="h3d.mat.BaseMaterial" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/BaseMaterial.hx">
		<extends path="hxd.impl.AnyProps"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<passes>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</passes>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<mainPass public="1" get="accessor" set="null"><c path="h3d.mat.Pass"/></mainPass>
		<addPass public="1" params="T" set="method" line="16"><f a="p">
	<c path="addPass.T"/>
	<c path="addPass.T"/>
</f></addPass>
		<removePass public="1" set="method" line="30"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Bool"/>
</f></removePass>
		<get_mainPass get="inline" set="null" line="47"><f a=""><c path="h3d.mat.Pass"/></f></get_mainPass>
		<getPasses public="1" set="method" line="51"><f a=""><c path="Array"><c path="h3d.mat.Pass"/></c></f></getPasses>
		<getPass public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Pass"/>
</f></getPass>
		<allocPass public="1" set="method" line="71">
			<f a="name:?inheritMain" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Pass"/>
			</f>
			<meta><m n=":value"><e>{ inheritMain : true }</e></m></meta>
		</allocPass>
		<clone public="1" set="method" line="80"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<new set="method" line="11"><f a="?shader">
	<c path="hxsl.Shader"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="h3d.mat.BlendMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/BlendMode.hx"><e path="h2d.BlendMode"/></typedef>
	<enum path="h3d.mat.Face" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Back/>
		<Front/>
		<Both/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Blend" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<One/>
		<Zero/>
		<SrcAlpha/>
		<SrcColor/>
		<DstAlpha/>
		<DstColor/>
		<OneMinusSrcAlpha/>
		<OneMinusSrcColor/>
		<OneMinusDstAlpha/>
		<OneMinusDstColor/>
		<ConstantColor/>
		<ConstantAlpha/>
		<OneMinusConstantColor/>
		<OneMinusConstantAlpha/>
		<SrcAlphaSaturate/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Compare" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Always/>
		<Never/>
		<Equal/>
		<NotEqual/>
		<Greater/>
		<GreaterEqual/>
		<Less/>
		<LessEqual/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.StencilOp" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Keep/>
		<Zero/>
		<Replace/>
		<Increment/>
		<IncrementWrap/>
		<Decrement/>
		<DecrementWrap/>
		<Invert/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.MipMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Filter" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Wrap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Clamp/>
		<Repeat/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Operation" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Add/>
		<Sub/>
		<ReverseSub/>
		<Min/>
		<Max/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.TextureFlags" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Target><haxe_doc>Allocate a texture that will be used as render target.</haxe_doc></Target>
		<Cube><haxe_doc>Allocate a cube texture. Might be restricted to power of two textures only.</haxe_doc></Cube>
		<MipMapped><haxe_doc>Activates Mip Mapping for this texture. Might not be available for target textures.</haxe_doc></MipMapped>
		<ManualMipMapGen><haxe_doc>By default, textures created with MipMapped will have their mipmaps generated when you upload the mipmap level 0. This flag disables this and manually upload mipmaps instead.</haxe_doc></ManualMipMapGen>
		<IsNPOT><haxe_doc>This is a not power of two texture. Automatically set when having width or height being not power of two.</haxe_doc></IsNPOT>
		<NoAlloc><haxe_doc>Don't initialy allocate the texture memory.</haxe_doc></NoAlloc>
		<Dynamic><haxe_doc>Inform that we will often perform upload operations on this texture</haxe_doc></Dynamic>
		<AlphaPremultiplied><haxe_doc>Assumes that the color value of the texture is premultiplied by the alpha component.</haxe_doc></AlphaPremultiplied>
		<WasCleared><haxe_doc>Tells if the target texture has been cleared (reserved for internal engine usage).</haxe_doc></WasCleared>
		<Loading><haxe_doc>The texture is being currently loaded. Set onLoaded to get event when loading is complete.</haxe_doc></Loading>
		<Serialize><haxe_doc>Allow texture data serialization when found in a scene (for user generated textures)</haxe_doc></Serialize>
		<IsArray><haxe_doc>Tells if it's a texture array</haxe_doc></IsArray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="h3d.mat.TextureFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data"><e path="hxd.PixelFormat"/></typedef>
	<class path="h3d.mat.Defaults" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Defaults.hx">
		<defaultKillAlphaThreshold public="1" expr="0.5" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</defaultKillAlphaThreshold>
		<loadingTextureColor public="1" expr="0xFFFF00FF" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</loadingTextureColor>
		<shadowShader public="1" get="accessor" set="accessor" static="1">
			<c path="hxsl.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shadowShader>
		<get_shadowShader set="method" line="11" static="1"><f a=""><c path="hxsl.Shader"/></f></get_shadowShader>
		<set_shadowShader set="method" line="20" static="1"><f a="s">
	<c path="hxsl.Shader"/>
	<c path="hxsl.Shader"/>
</f></set_shadowShader>
		<makeVolumeDecal public="1" set="dynamic" line="24" static="1"><f a="bounds">
	<c path="h3d.col.Bounds"/>
	<c path="hxsl.Shader"/>
</f></makeVolumeDecal>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.mat.DepthFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/DepthBuffer.hx" module="h3d.mat.DepthBuffer">
		<Depth16/>
		<Depth24/>
		<Depth24Stencil8/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.mat.DepthBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/DepthBuffer.hx">
		<getDefault public="1" set="method" line="55" static="1">
			<f a=""><c path="h3d.mat.DepthBuffer"/></f>
			<haxe_doc>This will return the default depth buffer, which is automatically resized to the screen size.</haxe_doc>
		</getDefault>
		<b>
			<t path="h3d.impl.DepthBuffer"/>
			<meta><m n=":allow"><e>h3d.impl.MemoryManager</e></m></meta>
		</b>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<format public="1" set="null"><e path="h3d.mat.DepthFormat"/></format>
		<hasStencil public="1" set="method" line="30"><f a=""><x path="Bool"/></f></hasStencil>
		<alloc set="method" line="37"><f a=""><x path="Void"/></f></alloc>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" set="method" line="48"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="23">
			<f a="width:height:?format">
				<x path="Int"/>
				<x path="Int"/>
				<e path="h3d.mat.DepthFormat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new depth buffer, it can be attached to one or several render target Texture by setting their `depthBuffer` property.</haxe_doc>
		</new>
		<haxe_doc>Depth buffer are used to store per pixel depth information when rendering a scene (also called Z-buffer)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.mat._Material.DefaultKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1" final="1">
	<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Opaque"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Opaque>
	<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Alpha"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "AlphaKill"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AlphaKill>
	<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Add"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Add>
	<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "SoftAdd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SoftAdd>
	<Hidden public="1" get="inline" set="null" expr="cast &quot;Hidden&quot;" line="9" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Hidden"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Hidden>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1" final="1">
		<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Opaque"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Opaque>
		<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Alpha"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "AlphaKill"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AlphaKill>
		<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Add"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Add>
		<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "SoftAdd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SoftAdd>
		<Hidden public="1" get="inline" set="null" expr="cast &quot;Hidden&quot;" line="9" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Hidden"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Hidden>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.mat._Material.DefaultProps" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material"><a>
	<shadows><x path="Bool"/></shadows>
	<light><x path="Bool"/></light>
	<kind><x path="h3d.mat._Material.DefaultKind"/></kind>
	<culling><x path="Bool"/></culling>
</a></typedef>
	<class path="h3d.mat.Material" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Material.hx">
		<extends path="h3d.mat.BaseMaterial"/>
		<create public="1" set="method" line="339" static="1"><f a="?tex">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Material"/>
</f></create>
		<mshader><c path="h3d.shader.BaseMesh"/></mshader>
		<normalShader><c path="h3d.shader.NormalMap"/></normalShader>
		<model public="1"><c path="hxd.res.Resource"/></model>
		<shadows public="1" get="accessor" set="accessor"><x path="Bool"/></shadows>
		<castShadows public="1" set="accessor"><x path="Bool"/></castShadows>
		<receiveShadows public="1" set="accessor"><x path="Bool"/></receiveShadows>
		<staticShadows public="1" set="accessor"><x path="Bool"/></staticShadows>
		<textureShader public="1" set="null"><c path="h3d.shader.Texture"/></textureShader>
		<specularShader public="1" set="null"><c path="h3d.shader.SpecularTexture"/></specularShader>
		<texture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></texture>
		<specularTexture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></specularTexture>
		<normalMap public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></normalMap>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<blendMode public="1" set="accessor"><t path="h3d.mat.BlendMode"/></blendMode>
		<get_specularPower get="inline" set="null" line="49"><f a=""><x path="Float"/></f></get_specularPower>
		<set_specularPower get="inline" set="null" line="53"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularPower>
		<get_specularAmount get="inline" set="null" line="57"><f a=""><x path="Float"/></f></get_specularAmount>
		<set_specularAmount get="inline" set="null" line="61"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularAmount>
		<get_color get="inline" set="null" line="65"><f a=""><t path="hxsl.Vec"/></f></get_color>
		<set_color get="inline" set="null" line="69"><f a="v">
	<t path="hxsl.Vec"/>
	<t path="hxsl.Vec"/>
</f></set_color>
		<get_shadows get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_shadows>
		<set_shadows get="inline" set="null" line="77"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shadows>
		<set_castShadows set="method" line="83"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_castShadows>
		<set_receiveShadows set="method" line="95"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_receiveShadows>
		<set_staticShadows set="method" line="108"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_staticShadows>
		<clone public="1" set="method" line="114" override="1"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<set_blendMode set="method" line="132"><f a="v">
	<t path="h3d.mat.BlendMode"/>
	<t path="h3d.mat.BlendMode"/>
</f></set_blendMode>
		<get_specularTexture set="method" line="150"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_specularTexture>
		<get_texture set="method" line="154"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_texture>
		<set_texture set="method" line="158"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_texture>
		<get_normalMap set="method" line="174"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_normalMap>
		<set_normalMap set="method" line="178"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_normalMap>
		<set_specularTexture set="method" line="197"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_specularTexture>
		<getDefaultModelProps public="1" set="method" line="219"><f a=""><x path="Any"/></f></getDefaultModelProps>
		<getDefaultProps public="1" set="method" line="237" override="1"><f a="?type">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="265" override="1"><f a=""><x path="Void"/></f></refreshProps>
		<new set="method" line="42"><f a="?texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialDatabase" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/MaterialDatabase.hx">
		<db expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a><v><d/></v></a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</db>
		<getFilePath set="method" line="10"><f a="model">
	<c path="hxd.res.Resource"/>
	<c path="String"/>
</f></getFilePath>
		<getModelData public="1" set="method" line="14"><f a="model">
	<c path="hxd.res.Resource"/>
	<a/>
</f></getModelData>
		<saveData set="method" line="26"><f a="model:data">
	<c path="hxd.res.Resource"/>
	<d/>
	<x path="Void"/>
</f></saveData>
		<loadMatProps public="1" set="method" line="41"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Any"/>
</f></loadMatProps>
		<saveMatProps public="1" set="method" line="51"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Void"/>
</f></saveMatProps>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialSetup" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/MaterialSetup.hx">
		<current public="1" expr="new MaterialSetup(&quot;Default&quot;)" line="47" static="1">
			<c path="h3d.mat.MaterialSetup"/>
			<meta><m n=":value"><e>new MaterialSetup("Default")</e></m></meta>
		</current>
		<name public="1" set="null"><c path="String"/></name>
		<database><c path="h3d.mat.MaterialDatabase"/></database>
		<emptyMat><c path="h3d.mat.Material"/></emptyMat>
		<createRenderer public="1" set="method" line="15"><f a=""><c path="h3d.scene.Renderer"/></f></createRenderer>
		<createLightSystem public="1" set="method" line="19"><f a=""><c path="h3d.scene.LightSystem"/></f></createLightSystem>
		<createMaterial public="1" set="method" line="23"><f a=""><c path="h3d.mat.Material"/></f></createMaterial>
		<getDefaults public="1" set="method" line="27"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaults>
		<loadMaterialProps public="1" set="method" line="32"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Any"/>
</f></loadMaterialProps>
		<saveMaterialProps public="1" set="method" line="36"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Void"/>
</f></saveMaterialProps>
		<customMeshInit public="1" set="method" line="44"><f a="mesh">
	<c path="h3d.scene.Mesh"/>
	<x path="Void"/>
</f></customMeshInit>
		<new public="1" set="method" line="9"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.Pass" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Pass.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getEnableLights public="1" get="inline" set="null" line="19" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getEnableLights>
		<enableLights_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</enableLights_bits>
		<enableLights_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</enableLights_offset>
		<enableLights_mask public="1" get="inline" set="null" expr="1" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</enableLights_mask>
		<getDynamicParameters public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDynamicParameters>
		<dynamicParameters_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</dynamicParameters_bits>
		<dynamicParameters_offset public="1" get="inline" set="null" expr="1" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</dynamicParameters_offset>
		<dynamicParameters_mask public="1" get="inline" set="null" expr="2" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</dynamicParameters_mask>
		<getIsStatic public="1" get="inline" set="null" line="30" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getIsStatic>
		<isStatic_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</isStatic_bits>
		<isStatic_offset public="1" get="inline" set="null" expr="2" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</isStatic_offset>
		<isStatic_mask public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</isStatic_mask>
		<getBatchMode public="1" get="inline" set="null" line="32" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBatchMode>
		<batchMode_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</batchMode_bits>
		<batchMode_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</batchMode_offset>
		<batchMode_mask public="1" get="inline" set="null" expr="8" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</batchMode_mask>
		<getCulling public="1" get="inline" set="null" line="34" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getCulling>
		<culling_bits public="1" get="inline" set="null" expr="2" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</culling_bits>
		<culling_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</culling_offset>
		<culling_mask public="1" get="inline" set="null" expr="3" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</culling_mask>
		<getDepthWrite public="1" get="inline" set="null" line="35" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthWrite>
		<depthWrite_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</depthWrite_bits>
		<depthWrite_offset public="1" get="inline" set="null" expr="2" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</depthWrite_offset>
		<depthWrite_mask public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</depthWrite_mask>
		<getDepthTest public="1" get="inline" set="null" line="36" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthTest>
		<depthTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_bits>
		<depthTest_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_offset>
		<depthTest_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</depthTest_mask>
		<getBlendSrc public="1" get="inline" set="null" line="37" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendSrc>
		<blendSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendSrc_bits>
		<blendSrc_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</blendSrc_offset>
		<blendSrc_mask public="1" get="inline" set="null" expr="960" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>960</e></m></meta>
		</blendSrc_mask>
		<getBlendDst public="1" get="inline" set="null" line="38" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendDst>
		<blendDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendDst_bits>
		<blendDst_offset public="1" get="inline" set="null" expr="10" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</blendDst_offset>
		<blendDst_mask public="1" get="inline" set="null" expr="15360" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15360</e></m></meta>
		</blendDst_mask>
		<getBlendAlphaSrc public="1" get="inline" set="null" line="39" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaSrc>
		<blendAlphaSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaSrc_bits>
		<blendAlphaSrc_offset public="1" get="inline" set="null" expr="14" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</blendAlphaSrc_offset>
		<blendAlphaSrc_mask public="1" get="inline" set="null" expr="245760" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>245760</e></m></meta>
		</blendAlphaSrc_mask>
		<getBlendAlphaDst public="1" get="inline" set="null" line="40" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaDst>
		<blendAlphaDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaDst_bits>
		<blendAlphaDst_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</blendAlphaDst_offset>
		<blendAlphaDst_mask public="1" get="inline" set="null" expr="3932160" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3932160</e></m></meta>
		</blendAlphaDst_mask>
		<getBlendOp public="1" get="inline" set="null" line="41" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendOp>
		<blendOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendOp_bits>
		<blendOp_offset public="1" get="inline" set="null" expr="22" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</blendOp_offset>
		<blendOp_mask public="1" get="inline" set="null" expr="29360128" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29360128</e></m></meta>
		</blendOp_mask>
		<getBlendAlphaOp public="1" get="inline" set="null" line="42" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaOp>
		<blendAlphaOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendAlphaOp_bits>
		<blendAlphaOp_offset public="1" get="inline" set="null" expr="25" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</blendAlphaOp_offset>
		<blendAlphaOp_mask public="1" get="inline" set="null" expr="234881024" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>234881024</e></m></meta>
		</blendAlphaOp_mask>
		<getWireframe public="1" get="inline" set="null" line="43" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWireframe>
		<wireframe_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</wireframe_bits>
		<wireframe_offset public="1" get="inline" set="null" expr="28" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</wireframe_offset>
		<wireframe_mask public="1" get="inline" set="null" expr="268435456" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>268435456</e></m></meta>
		</wireframe_mask>
		<getReserved public="1" get="inline" set="null" line="50" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReserved>
		<reserved_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</reserved_bits>
		<reserved_offset public="1" get="inline" set="null" expr="29" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</reserved_offset>
		<reserved_mask public="1" get="inline" set="null" expr="536870912" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>536870912</e></m></meta>
		</reserved_mask>
		<name public="1" set="null">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<flags><x path="Int"/></flags>
		<passId><x path="Int"/></passId>
		<bits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</bits>
		<parentPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</parentPass>
		<parentShaders><c path="hxsl.ShaderList"/></parentShaders>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<nextPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</nextPass>
		<enableLights public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
		</enableLights>
		<dynamicParameters public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
			<haxe_doc>Inform the pass system that the parameters will be modified in object draw() command,
		so they will be manually uploaded by calling RenderContext.uploadParams.</haxe_doc>
		</dynamicParameters>
		<isStatic public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
			<haxe_doc>Mark the pass as static, this will allow some renderers or shadows to filter it
		when rendering static/dynamic parts.</haxe_doc>
		</isStatic>
		<batchMode set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
		</batchMode>
		<culling public="1" set="accessor">
			<e path="h3d.mat.Face"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</culling>
		<depthWrite public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthWrite>
		<depthTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthTest>
		<blendSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendSrc>
		<blendDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendDst>
		<blendAlphaSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaSrc>
		<blendAlphaDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaDst>
		<blendOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendOp>
		<blendAlphaOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaOp>
		<wireframe public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</wireframe>
		<colorMask public="1"><x path="Int"/></colorMask>
		<layer public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</layer>
		<stencil public="1">
			<c path="h3d.mat.Stencil"/>
			<meta><m n=":s"/></meta>
		</stencil>
		<reserved set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":bits"><e>bits</e></m>
				<m n=":noCompletion"/>
			</meta>
		</reserved>
		<load public="1" set="method" line="63"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></load>
		<setPassName public="1" set="method" line="85"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></setPassName>
		<blend public="1" get="inline" set="null" line="90"><f a="src:dst">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
	<x path="Void"/>
</f></blend>
		<setBlendMode public="1" set="method" line="97"><f a="b">
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></setBlendMode>
		<depth public="1" set="method" line="163"><f a="write:test">
	<x path="Bool"/>
	<e path="h3d.mat.Compare"/>
	<x path="Void"/>
</f></depth>
		<setColorMask public="1" set="method" line="168"><f a="r:g:b:a">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setColorChannel public="1" set="method" line="172"><f a="c">
	<e path="hxsl.Channel"/>
	<x path="Void"/>
</f></setColorChannel>
		<addShader public="1" params="T" set="method" line="182"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<addShaderAtIndex params="T" set="method" line="192">
			<f a="s:index">
				<c path="addShaderAtIndex.T"/>
				<x path="Int"/>
				<c path="addShaderAtIndex.T"/>
			</f>
			<haxe_doc>Can be used for internal usage</haxe_doc>
		</addShaderAtIndex>
		<getShaderIndex set="method" line="207"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Int"/>
</f></getShaderIndex>
		<removeShader public="1" set="method" line="218"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="234"><f a="t">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<getShaderByName public="1" set="method" line="245"><f a="name">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</f></getShaderByName>
		<getShaders public="1" get="inline" set="null" line="255"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></getShaders>
		<getShadersRec set="method" line="259"><f a=""><c path="hxsl.ShaderList"/></f></getShadersRec>
		<clone public="1" set="method" line="276"><f a=""><c path="h3d.mat.Pass"/></f></clone>
		<getDebugShaderCode public="1" set="method" line="285">
			<f a="scene:?toHxsl" v=":true">
				<c path="h3d.scene.Scene"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
		</getDebugShaderCode>
		<set_enableLights set="method" line="19"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableLights>
		<set_dynamicParameters set="method" line="24"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dynamicParameters>
		<set_isStatic set="method" line="30"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isStatic>
		<set_batchMode set="method" line="32"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_batchMode>
		<set_culling set="method" line="34"><f a="v">
	<e path="h3d.mat.Face"/>
	<e path="h3d.mat.Face"/>
</f></set_culling>
		<set_depthWrite set="method" line="35"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_depthWrite>
		<set_depthTest set="method" line="36"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_depthTest>
		<set_blendSrc set="method" line="37"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendSrc>
		<set_blendDst set="method" line="38"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendDst>
		<set_blendAlphaSrc set="method" line="39"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaSrc>
		<set_blendAlphaDst set="method" line="40"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaDst>
		<set_blendOp set="method" line="41"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendOp>
		<set_blendAlphaOp set="method" line="42"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendAlphaOp>
		<set_wireframe set="method" line="43"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wireframe>
		<set_reserved set="method" line="50"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_reserved>
		<loadFlags set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadFlags>
		<loadBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadBits>
		<new public="1" set="method" line="52"><f a="name:?shaders:?parent">
	<c path="String"/>
	<c path="hxsl.ShaderList"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.BaseMaterial</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<class path="h3d.mat.Stencil" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Stencil.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getReadMask public="1" get="inline" set="null" line="13" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReadMask>
		<readMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</readMask_bits>
		<readMask_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</readMask_offset>
		<readMask_mask public="1" get="inline" set="null" expr="255" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</readMask_mask>
		<getWriteMask public="1" get="inline" set="null" line="14" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWriteMask>
		<writeMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_bits>
		<writeMask_offset public="1" get="inline" set="null" expr="8" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_offset>
		<writeMask_mask public="1" get="inline" set="null" expr="65280" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65280</e></m></meta>
		</writeMask_mask>
		<getReference public="1" get="inline" set="null" line="15" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReference>
		<reference_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</reference_bits>
		<reference_offset public="1" get="inline" set="null" expr="16" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</reference_offset>
		<reference_mask public="1" get="inline" set="null" expr="16711680" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16711680</e></m></meta>
		</reference_mask>
		<getFrontTest public="1" get="inline" set="null" line="17" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontTest>
		<frontTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontTest_bits>
		<frontTest_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</frontTest_offset>
		<frontTest_mask public="1" get="inline" set="null" expr="7" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</frontTest_mask>
		<getFrontPass public="1" get="inline" set="null" line="18" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontPass>
		<frontPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_bits>
		<frontPass_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_offset>
		<frontPass_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</frontPass_mask>
		<getFrontSTfail public="1" get="inline" set="null" line="19" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontSTfail>
		<frontSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontSTfail_bits>
		<frontSTfail_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</frontSTfail_offset>
		<frontSTfail_mask public="1" get="inline" set="null" expr="448" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>448</e></m></meta>
		</frontSTfail_mask>
		<getFrontDPfail public="1" get="inline" set="null" line="20" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontDPfail>
		<frontDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontDPfail_bits>
		<frontDPfail_offset public="1" get="inline" set="null" expr="9" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</frontDPfail_offset>
		<frontDPfail_mask public="1" get="inline" set="null" expr="3584" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3584</e></m></meta>
		</frontDPfail_mask>
		<getBackTest public="1" get="inline" set="null" line="22" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackTest>
		<backTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backTest_bits>
		<backTest_offset public="1" get="inline" set="null" expr="12" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</backTest_offset>
		<backTest_mask public="1" get="inline" set="null" expr="28672" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28672</e></m></meta>
		</backTest_mask>
		<getBackPass public="1" get="inline" set="null" line="23" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackPass>
		<backPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backPass_bits>
		<backPass_offset public="1" get="inline" set="null" expr="15" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</backPass_offset>
		<backPass_mask public="1" get="inline" set="null" expr="229376" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>229376</e></m></meta>
		</backPass_mask>
		<getBackSTfail public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackSTfail>
		<backSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backSTfail_bits>
		<backSTfail_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</backSTfail_offset>
		<backSTfail_mask public="1" get="inline" set="null" expr="1835008" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1835008</e></m></meta>
		</backSTfail_mask>
		<getBackDPfail public="1" get="inline" set="null" line="25" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackDPfail>
		<backDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backDPfail_bits>
		<backDPfail_offset public="1" get="inline" set="null" expr="21" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</backDPfail_offset>
		<backDPfail_mask public="1" get="inline" set="null" expr="14680064" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14680064</e></m></meta>
		</backDPfail_mask>
		<maskBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</maskBits>
		<opBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</opBits>
		<readMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</readMask>
		<writeMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</writeMask>
		<reference public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</reference>
		<frontTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontTest>
		<frontPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontPass>
		<frontSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontSTfail>
		<frontDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontDPfail>
		<backTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backTest>
		<backPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backPass>
		<backSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backSTfail>
		<backDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backDPfail>
		<setFront public="1" set="method" line="32"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setFront>
		<setBack public="1" set="method" line="38"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setBack>
		<setOp public="1" set="method" line="44"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setOp>
		<setFunc public="1" set="method" line="49">
			<f a="f:?reference:?readMask:?writeMask" v=":0:0xFF:0xFF">
				<e path="h3d.mat.Compare"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 0xFF, readMask : 0xFF, reference : 0 }</e></m></meta>
		</setFunc>
		<clone public="1" set="method" line="56"><f a=""><c path="h3d.mat.Stencil"/></f></clone>
		<load public="1" set="method" line="63"><f a="s">
	<c path="h3d.mat.Stencil"/>
	<x path="Void"/>
</f></load>
		<set_readMask set="method" line="13"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_readMask>
		<set_writeMask set="method" line="14"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_writeMask>
		<set_reference set="method" line="15"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_reference>
		<set_frontTest set="method" line="17"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_frontTest>
		<set_frontPass set="method" line="18"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontPass>
		<set_frontSTfail set="method" line="19"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontSTfail>
		<set_frontDPfail set="method" line="20"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontDPfail>
		<set_backTest set="method" line="22"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_backTest>
		<set_backPass set="method" line="23"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backPass>
		<set_backSTfail set="method" line="24"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backSTfail>
		<set_backDPfail set="method" line="25"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backDPfail>
		<loadOpBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadOpBits>
		<loadMaskBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadMaskBits>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.Material</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<enum path="hxd.PixelFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/PixelFormat.hx">
		<ARGB/>
		<BGRA/>
		<RGBA/>
		<RGBA16F/>
		<RGBA32F/>
		<R8/>
		<R16F/>
		<R32F/>
		<RG8/>
		<RG16F/>
		<RG32F/>
		<RGB8/>
		<RGB16F/>
		<RGB32F/>
		<SRGB/>
		<SRGB_ALPHA/>
		<RGB10A2/>
		<RG11B10UF/>
		<S3TC a="v"><x path="Int"/></S3TC>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="h3d.mat.Texture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/Texture.hx">
		<UID expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<PREVENT_AUTO_DISPOSE final="1" set="null" expr="0x7FFFFFFF" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x7FFFFFFF</e></m></meta>
		</PREVENT_AUTO_DISPOSE>
		<nativeFormat public="1" set="null" expr="RGBA" line="19" static="1">
			<t path="h3d.mat.TextureFormat"/>
			<meta><m n=":value"><e>RGBA</e></m></meta>
			<haxe_doc>The default texture color format</haxe_doc>
		</nativeFormat>
		<fromBitmap public="1" set="method" line="398" static="1"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<c path="h3d.mat.Texture"/>
</f></fromBitmap>
		<fromPixels public="1" set="method" line="404" static="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<c path="h3d.mat.Texture"/>
</f></fromPixels>
		<fromColor public="1" set="method" line="413" static="1">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Null"><c path="h3d.mat.Texture"/></x>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
			<haxe_doc>Creates a 1x1 texture using the RGB color passed as parameter.</haxe_doc>
		</fromColor>
		<genDisc public="1" set="method" line="430" static="1">
			<f a="size:color:?alpha" v="::1.">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</genDisc>
		<genTexture set="method" line="434" static="1"><f a="mode:size:color:alpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="h3d.mat.Texture"/>
</f></genTexture>
		<drawGenTexture set="method" line="455" static="1"><f a="t:color:mode">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawGenTexture>
		<defaultCubeTexture public="1" set="method" line="470" static="1">
			<f a=""><c path="h3d.mat.Texture"/></f>
			<haxe_doc>Returns a default dummy 1x1 black cube texture</haxe_doc>
		</defaultCubeTexture>
		<genChecker public="1" set="method" line="485" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<haxe_doc>Returns a checker texture of size x size, than can be repeated</haxe_doc>
		</genChecker>
		<checkerTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="501" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</checkerTextureKeys>
		<noiseTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="502" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</noiseTextureKeys>
		<genTextureKeys expr="new Map&lt;String,{ }&gt;()" line="503" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ }>()]]></e></m></meta>
		</genTextureKeys>
		<genNoise public="1" set="method" line="505" static="1"><f a="size">
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
</f></genNoise>
		<allocNoise set="method" line="521" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocNoise>
		<allocChecker set="method" line="532" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocChecker>
		<t><t path="h3d.impl.Texture"/></t>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" set="null"><c path="String"/></name>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.mat.TextureFlags"/></x></flags>
		<format public="1" set="null"><t path="h3d.mat.TextureFormat"/></format>
		<lastFrame get="accessor" set="accessor"><x path="Int"/></lastFrame>
		<bits><x path="Int"/></bits>
		<waitLoads><c path="Array"><f a=""><x path="Void"/></f></c></waitLoads>
		<mipMap public="1" set="accessor"><e path="h3d.mat.MipMap"/></mipMap>
		<filter public="1" set="accessor"><e path="h3d.mat.Filter"/></filter>
		<wrap public="1" set="accessor"><e path="h3d.mat.Wrap"/></wrap>
		<layerCount public="1" get="accessor" set="null"><x path="Int"/></layerCount>
		<realloc public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If this callback is set, the texture can be re-allocated when the 3D context has been lost or when
		it's been free because of lack of memory.</haxe_doc>
		</realloc>
		<depthBuffer public="1">
			<c path="h3d.mat.DepthBuffer"/>
			<haxe_doc>When the texture is used as render target, tells which depth buffer will be used.
		If set to null, depth testing is disabled.</haxe_doc>
		</depthBuffer>
		<_lastFrame><x path="Int"/></_lastFrame>
		<set_lastFrame set="method" line="56"><f a="lf">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lastFrame>
		<get_lastFrame set="method" line="64"><f a=""><x path="Int"/></f></get_lastFrame>
		<get_layerCount set="method" line="104"><f a=""><x path="Int"/></f></get_layerCount>
		<alloc public="1" set="method" line="108"><f a=""><x path="Void"/></f></alloc>
		<isSRGB public="1" set="method" line="113"><f a=""><x path="Bool"/></f></isSRGB>
		<checkAlloc set="method" line="117"><f a=""><x path="Void"/></f></checkAlloc>
		<clone public="1" set="method" line="124"><f a=""><c path="h3d.mat.Texture"/></f></clone>
		<preventAutoDispose public="1" set="method" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>In case of out of GPU memory, textures that hasn't been used for a long time will be disposed.
		Calling this will make this texture not considered for auto disposal.</haxe_doc>
		</preventAutoDispose>
		<waitLoad public="1" set="method" line="158">
			<f a="f">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some textures might take some time to load. You can check flags.has(Loading)
		or add a waitLoad callback which will get called either immediately if the texture is already loaded
		or when loading is complete.</haxe_doc>
		</waitLoad>
		<toString set="method" line="167"><f a=""><c path="String"/></f></toString>
		<setName public="1" set="method" line="178"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></setName>
		<set_mipMap set="method" line="182"><f a="m">
	<e path="h3d.mat.MipMap"/>
	<e path="h3d.mat.MipMap"/>
</f></set_mipMap>
		<set_filter set="method" line="187"><f a="f">
	<e path="h3d.mat.Filter"/>
	<e path="h3d.mat.Filter"/>
</f></set_filter>
		<set_wrap set="method" line="192"><f a="w">
	<e path="h3d.mat.Wrap"/>
	<e path="h3d.mat.Wrap"/>
</f></set_wrap>
		<isDisposed public="1" get="inline" set="null" line="197"><f a=""><x path="Bool"/></f></isDisposed>
		<resize public="1" set="method" line="201"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<clearF public="1" set="method" line="219">
			<f a="?r:?g:?b:?a:?layer" v="0.:0.:0.:0.:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : -1, a : 0., b : 0., g : 0., r : 0. }</e></m></meta>
		</clearF>
		<clear public="1" set="method" line="237">
			<f a="color:?alpha:?layer" v=":1.:-1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : -1, alpha : 1. }</e></m></meta>
		</clear>
		<checkSize get="inline" set="null" line="284"><f a="width:height:mip">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkSize>
		<checkMipMapGen set="method" line="289"><f a="mipLevel:layer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkMipMapGen>
		<uploadBitmap public="1" set="method" line="294">
			<f a="bmp:?mipLevel:?layer" v=":0:0">
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadBitmap>
		<uploadPixels public="1" set="method" line="302">
			<f a="pixels:?mipLevel:?layer" v=":0:0">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadPixels>
		<dispose public="1" set="method" line="310"><f a=""><x path="Void"/></f></dispose>
		<swapTexture public="1" set="method" line="319">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Swap two textures, this is an immediate operation.
		BEWARE : if the texture is a cached image (hxd.res.Image), the swap will affect the cache!</haxe_doc>
		</swapTexture>
		<capturePixels public="1" set="method" line="333">
			<f a="?face:?mipLevel:?region" v="0:0:">
				<x path="Int"/>
				<x path="Int"/>
				<c path="h2d.col.IBounds"/>
				<c path="hxd.Pixels"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, face : 0 }</e></m></meta>
			<haxe_doc>Downloads the current texture data from the GPU.
		Beware, this is a very slow operation that shouldn't be done during rendering.</haxe_doc>
		</capturePixels>
		<new public="1" set="method" line="69"><f a="w:h:?flags:?format">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<x path="Null"><t path="h3d.mat.TextureFormat"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.mat.TextureArray" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/mat/TextureArray.hx">
		<extends path="h3d.mat.Texture"/>
		<layers><x path="Int"/></layers>
		<get_layerCount set="method" line="15" override="1"><f a=""><x path="Int"/></f></get_layerCount>
		<clone public="1" set="method" line="19" override="1"><f a=""><c path="h3d.mat.TextureArray"/></f></clone>
		<toString set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="w:h:layers:?flags:?format">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<x path="Null"><t path="h3d.mat.TextureFormat"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.Base" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Base.hx">
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<name public="1" set="null"><c path="String"/></name>
		<compileShader public="1" set="method" line="12"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<setContext public="1" set="method" line="17"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setContext>
		<dispose public="1" set="method" line="21"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method" line="24"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="8"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.ScreenFx" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/ScreenFx.hx">
		<run public="1" set="method" line="86" static="1"><f a="shader:output:?layer">
	<c path="h3d.shader.ScreenShader"/>
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<shader public="1"><c path="h3d.pass.ScreenFx.T"/></shader>
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<_engine><c path="h3d.Engine"/></_engine>
		<engine get="accessor" set="null"><c path="h3d.Engine"/></engine>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<get_engine set="method" line="23"><f a=""><c path="h3d.Engine"/></f></get_engine>
		<copy set="method" line="28"><f a="src:dst">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></copy>
		<setGlobals public="1" set="method" line="32"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setGlobals>
		<addShader public="1" params="T" set="method" line="37"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<removeShader public="1" set="method" line="42"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="56"><f a="cl">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<render public="1" set="method" line="64"><f a=""><x path="Void"/></f></render>
		<dispose public="1" set="method" line="83"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="shader:?output">
	<c path="h3d.pass.ScreenFx.T"/>
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Blur" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Blur.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.shader.Blur"/></extends>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<radius public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How far in pixels the blur will go.</haxe_doc>
		</radius>
		<gain public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How much the blur increases or decreases the color amount (default = 1)</haxe_doc>
		</gain>
		<linear public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Set linear blur instead of gaussian (default = 0).</haxe_doc>
		</linear>
		<quality public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Adjust how much quality/speed tradeoff we want (default = 1)</haxe_doc>
		</quality>
		<values><c path="Array"><x path="Float"/></c></values>
		<offsets><c path="Array"><x path="Float"/></c></offsets>
		<set_radius set="method" line="44"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<set_quality set="method" line="51"><f a="q">
	<x path="Float"/>
	<x path="Float"/>
</f></set_quality>
		<set_gain set="method" line="58"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<set_linear set="method" line="65"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_linear>
		<gauss set="method" line="72"><f a="x:s">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></gauss>
		<calcValues set="method" line="79"><f a=""><x path="Void"/></f></calcValues>
		<getKernelSize public="1" set="method" line="121"><f a=""><x path="Int"/></f></getKernelSize>
		<apply public="1" set="method" line="126"><f a="ctx:src:?output">
	<c path="h3d.impl.RenderContext"/>
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="36">
			<f a="?radius:?gain:?linear:?quality" v="1.:1.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quality : 1., linear : 0., gain : 1., radius : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n="ignore"><e>"shader"</e></m>
		</meta>
	</class>
	<class path="hxsl.Shader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Shader.hx">
		<priority public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</priority>
		<shader><c path="hxsl.SharedShader"/></shader>
		<instance><c path="hxsl.ShaderInstance"/></instance>
		<constBits><x path="Int"/></constBits>
		<constModified><x path="Bool"/></constModified>
		<initialize set="method" line="17"><f a=""><x path="Void"/></f></initialize>
		<setPriority public="1" set="method" line="40">
			<f a="v">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shader priority should only be changed *before* the shader is added to a material.</haxe_doc>
		</setPriority>
		<getParamValue public="1" set="method" line="44"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="49"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<updateConstants public="1" set="method" line="54"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<updateConstantsFinal set="method" line="58"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstantsFinal>
		<clone public="1" set="method" line="100"><f a=""><c path="hxsl.Shader"/></f></clone>
		<toString public="1" set="method" line="104"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ScreenShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/ScreenShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<flipY public="1" get="accessor" set="accessor"><x path="Float"/></flipY>
		<flipY__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</flipY__>
		<get_flipY get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_flipY>
		<set_flipY get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_flipY>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@input var input:{ var position : Vec2; var uv : Vec2};
	@param var flipY:Float;
	var output:{ var position : Vec4; var color : Vec4};
	var pixelColor:Vec4;
	var calculatedUV:Vec2;
	function __init__() {
		output.color = pixelColor;
		calculatedUV = input.uv;
	};
	function vertex() {
		output.position = vec4(input.position.x, input.position.y * flipY, 0, 1);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass._Border.BorderShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Border.hx" private="1" module="h3d.pass.Border">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA&quot;" line="4" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="4">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="4">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="4" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="4" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var color:Vec4;
	function fragment() {
		pixelColor = color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Border" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Border.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Border.BorderShader"/></extends>
		<dispose public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="17">
			<f a="width:height:?size" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._Copy.ArrayCopyShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Copy.hx" private="1" module="h3d.pass.Copy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA&quot;" line="17" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2DArray"/></texture>
		<texture__>
			<t path="hxsl.Sampler2DArray"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="17">
			<f a=""><t path="hxsl.Sampler2DArray"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="17">
			<f a="_v">
				<t path="hxsl.Sampler2DArray"/>
				<t path="hxsl.Sampler2DArray"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<layer public="1" get="accessor" set="accessor"><x path="Int"/></layer>
		<layer__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</layer__>
		<get_layer get="inline" set="null" line="17">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_layer>
		<set_layer get="inline" set="null" line="17">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_layer>
		<updateConstants public="1" set="method" line="17" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2DArray;
	@param var layer:Int;
	function fragment() {
		pixelColor = texture.get(vec3(calculatedUV, layer));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.ArrayCopy" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Copy.hx" module="h3d.pass.Copy">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Copy.ArrayCopyShader"/></extends>
		<run public="1" set="method" line="58" static="1"><f a="from:fromLayer:to:?blend:?pass:?layer">
	<c path="h3d.mat.TextureArray"/>
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<apply public="1" set="method" line="32"><f a="from:fromLayer:to:?blend:?customPass:?layer">
	<c path="h3d.mat.TextureArray"/>
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h3d.pass._Copy.CopyShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Copy.hx" private="1" module="h3d.pass.Copy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA&quot;" line="73" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="73">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="73">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="73" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="73" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="73" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="73" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="71"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	function fragment() {
		pixelColor = texture.get(calculatedUV);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Copy" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Copy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Copy.CopyShader"/></extends>
		<run public="1" set="method" line="111" static="1"><f a="from:to:?blend:?pass:?layer">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<apply public="1" set="method" line="87"><f a="from:to:?blend:?customPass:?layer">
	<t path="hxsl.Sampler2D"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="83"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._CubeCopy.CubeCopyShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/CubeCopy.hx" private="1" module="h3d.pass.CubeCopy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texture>
		<texture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:SamplerCube;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		pixelColor = texture.get(normalize(vec3(uv, 1) * mat));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.CubeCopy" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/CubeCopy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._CubeCopy.CubeCopyShader"/></extends>
		<run public="1" set="method" line="55" static="1"><f a="from:to:?blend:?pass">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></run>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<apply public="1" set="method" line="28"><f a="from:to:?blend:?customPass">
	<t path="hxsl.SamplerCube"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Default" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Default.hx">
		<extends path="h3d.pass.Base"/>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<globals get="accessor" set="null"><c path="hxsl.Globals"/></globals>
		<defaultSort expr="new SortByMaterial().sort">
			<f a="passes">
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>new SortByMaterial().sort</e></m></meta>
		</defaultSort>
		<get_globals get="inline" set="null" line="11"><f a=""><c path="hxsl.Globals"/></f></get_globals>
		<cameraView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.view"</e></m></meta>
		</cameraView>
		<cameraNear get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zNear"</e></m></meta>
		</cameraNear>
		<cameraFar get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zFar"</e></m></meta>
		</cameraFar>
		<cameraProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.proj"</e></m></meta>
		</cameraProj>
		<cameraPos get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.position"</e></m></meta>
		</cameraPos>
		<cameraProjDiag get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.projDiag"</e></m></meta>
		</cameraProjDiag>
		<cameraProjFlip get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.projFlip"</e></m></meta>
		</cameraProjFlip>
		<cameraViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.viewProj"</e></m></meta>
		</cameraViewProj>
		<cameraInverseViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.inverseViewProj"</e></m></meta>
		</cameraInverseViewProj>
		<globalTime get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"global.time"</e></m></meta>
		</globalTime>
		<pixelSize get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"global.pixelSize"</e></m></meta>
		</pixelSize>
		<globalModelView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelView"</e></m></meta>
		</globalModelView>
		<globalModelViewInverse get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelViewInverse"</e></m></meta>
		</globalModelViewInverse>
		<getOutputs set="method" line="33"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<compileShader public="1" set="method" line="37" override="1"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<processShaders set="method" line="44"><f a="p:shaders">
	<c path="h3d.pass.PassObject"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></processShaders>
		<setupShaders set="method" line="54">
			<f a="passes">
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</setupShaders>
		<log get="inline" set="null" line="78"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<drawObject set="method" line="82"><f a="p">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></drawObject>
		<draw public="1" set="method" line="89" override="1">
			<f a="passes:?sort">
				<c path="h3d.pass.PassList"/>
				<f a="">
					<c path="h3d.pass.PassList"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</draw>
		<cameraView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraView_id>
		<get_cameraView get="inline" set="null" line="13"><f a=""><c path="h3d.Matrix"/></f></get_cameraView>
		<set_cameraView get="inline" set="null" line="13"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraView>
		<cameraNear_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraNear_id>
		<get_cameraNear get="inline" set="null" line="14"><f a=""><x path="Float"/></f></get_cameraNear>
		<set_cameraNear get="inline" set="null" line="14"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraNear>
		<cameraFar_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraFar_id>
		<get_cameraFar get="inline" set="null" line="15"><f a=""><x path="Float"/></f></get_cameraFar>
		<set_cameraFar get="inline" set="null" line="15"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraFar>
		<cameraProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProj_id>
		<get_cameraProj get="inline" set="null" line="16"><f a=""><c path="h3d.Matrix"/></f></get_cameraProj>
		<set_cameraProj get="inline" set="null" line="16"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraProj>
		<cameraPos_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraPos_id>
		<get_cameraPos get="inline" set="null" line="17"><f a=""><c path="h3d.Vector"/></f></get_cameraPos>
		<set_cameraPos get="inline" set="null" line="17"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraPos>
		<cameraProjDiag_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjDiag_id>
		<get_cameraProjDiag get="inline" set="null" line="18"><f a=""><c path="h3d.Vector"/></f></get_cameraProjDiag>
		<set_cameraProjDiag get="inline" set="null" line="18"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraProjDiag>
		<cameraProjFlip_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjFlip_id>
		<get_cameraProjFlip get="inline" set="null" line="19"><f a=""><x path="Float"/></f></get_cameraProjFlip>
		<set_cameraProjFlip get="inline" set="null" line="19"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraProjFlip>
		<cameraViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraViewProj_id>
		<get_cameraViewProj get="inline" set="null" line="20"><f a=""><c path="h3d.Matrix"/></f></get_cameraViewProj>
		<set_cameraViewProj get="inline" set="null" line="20"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraViewProj>
		<cameraInverseViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraInverseViewProj_id>
		<get_cameraInverseViewProj get="inline" set="null" line="21"><f a=""><c path="h3d.Matrix"/></f></get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="21"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraInverseViewProj>
		<globalTime_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalTime_id>
		<get_globalTime get="inline" set="null" line="22"><f a=""><x path="Float"/></f></get_globalTime>
		<set_globalTime get="inline" set="null" line="22"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_globalTime>
		<pixelSize_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</pixelSize_id>
		<get_pixelSize get="inline" set="null" line="23"><f a=""><c path="h3d.Vector"/></f></get_pixelSize>
		<set_pixelSize get="inline" set="null" line="23"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_pixelSize>
		<globalModelView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelView_id>
		<get_globalModelView get="inline" set="null" line="24"><f a=""><c path="h3d.Matrix"/></f></get_globalModelView>
		<set_globalModelView get="inline" set="null" line="24"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelView>
		<globalModelViewInverse_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelViewInverse_id>
		<get_globalModelViewInverse get="inline" set="null" line="25"><f a=""><c path="h3d.Matrix"/></f></get_globalModelViewInverse>
		<set_globalModelViewInverse get="inline" set="null" line="25"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelViewInverse>
		<initGlobals set="method" line="3"><f a=""><x path="Void"/></f></initGlobals>
		<setGlobals set="method" line="3"><f a=""><x path="Void"/></f></setGlobals>
		<new public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>hxsl.Macros.buildGlobals()</e></m>
			<m n=":access"><e>h3d.mat.Pass</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Shadows" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Shadows.hx">
		<extends path="h3d.pass.Default"/>
		<lightCamera><c path="h3d.Camera"/></lightCamera>
		<format><e path="hxd.PixelFormat"/></format>
		<staticTexture><c path="h3d.mat.Texture"/></staticTexture>
		<light><c path="h3d.scene.Light"/></light>
		<enabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<mode public="1" set="accessor" expr="None">
			<e path="h3d.pass.RenderMode"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</mode>
		<size public="1" set="accessor" expr="1024">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</size>
		<shader public="1" set="null"><c path="hxsl.Shader"/></shader>
		<blur public="1"><c path="h3d.pass.Blur"/></blur>
		<samplingKind public="1" expr="None">
			<e path="h3d.pass.ShadowSamplingKind"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</samplingKind>
		<power public="1" expr="30.0">
			<x path="Float"/>
			<meta><m n=":value"><e>30.0</e></m></meta>
		</power>
		<bias public="1" expr="0.01">
			<x path="Float"/>
			<meta><m n=":value"><e>0.01</e></m></meta>
		</bias>
		<pcfQuality public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pcfQuality>
		<pcfScale public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</pcfScale>
		<set_mode set="method" line="44"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_enabled set="method" line="49"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_size set="method" line="53"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="61" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowProj public="1" set="method" line="68"><f a=""><c path="h3d.Matrix"/></f></getShadowProj>
		<getShadowTex public="1" set="method" line="72"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<isUsingWorldDist set="method" line="76"><f a=""><x path="Bool"/></f></isUsingWorldDist>
		<getOutputs set="method" line="80" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<loadStaticData public="1" set="method" line="89"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<saveStaticData public="1" set="method" line="93"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<computeStatic public="1" set="method" line="97"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></computeStatic>
		<createDefaultShadowMap set="method" line="101"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></createDefaultShadowMap>
		<syncShader set="method" line="107"><f a="texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></syncShader>
		<filterPasses set="method" line="110"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Bool"/>
</f></filterPasses>
		<cullPasses get="inline" set="null" line="144"><f a="passes:f">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.col.Collider"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></cullPasses>
		<new public="1" set="method" line="34"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DirShadowMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/DirShadowMap.hx">
		<extends path="h3d.pass.Shadows"/>
		<customDepth><x path="Bool"/></customDepth>
		<depth><c path="h3d.mat.DepthBuffer"/></depth>
		<dshader><c path="h3d.shader.DirShadow"/></dshader>
		<border><c path="h3d.pass.Border"/></border>
		<mergePass expr="new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())">
			<c path="h3d.pass.ScreenFx"><c path="h3d.shader.MinMaxShader"/></c>
			<meta><m n=":value"><e>new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())</e></m></meta>
		</mergePass>
		<set_mode set="method" line="21" override="1"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_enabled set="method" line="26" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_size set="method" line="31" override="1"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowTex public="1" set="method" line="45" override="1"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<calcShadowBounds public="1" set="dynamic" line="49"><f a="camera">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></calcShadowBounds>
		<setGlobals set="method" line="108" override="1"><f a=""><x path="Void"/></f></setGlobals>
		<syncShader set="method" line="118" override="1"><f a="texture">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Void"/>
</f></syncShader>
		<saveStaticData public="1" set="method" line="136" override="1"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<loadStaticData public="1" set="method" line="161" override="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<draw public="1" set="method" line="192" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<computeStatic public="1" set="method" line="247" override="1"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></computeStatic>
		<new public="1" set="method" line="11"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DefaultShadowMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/DefaultShadowMap.hx">
		<extends path="h3d.pass.DirShadowMap"/>
		<shadowMapId><x path="Int"/></shadowMapId>
		<shadowProjId><x path="Int"/></shadowProjId>
		<shadowColorId><x path="Int"/></shadowColorId>
		<shadowPowerId><x path="Int"/></shadowPowerId>
		<shadowBiasId><x path="Int"/></shadowBiasId>
		<color public="1"><c path="h3d.Vector"/></color>
		<draw public="1" set="method" line="27" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="13">
			<f a="?size:?format" v="1024:">
				<x path="Int"/>
				<e path="hxd.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1024 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._HardwarePick.FixedColor" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/HardwarePick.hx" private="1" module="h3d.pass.HardwarePick">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorID public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorID>
		<colorID__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorID__>
		<get_colorID get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorID>
		<set_colorID get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorID>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var colorID:Vec4;
	@param var viewport:Vec4;
	var output:{ var position : Vec4; var colorID : Vec4};
	function vertex() {
		output.position = (output.position + vec4(viewport.xy, 0., 0.) * output.position.w) * vec4(viewport.zw, 1., 1.);
	};
	function fragment() {
		output.colorID = colorID;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.HardwarePick" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/HardwarePick.hx">
		<extends path="h3d.pass.Default"/>
		<pickX public="1"><x path="Float"/></pickX>
		<pickY public="1"><x path="Float"/></pickY>
		<fixedColor expr="new FixedColor()">
			<c path="h3d.pass._HardwarePick.FixedColor"/>
			<meta><m n=":value"><e>new FixedColor()</e></m></meta>
		</fixedColor>
		<colorID><x path="Int"/></colorID>
		<texOut><c path="h3d.mat.Texture"/></texOut>
		<material><c path="h3d.mat.Pass"/></material>
		<pickedIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</pickedIndex>
		<dispose public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></dispose>
		<getOutputs set="method" line="53" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<drawObject set="method" line="57" override="1"><f a="p">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></drawObject>
		<nextID get="inline" set="null" line="62"><f a=""><x path="Void"/></f></nextID>
		<draw public="1" set="method" line="66" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.PassListIterator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/PassList.hx" module="h3d.pass.PassList">
		<o><c path="h3d.pass.PassObject"/></o>
		<hasNext public="1" get="inline" set="null" line="8"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="11"><f a=""><c path="h3d.pass.PassObject"/></f></next>
		<new public="1" get="inline" set="null" line="5"><f a="o">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.PassList" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/PassList.hx">
		<current><c path="h3d.pass.PassObject"/></current>
		<discarded><c path="h3d.pass.PassObject"/></discarded>
		<lastDisc><c path="h3d.pass.PassObject"/></lastDisc>
		<init public="1" get="inline" set="null" line="32">
			<f a="pass">
				<c path="h3d.pass.PassObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the passes and empty the discarded list</haxe_doc>
		</init>
		<reset public="1" get="inline" set="null" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Put back discarded passes into the pass list</haxe_doc>
		</reset>
		<save public="1" get="inline" set="null" line="51">
			<f a=""><c path="h3d.pass.PassObject"/></f>
			<haxe_doc>Save the discarded list, allow to perfom some filters, then call "load" to restore passes</haxe_doc>
		</save>
		<load public="1" get="inline" set="null" line="58">
			<f a="p">
				<c path="h3d.pass.PassObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>load state that was save() before</haxe_doc>
		</load>
		<isEmpty public="1" get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></isEmpty>
		<clear public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Put all passes into discarded list</haxe_doc>
		</clear>
		<sort public="1" get="inline" set="null" line="92"><f a="f">
	<f a=":">
		<c path="h3d.pass.PassObject"/>
		<c path="h3d.pass.PassObject"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<filter public="1" get="inline" set="null" line="99">
			<f a="f">
				<f a="">
					<c path="h3d.pass.PassObject"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Filter current passes, add results to discarded list</haxe_doc>
		</filter>
		<iterator public="1" get="inline" set="null" line="132"><f a=""><c path="h3d.pass.PassListIterator"/></f></iterator>
		<getFiltered public="1" get="inline" set="null" line="139">
			<f a=""><c path="h3d.pass.PassListIterator"/></f>
			<haxe_doc>Iterate on all discarded elements, if any</haxe_doc>
		</getFiltered>
		<new public="1" set="method" line="25"><f a="?current">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.pass.PassObject</e></m>
		</meta>
	</class>
	<class path="h3d.pass.PassObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/PassObject.hx">
		<next public="1">
			<c path="h3d.pass.PassObject"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<nextAlloc><c path="h3d.pass.PassObject"/></nextAlloc>
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<index public="1"><x path="Int"/></index>
		<shaders public="1"><c path="hxsl.ShaderList"/></shaders>
		<shader public="1"><c path="hxsl.RuntimeShader"/></shader>
		<depth public="1"><x path="Float"/></depth>
		<texture public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texture>
		<new set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.ShaderManager" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/ShaderManager.hx">
		<STRICT public="1" expr="true" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</STRICT>
		<globals public="1"><c path="hxsl.Globals"/></globals>
		<shaderCache><c path="hxsl.Cache"/></shaderCache>
		<currentOutput><c path="hxsl.ShaderList"/></currentOutput>
		<setOutput public="1" set="method" line="21"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></setOutput>
		<fillRec set="method" line="27">
			<f a="v:type:out:pos">
				<d/>
				<e path="hxsl.Type"/>
				<t path="h3d.shader.ShaderBufferData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</fillRec>
		<shaderInfo set="method" line="154"><f a="shaders:path">
	<c path="hxsl.ShaderList"/>
	<c path="String"/>
	<c path="String"/>
</f></shaderInfo>
		<getPtr get="inline" set="null" line="166"><f a="data">
	<t path="h3d.shader.ShaderBufferData"/>
	<t path="h3d.shader.ShaderBufferData"/>
</f></getPtr>
		<getParamValue public="1" get="inline" set="null" line="174">
			<f a="p:shaders:?opt" v="::false">
				<c path="hxsl.AllocParam"/>
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getParamValue>
		<fillGlobals public="1" set="method" line="190"><f a="buf:s">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></fillGlobals>
		<fillParams public="1" set="method" line="212"><f a="buf:s:shaders">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></fillParams>
		<compileShaders public="1" set="method" line="261">
			<f a="shaders:?batchMode" v=":false">
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<c path="hxsl.RuntimeShader"/>
			</f>
			<meta><m n=":value"><e>{ batchMode : false }</e></m></meta>
		</compileShaders>
		<new public="1" set="method" line="11"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.pass.RenderMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Shadows.hx" module="h3d.pass.Shadows">
		<None/>
		<Static/>
		<Dynamic/>
		<Mixed/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.pass.ShadowSamplingKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/Shadows.hx" module="h3d.pass.Shadows">
		<None/>
		<PCF/>
		<ESM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.pass.SortByMaterial" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/pass/SortByMaterial.hx">
		<shaderCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</shaderCount>
		<textureCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textureCount>
		<shaderIdMap><c path="Array"><x path="Int"/></c></shaderIdMap>
		<textureIdMap><c path="Array"><x path="Int"/></c></textureIdMap>
		<sort public="1" set="method" line="15"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></sort>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.BigPrimitive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/BigPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<PREV_BUFFER static="1"><x path="hxd.FloatBuffer"/></PREV_BUFFER>
		<PREV_INDEX static="1"><x path="hxd.IndexBuffer"/></PREV_INDEX>
		<isRaw><x path="Bool"/></isRaw>
		<stride><x path="Int"/></stride>
		<buffers><c path="Array"><c path="h3d.Buffer"/></c></buffers>
		<allIndexes><c path="Array"><c path="h3d.Indexes"/></c></allIndexes>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<tmpIdx><x path="hxd.IndexBuffer"/></tmpIdx>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<bufPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufPos>
		<idxPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</idxPos>
		<startIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startIndex>
		<flushing><x path="Bool"/></flushing>
		<hasTangents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasTangents>
		<isStatic public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isStatic>
		<begin public="1" set="method" line="46">
			<f a="vcount:icount">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Call begin() before starting to add vertexes/indexes to the primitive.
		The count value is the number of vertexes you will add, it will automatically flush() if it doesn't fit into the current buffer.</haxe_doc>
		</begin>
		<addPoint public="1" get="inline" set="null" line="81">
			<f a="x:y:z">
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is similar to addVertexValue for X Y and Z, but will also update the bounds if you wish to have them calculated.</haxe_doc>
		</addPoint>
		<addBounds public="1" get="inline" set="null" line="88"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<addVertexValue public="1" get="inline" set="null" line="92"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Void"/>
</f></addVertexValue>
		<addIndex public="1" get="inline" set="null" line="96"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<triCount public="1" set="method" line="100" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="108" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<flush public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush the current buffer.
		It is required to call begin() after a flush()</haxe_doc>
		</flush>
		<render public="1" set="method" line="147" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="153" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<dispose public="1" set="method" line="157" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="161"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="183">
			<f a="buf:idx:?dx:?dy:?dz:?rotation:?scale:?stride" v="::0.:0.:0.:0.:1.:-1">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Adds a complete object to the primitive, with custom position,scale,rotation.
		See addSub for complete documentation.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="195">
			<f a="buf:idx:startVert:startTri:nvert:triCount:?dx:?dy:?dz:?rotation:?scale:?stride:?deltaU:?deltaV:?color:?mat" v="::::::0.:0.:0.:0.:1.:-1:0.:0.:1.:null">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ mat : null, color : 1., deltaV : 0., deltaU : 0., stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m>
				<m n=":noDebug"/>
			</meta>
			<haxe_doc>Adds a buffer to the primitive, with custom position,scale,rotation.
		The buffer can have more stride than the BigPrimitive, but not less.
		It is assumed that the buffer contains [X,Y,Z,NX,NY,NZ,U,V,R,G,B] (depending on his stride) so the different offsets are applied to the corresponding components.
		If hasTangent=true, we have [TX,TY,TZ] just after normal.
		However if the stride is 5, we assume [X,Y,Z,U,V]
		If mat is not null, it overrides dx, dy, dz, rotation, scale</haxe_doc>
		</addSub>
		<new public="1" set="method" line="30">
			<f a="stride:?isRaw" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isRaw : false }</e></m></meta>
		</new>
		<haxe_doc>Vertex buffers are limited to 65K vertexes because of the 16-bits limitation of the index buffers.
	BigPrimitive allows you to easily create large buffers by spliting the buffers.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.MeshPrimitive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/MeshPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<bufferCache><t path="Map">
	<x path="Int"/>
	<c path="h3d.BufferOffset"/>
</t></bufferCache>
		<layouts><t path="Map">
	<x path="Int"/>
	<c path="h3d.BufferOffset"/>
</t></layouts>
		<allocBuffer set="method" line="8"><f a="engine:name">
	<c path="h3d.Engine"/>
	<c path="String"/>
	<x path="Null"><c path="h3d.BufferOffset"/></x>
</f></allocBuffer>
		<hasBuffer public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBuffer>
		<addBuffer set="method" line="18">
			<f a="name:buf:?offset" v="::0">
				<c path="String"/>
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addBuffer>
		<dispose public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></dispose>
		<getBuffers set="method" line="37"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Null"><c path="h3d.BufferOffset"/></x>
</f></getBuffers>
		<render public="1" set="method" line="67" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="3">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="h3d.prim.HMDModel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/HMDModel.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<data><c path="hxd.fmt.hmd.Geometry"/></data>
		<dataPosition><x path="Int"/></dataPosition>
		<indexCount><x path="Int"/></indexCount>
		<indexesTriPos><c path="Array"><x path="Int"/></c></indexesTriPos>
		<lib><c path="hxd.fmt.hmd.Library"/></lib>
		<curMaterial><x path="Int"/></curMaterial>
		<collider><c path="h3d.col.Collider"/></collider>
		<normalsRecomputed><c path="String"/></normalsRecomputed>
		<bufferAliases expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a>
					<realName><c path="String"/></realName>
					<offset><x path="Int"/></offset>
				</a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</bufferAliases>
		<triCount public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="25" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getBounds public="1" set="method" line="29" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<selectMaterial public="1" set="method" line="33" override="1"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></selectMaterial>
		<getDataBuffers public="1" set="method" line="37"><f a="fmt:?defaults:?material">
	<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
	<c path="Array"><c path="h3d.Vector"/></c>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.GeometryBuffer"/>
</f></getDataBuffers>
		<loadSkin public="1" set="method" line="41"><f a="skin">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></loadSkin>
		<addAlias public="1" set="method" line="45">
			<f a="name:realName:?offset" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addAlias>
		<alloc public="1" set="method" line="56" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<allocAlias set="method" line="97"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></allocAlias>
		<recomputeNormals public="1" set="method" line="105"><f a="?name">
	<c path="String"/>
	<x path="Void"/>
</f></recomputeNormals>
		<render public="1" set="method" line="153" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<initCollider set="method" line="164"><f a="poly">
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></initCollider>
		<getCollider public="1" set="method" line="173" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<new public="1" set="method" line="15"><f a="data:dataPos:lib">
	<c path="hxd.fmt.hmd.Geometry"/>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.Library"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Plane2D" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/Plane2D.hx">
		<extends path="h3d.prim.Primitive"/>
		<get public="1" set="method" line="46" static="1"><f a=""><x path="Null"><d/></x></f></get>
		<triCount public="1" set="method" line="8" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="12" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="16" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="41" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Polygon" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/Polygon.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<points public="1"><c path="Array"><c path="h3d.col.Point"/></c></points>
		<normals public="1"><c path="Array"><c path="h3d.col.Point"/></c></normals>
		<tangents public="1"><c path="Array"><c path="h3d.col.Point"/></c></tangents>
		<uvs public="1"><c path="Array"><c path="h3d.prim.UV"/></c></uvs>
		<idx public="1"><x path="hxd.IndexBuffer"/></idx>
		<colors public="1"><c path="Array"><c path="h3d.col.Point"/></c></colors>
		<scaled expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":s"/>
			</meta>
		</scaled>
		<translatedX expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedX>
		<translatedY expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedY>
		<translatedZ expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedZ>
		<getBounds public="1" set="method" line="22" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<alloc public="1" set="method" line="29" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<unindex public="1" set="method" line="99"><f a=""><x path="Void"/></f></unindex>
		<translate public="1" set="method" line="134"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<scale public="1" set="method" line="145"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<addNormals public="1" set="method" line="154"><f a=""><x path="Void"/></f></addNormals>
		<addTangents public="1" set="method" line="186"><f a=""><x path="Void"/></f></addTangents>
		<addUVs public="1" set="method" line="233"><f a=""><x path="Void"/></f></addUVs>
		<uvScale public="1" set="method" line="239"><f a="su:sv">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uvScale>
		<triCount public="1" set="method" line="251" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="258" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getCollider public="1" set="method" line="262" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<render public="1" set="method" line="278" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="17"><f a="points:?idx">
	<c path="Array"><c path="h3d.col.Point"/></c>
	<x path="hxd.IndexBuffer"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.RawPrimitive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/RawPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<vcount><x path="Int"/></vcount>
		<tcount><x path="Int"/></tcount>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<onContextLost public="1"><f a=""><a>
	<vbuf><x path="hxd.FloatBuffer"/></vbuf>
	<stride><x path="Int"/></stride>
	<quads>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</quads>
	<ibuf>
		<x path="Null"><x path="hxd.IndexBuffer"/></x>
		<meta><m n=":optional"/></meta>
	</ibuf>
</a></f></onContextLost>
		<alloc public="1" set="method" line="17" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<getBounds public="1" set="method" line="34" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<triCount public="1" set="method" line="39" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="43" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<new public="1" set="method" line="10">
			<f a="inf:?persist" v=":false">
				<a>
					<vbuf><x path="hxd.FloatBuffer"/></vbuf>
					<stride><x path="Int"/></stride>
					<quads>
						<x path="Null"><x path="Bool"/></x>
						<meta><m n=":optional"/></meta>
					</quads>
					<ibuf>
						<x path="Null"><x path="hxd.IndexBuffer"/></x>
						<meta><m n=":optional"/></meta>
					</ibuf>
					<bounds>
						<x path="Null"><c path="h3d.col.Bounds"/></x>
						<meta><m n=":optional"/></meta>
					</bounds>
				</a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ persist : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.UV" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/prim/UV.hx">
		<u public="1"><x path="Float"/></u>
		<v public="1"><x path="Float"/></v>
		<clone public="1" set="method" line="13"><f a=""><c path="h3d.prim.UV"/></f></clone>
		<toString set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="u:v">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene._Graphics.GPoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Graphics.hx" private="1" module="h3d.scene.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method" line="12"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Object" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Object.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<ROT2RAD get="inline" set="null" expr="-0.017453292519943295769236907684886" line="35" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-0.017453292519943295769236907684886</e></m></meta>
		</ROT2RAD>
		<tmpMat expr="new h3d.Matrix()" line="803" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new h3d.Matrix()</e></m></meta>
			<haxe_doc>Set the position, scale and rotation of the object relative to its parent based on the specified transform matrix.</haxe_doc>
		</tmpMat>
		<tmpVec expr="new h3d.Vector()" line="804" static="1">
			<c path="h3d.Vector"/>
			<meta><m n=":value"><e>new h3d.Vector()</e></m></meta>
		</tmpVec>
		<flags>
			<x path="h3d.scene.ObjectFlags"/>
			<meta><m n=":s"/></meta>
		</flags>
		<children><c path="Array"><c path="h3d.scene.Object"/></c></children>
		<parent public="1" set="null">
			<c path="h3d.scene.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<x path="Null"><c path="String"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The x position of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The y position of the object relative to its parent.</haxe_doc>
		</y>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The z position of the object relative to its parent.</haxe_doc>
		</z>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the X axis of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Y axis of this object (default 1.0)</haxe_doc>
		</scaleY>
		<scaleZ public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Z axis of this object (default 1.0)</haxe_doc>
		</scaleZ>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<allocated get="accessor" set="accessor"><x path="Bool"/></allocated>
		<follow public="1" set="accessor">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Follow a given object or joint as if it was our parent. Ignore defaultTransform when set.</haxe_doc>
		</follow>
		<followPositionOnly public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When follow is set, only follow the position and ignore both scale and rotation.</haxe_doc>
		</followPositionOnly>
		<defaultTransform public="1" set="accessor">
			<c path="h3d.Matrix"/>
			<haxe_doc>This is an additional optional transformation that is performed before other local transformations.
		It is used by the animation system.</haxe_doc>
		</defaultTransform>
		<currentAnimation public="1" set="null">
			<c path="h3d.anim.Animation"/>
			<meta><m n=":s"/></meta>
		</currentAnimation>
		<culled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Inform that the object is not to be displayed and his animation doesn't have to be sync. Unlike visible, this doesn't apply to children unless inheritCulled is set to true.</haxe_doc>
		</culled>
		<alwaysSync public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When an object is not visible or culled, its animation does not get synchronized unless you set alwaysSync=true</haxe_doc>
		</alwaysSync>
		<inheritCulled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the culled flag and culling collider is inherited by children objects.</haxe_doc>
		</inheritCulled>
		<ignoreBounds public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object bounds are ignored when using getBounds()</haxe_doc>
		</ignoreBounds>
		<ignoreCollide public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object is ignored when using getCollider()</haxe_doc>
		</ignoreCollide>
		<allowSerialize public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object can be serialized (default : true)</haxe_doc>
		</allowSerialize>
		<ignoreParentTransform public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object will not follow its parent transform</haxe_doc>
		</ignoreParentTransform>
		<lightCameraCenter public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When selecting the lights to apply to this object, we will use the camera target as reference
		instead of the object absolute position. This is useful for very large objects so they can get good lighting.</haxe_doc>
		</lightCameraCenter>
		<cullingCollider public="1" set="accessor">
			<c path="h3d.col.Collider"/>
			<haxe_doc>When set, collider shape will be used for automatic frustum culling.
		If `inheritCulled` is true, collider will be inherited to children unless they have their own collider set.</haxe_doc>
		</cullingCollider>
		<set_cullingCollider set="method" line="156"><f a="c">
	<c path="h3d.col.Collider"/>
	<c path="h3d.col.Collider"/>
</f></set_cullingCollider>
		<cullingColliderInherited get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Indicates that current cullingCollider is currently inherited from a parent object</haxe_doc>
		</cullingColliderInherited>
		<absPos><c path="h3d.Matrix"/></absPos>
		<invPos><c path="h3d.Matrix"/></invPos>
		<qRot><c path="h3d.Quat"/></qRot>
		<posChanged get="accessor" set="accessor"><x path="Bool"/></posChanged>
		<lastFrame><x path="Int"/></lastFrame>
		<get_visible get="inline" set="null" line="189"><f a=""><x path="Bool"/></f></get_visible>
		<get_allocated get="inline" set="null" line="190"><f a=""><x path="Bool"/></f></get_allocated>
		<get_posChanged get="inline" set="null" line="191"><f a=""><x path="Bool"/></f></get_posChanged>
		<get_culled get="inline" set="null" line="192"><f a=""><x path="Bool"/></f></get_culled>
		<get_followPositionOnly get="inline" set="null" line="193"><f a=""><x path="Bool"/></f></get_followPositionOnly>
		<get_lightCameraCenter get="inline" set="null" line="194"><f a=""><x path="Bool"/></f></get_lightCameraCenter>
		<get_alwaysSync get="inline" set="null" line="195"><f a=""><x path="Bool"/></f></get_alwaysSync>
		<get_inheritCulled get="inline" set="null" line="196"><f a=""><x path="Bool"/></f></get_inheritCulled>
		<get_ignoreBounds get="inline" set="null" line="197"><f a=""><x path="Bool"/></f></get_ignoreBounds>
		<get_ignoreCollide get="inline" set="null" line="198"><f a=""><x path="Bool"/></f></get_ignoreCollide>
		<get_allowSerialize get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></get_allowSerialize>
		<get_ignoreParentTransform get="inline" set="null" line="200"><f a=""><x path="Bool"/></f></get_ignoreParentTransform>
		<get_cullingColliderInherited get="inline" set="null" line="201"><f a=""><x path="Bool"/></f></get_cullingColliderInherited>
		<set_posChanged get="inline" set="null" line="202"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_posChanged>
		<set_culled get="inline" set="null" line="203"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_culled>
		<set_visible get="inline" set="null" line="204"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_allocated get="inline" set="null" line="205"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allocated>
		<set_followPositionOnly get="inline" set="null" line="206"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_followPositionOnly>
		<set_lightCameraCenter get="inline" set="null" line="207"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_lightCameraCenter>
		<set_alwaysSync get="inline" set="null" line="208"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alwaysSync>
		<set_ignoreBounds get="inline" set="null" line="209"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreBounds>
		<set_inheritCulled get="inline" set="null" line="210"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inheritCulled>
		<set_ignoreCollide get="inline" set="null" line="211"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreCollide>
		<set_allowSerialize get="inline" set="null" line="212"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSerialize>
		<set_ignoreParentTransform get="inline" set="null" line="213"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreParentTransform>
		<set_cullingColliderInherited get="inline" set="null" line="214"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cullingColliderInherited>
		<playAnimation public="1" set="method" line="219">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Create an animation instance bound to the object, set it as currentAnimation and play it.</haxe_doc>
		</playAnimation>
		<switchToAnimation public="1" set="method" line="226">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Change the current animation. This animation should be an instance that was previously created by playAnimation.</haxe_doc>
		</switchToAnimation>
		<stopAnimation public="1" set="method" line="233">
			<f a="?recursive" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>Stop the current animation. If recursive is set to true, all children will also stop their animation</haxe_doc>
		</stopAnimation>
		<applyAnimationTransform public="1" set="method" line="248">
			<f a="?recursive" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>When an object is loaded, its position scale and rotation will always be set to the default values (0 for position/rotation and 1 for scale).
		If it's part of a group/scene or if it's animated, then its position/rotation/scale will be stored into the defaultTransform matrix.
		Calling this function will reset the defaultTransform to null and instead initialize x/y/z/rotation/scale properties.
		This will not change the actual position of the object but allows you to move the object more freely on your own.
		Do not use on an object that is currently being animated, since it will set again defaultTransform and apply twice the transformation.</haxe_doc>
		</applyAnimationTransform>
		<getObjectsCount public="1" set="method" line="268">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<getMaterialByName public="1" set="method" line="278">
			<f a="name">
				<c path="String"/>
				<c path="h3d.mat.Material"/>
			</f>
			<haxe_doc>Search for a material recursively by name, return it or null if not found.</haxe_doc>
		</getMaterialByName>
		<find public="1" params="T" set="method" line="289">
			<f a="f">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="303">
			<f a="f:?arr">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<getMaterials public="1" set="method" line="316">
			<f a="?a">
				<c path="Array"><c path="h3d.mat.Material"/></c>
				<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
			</f>
			<haxe_doc>Return all materials in the tree.</haxe_doc>
		</getMaterials>
		<localToGlobal public="1" set="method" line="326">
			<f a="?pt">
				<c path="h3d.Vector"/>
				<x path="Null"><c path="h3d.Vector"/></x>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute global position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="336">
			<f a="pt">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Convert an absolute global position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getInvPos public="1" set="method" line="344">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated inverse position matrix. Please note that this is not a copy and should not be modified.</haxe_doc>
		</getInvPos>
		<getBounds final="1" public="1" set="method" line="358">
			<f a="?b">
				<c path="h3d.col.Bounds"/>
				<c path="h3d.col.Bounds"/>
			</f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Return the bounds of this object and all its children, in absolute global coordinates.</haxe_doc>
		</getBounds>
		<getBoundsRec set="method" line="366"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getMeshes public="1" set="method" line="381">
			<f a="?out">
				<c path="Array"><c path="h3d.scene.Mesh"/></c>
				<x path="Null"><c path="Array"><c path="h3d.scene.Mesh"/></c></x>
			</f>
			<haxe_doc>Return all meshes part of this tree</haxe_doc>
		</getMeshes>
		<getMeshByName public="1" set="method" line="393">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Mesh"/>
			</f>
			<haxe_doc>Search for an mesh recursively by name, return null if not found.</haxe_doc>
		</getMeshByName>
		<getObjectByName public="1" set="method" line="400">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<clone public="1" set="method" line="413">
			<f a="?o">
				<c path="h3d.scene.Object"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Make a copy of the object and all its children.</haxe_doc>
		</clone>
		<addChild public="1" set="method" line="442">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="449">
			<f a="o:pos">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<iterVisibleMeshes public="1" set="method" line="481">
			<f a="callb">
				<f a="">
					<c path="h3d.scene.Mesh"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Iterate on all mesh that are currently visible and not culled in the tree. Call `callb` for each mesh found.</haxe_doc>
		</iterVisibleMeshes>
		<onParentChanged set="method" line="492"><f a=""><x path="Void"/></f></onParentChanged>
		<onAdd set="method" line="498"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="505"><f a=""><x path="Void"/></f></onRemove>
		<removeChild public="1" set="method" line="514">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<removeChildren public="1" set="method" line="525">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="534">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onParentChanged</haxe_doc>
		</remove>
		<getScene public="1" set="method" line="541">
			<f a=""><c path="h3d.scene.Scene"/></f>
			<haxe_doc>Return the Scene this object is part of, or null if not added to a Scene.</haxe_doc>
		</getScene>
		<getAbsPos public="1" set="method" line="550">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated absolute position matrix. Please note that this is not a copy so it should not be modified.</haxe_doc>
		</getAbsPos>
		<isMesh public="1" get="inline" set="null" line="558">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tell if the object is a Mesh.</haxe_doc>
		</isMesh>
		<toMesh public="1" set="method" line="565">
			<f a=""><c path="h3d.scene.Mesh"/></f>
			<haxe_doc>If the object is a Mesh, return the corresponding Mesh. If not, throw an exception.</haxe_doc>
		</toMesh>
		<getCollider final="1" public="1" set="method" line="576">
			<f a=""><c path="h3d.col.Collider"/></f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Build and return the global absolute recursive collider for the object.
		Returns null if no collider was found or if ignoreCollide was set to true.</haxe_doc>
		</getCollider>
		<getGlobalCollider public="1" set="method" line="603">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Same as getLocalCollider, but returns an absolute collider instead of a local one.</haxe_doc>
		</getGlobalCollider>
		<getLocalCollider public="1" set="method" line="614">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Build and returns the local relative not-recursive collider for the object, or null if this object does not have a collider.
		Does not check for ignoreCollide.</haxe_doc>
		</getLocalCollider>
		<draw set="method" line="618"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<set_follow set="method" line="621"><f a="v">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></set_follow>
		<calcAbsPos set="method" line="626"><f a=""><x path="Void"/></f></calcAbsPos>
		<sync set="method" line="659"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncRec set="method" line="662"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></syncRec>
		<syncPos set="method" line="714"><f a=""><x path="Void"/></f></syncPos>
		<emit set="method" line="724"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<emitRec set="method" line="727"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emitRec>
		<set_x get="inline" set="null" line="748"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="754"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z get="inline" set="null" line="760"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_scaleX get="inline" set="null" line="766"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="772"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_scaleZ get="inline" set="null" line="778"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleZ>
		<set_defaultTransform get="inline" set="null" line="784"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_defaultTransform>
		<setPosition public="1" get="inline" set="null" line="793">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<setTransform public="1" set="method" line="805"><f a="mat">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></setTransform>
		<rotate public="1" set="method" line="822">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate around the current rotation axis by the specified angles (in radian).</haxe_doc>
		</rotate>
		<setRotation public="1" set="method" line="832">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified angles (in radian).</haxe_doc>
		</setRotation>
		<setRotationAxis public="1" set="method" line="840">
			<f a="ax:ay:az:angle">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified axis and angle of rotation around it (in radian).</haxe_doc>
		</setRotationAxis>
		<setDirection public="1" set="method" line="848">
			<f a="v">
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified look at direction</haxe_doc>
		</setDirection>
		<getDirection public="1" set="method" line="856">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Return the direction in which the object rotation is currently oriented to</haxe_doc>
		</getDirection>
		<getRotationQuat public="1" set="method" line="864">
			<f a=""><c path="h3d.Quat"/></f>
			<haxe_doc>Return the quaternion representing the current object rotation.
		Dot not modify as it's not a copy.</haxe_doc>
		</getRotationQuat>
		<setRotationQuat public="1" set="method" line="872">
			<f a="q">
				<c path="h3d.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the quaternion representing the current object rotation.
		Dot not modify the value afterwards as no copy is made.</haxe_doc>
		</setRotationQuat>
		<scale public="1" get="inline" set="null" line="880">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="890">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<toString public="1" set="method" line="900">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return both class name and object name if any.</haxe_doc>
		</toString>
		<getChildAt public="1" get="inline" set="null" line="907">
			<f a="n">
				<x path="Int"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="914">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<get_numChildren get="inline" set="null" line="921"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="928">
			<f a=""><c path="hxd.impl.ArrayIterator_h3d_scene_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<new public="1" set="method" line="176">
			<f a="?parent">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Object is the base 3D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Mesh" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Mesh.hx">
		<extends path="h3d.scene.Object"/>
		<primitive public="1" set="accessor">
			<c path="h3d.prim.Primitive"/>
			<haxe_doc>The primitive of the mesh: the list of vertexes and indices necessary to display the mesh.</haxe_doc>
		</primitive>
		<material public="1">
			<c path="h3d.mat.Material"/>
			<haxe_doc>The material of the mesh: the properties used to display it (texture, color, shaders, etc.)</haxe_doc>
		</material>
		<getMeshMaterials public="1" set="method" line="36">
			<f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f>
			<haxe_doc>Return all materials for the current object.</haxe_doc>
		</getMeshMaterials>
		<getBoundsRec set="method" line="40" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<clone public="1" set="method" line="50" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></clone>
		<getLocalCollider public="1" set="method" line="58" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<draw set="method" line="62" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<emit set="method" line="66" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="70" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="76" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<onAdd set="method" line="95" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="101" override="1"><f a=""><x path="Void"/></f></onRemove>
		<set_primitive set="method" line="107"><f a="prim">
	<c path="h3d.prim.Primitive"/>
	<c path="h3d.prim.Primitive"/>
</f></set_primitive>
		<new public="1" set="method" line="23">
			<f a="primitive:?material:?parent">
				<c path="h3d.prim.Primitive"/>
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new mesh with given primitive, material and parent object.
		If material is not specified, a new default material is created for the current renderer.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Mesh is the base class for all 3D objects displayed on screen.
	Unlike Object base class, all properties of Mesh only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Graphics" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Graphics.hx">
		<extends path="h3d.scene.Mesh"/>
		<bprim><c path="h3d.prim.BigPrimitive"/></bprim>
		<curX expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curX>
		<curY expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curY>
		<curZ expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curZ>
		<curR expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lineSize>
		<lineShader><c path="h3d.shader.LineShader"/></lineShader>
		<tmpPoints><c path="Array"><c path="h3d.scene._Graphics.GPoint"/></c></tmpPoints>
		<is3D public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Setting is3D to true will switch from a screen space line (constant size whatever the distance) to a world space line</haxe_doc>
		</is3D>
		<onRemove set="method" line="58" override="1"><f a=""><x path="Void"/></f></onRemove>
		<set_is3D set="method" line="63"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_is3D>
		<flushLine set="method" line="76"><f a=""><x path="Void"/></f></flushLine>
		<flush set="method" line="185"><f a=""><x path="Void"/></f></flush>
		<sync set="method" line="194" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="200" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<clear public="1" set="method" line="206"><f a=""><x path="Void"/></f></clear>
		<lineStyle public="1" set="method" line="211">
			<f a="?size:?color:?alpha" v="0.:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0. }</e></m></meta>
		</lineStyle>
		<setColor public="1" set="method" line="220">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawLine public="1" get="inline" set="null" line="227"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></drawLine>
		<moveTo public="1" set="method" line="232"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<addVertex get="inline" set="null" line="243"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addVertex>
		<lineTo public="1" set="method" line="247"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<new public="1" set="method" line="42"><f a="?parent">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Interactive" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Interactive.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.Interactive"/>
		<shape public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</shape>
		<preciseShape public="1">
			<x path="Null"><c path="h3d.col.Collider"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>If several interactive conflicts, the preciseShape (if defined) can be used to distinguish between the two.</haxe_doc>
		</preciseShape>
		<priority public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>In case of conflicting shapes, usually the one in front of the camera is prioritized, unless you set an higher priority.</haxe_doc>
		</priority>
		<cursor public="1" set="accessor"><x path="Null"><e path="hxd.Cursor"/></x></cursor>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<enableRightButton public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</enableRightButton>
		<bestMatch public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Is it required to find the best hit point in a complex mesh or any hit possible point will be enough (default = false, faster).</haxe_doc>
		</bestMatch>
		<scene><c path="h3d.scene.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<hitPoint expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta>
				<m n=":value"><e>new h3d.Vector()</e></m>
				<m n=":allow"><e>h3d.scene.Scene</e></m>
			</meta>
		</hitPoint>
		<onAdd set="method" line="45" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="51" override="1"><f a=""><x path="Void"/></f></onRemove>
		<preventClick public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="66">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="70">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<set_cursor set="method" line="116"><f a="c">
	<x path="Null"><e path="hxd.Cursor"/></x>
	<x path="Null"><e path="hxd.Cursor"/></x>
</f></set_cursor>
		<focus public="1" set="method" line="123"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="129"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="133"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="137"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="146">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOver`.
		Propagation can be set with `onMove` event, as well as cancelling `onMove` will prevent `onOver`.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="152">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOut`.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="156">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="167">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="174">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="181">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="184"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="187"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="190"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="193"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="196"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="199"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="202"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="205"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="39"><f a="shape:?parent">
	<c path="h3d.col.Collider"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.Light" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Light.hx">
		<extends path="h3d.scene.Object"/>
		<shader><c path="hxsl.Shader"/></shader>
		<objectDistance><x path="Float"/></objectDistance>
		<next public="1">
			<c path="h3d.scene.Light"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<cullingDistance expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n=":s"/>
			</meta>
		</cullingDistance>
		<priority public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</priority>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<enableSpecular public="1" get="accessor" set="accessor"><x path="Bool"/></enableSpecular>
		<get_color set="method" line="20"><f a=""><c path="h3d.Vector"/></f></get_color>
		<set_color set="method" line="24"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_color>
		<get_enableSpecular set="method" line="28"><f a=""><x path="Bool"/></f></get_enableSpecular>
		<set_enableSpecular set="method" line="32"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableSpecular>
		<emit set="method" line="37" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getShadowDirection set="method" line="41"><f a=""><c path="h3d.Vector"/></f></getShadowDirection>
		<new set="method" line="14"><f a="shader:?parent">
	<c path="hxsl.Shader"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.LightSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/LightSystem.hx">
		<drawPasses public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawPasses>
		<ambientLight public="1" set="null"><c path="h3d.Vector"/></ambientLight>
		<shadowLight public="1"><c path="h3d.scene.Light"/></shadowLight>
		<lightCount><x path="Int"/></lightCount>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<initGlobals public="1" set="method" line="16"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></initGlobals>
		<cullLights set="method" line="19"><f a=""><x path="Void"/></f></cullLights>
		<initLights public="1" set="method" line="45"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></initLights>
		<computeLight public="1" set="method" line="62"><f a="obj:shaders">
	<c path="h3d.scene.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></computeLight>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h3d.scene.MultiMaterial" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/MultiMaterial.hx">
		<extends path="h3d.scene.Mesh"/>
		<materials public="1"><c path="Array"><c path="h3d.mat.Material"/></c></materials>
		<getMeshMaterials public="1" set="method" line="12" override="1"><f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f></getMeshMaterials>
		<clone public="1" set="method" line="16" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.MultiMaterial"/>
</f></clone>
		<emit set="method" line="26" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="34" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="41" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<draw set="method" line="51" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="7"><f a="prim:?mats:?parent">
	<c path="h3d.prim.Primitive"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.scene.ObjectFlags" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Object.hx" module="h3d.scene.Object">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object" final="1">
	<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x01</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FPosChanged>
	<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x02</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FVisible>
	<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x04</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FCulled>
	<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FFollowPositionOnly>
	<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLightCameraCenter>
	<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAllocated>
	<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAlwaysSync>
	<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FInheritCulled>
	<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FNoSerialize>
	<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreBounds>
	<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x400</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreCollide>
	<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x800</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreParentTransform>
	<FCullingColliderInherited public="1" get="inline" set="null" expr="cast 0x1000" line="16" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x1000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FCullingColliderInherited>
	<_new public="1" get="inline" set="null" line="17" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<has public="1" get="inline" set="null" line="21" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<set public="1" get="inline" set="null" line="22" static="1">
		<f a="this:f:b">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object" final="1">
		<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x01</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FPosChanged>
		<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x02</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FVisible>
		<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x04</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FCulled>
		<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FFollowPositionOnly>
		<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLightCameraCenter>
		<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAllocated>
		<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAlwaysSync>
		<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FInheritCulled>
		<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FNoSerialize>
		<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreBounds>
		<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x400</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreCollide>
		<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x800</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreParentTransform>
		<FCullingColliderInherited public="1" get="inline" set="null" expr="cast 0x1000" line="16" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x1000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FCullingColliderInherited>
		<_new public="1" get="inline" set="null" line="17" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<has public="1" get="inline" set="null" line="21" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<set public="1" get="inline" set="null" line="22" static="1">
			<f a="this:f:b">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="h3d.scene._RenderContext.SharedGlobal" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/RenderContext.hx" private="1" module="h3d.scene.RenderContext">
		<gid public="1"><x path="Int"/></gid>
		<value public="1"><d/></value>
		<new public="1" set="method" line="6"><f a="gid:value">
	<x path="Int"/>
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.RenderContext" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<camera public="1"><c path="h3d.Camera"/></camera>
		<scene public="1"><c path="h3d.scene.Scene"/></scene>
		<drawPass public="1"><c path="h3d.pass.PassObject"/></drawPass>
		<pbrLightPass public="1"><c path="h3d.mat.Pass"/></pbrLightPass>
		<computingStatic public="1"><x path="Bool"/></computingStatic>
		<sharedGlobals><c path="Array"><c path="h3d.scene._RenderContext.SharedGlobal"/></c></sharedGlobals>
		<lightSystem public="1"><c path="h3d.scene.LightSystem"/></lightSystem>
		<extraShaders public="1"><c path="hxsl.ShaderList"/></extraShaders>
		<visibleFlag public="1"><x path="Bool"/></visibleFlag>
		<shaderBuffers public="1"><c path="h3d.shader.Buffers"/></shaderBuffers>
		<cullingCollider public="1"><c path="h3d.col.Collider"/></cullingCollider>
		<allocPool><c path="h3d.pass.PassObject"/></allocPool>
		<allocFirst><c path="h3d.pass.PassObject"/></allocFirst>
		<cachedShaderList><c path="Array"><c path="hxsl.ShaderList"/></c></cachedShaderList>
		<cachedPassObjects><c path="Array"><c path="h3d.scene.PassObjects"/></c></cachedPassObjects>
		<cachedPos><x path="Int"/></cachedPos>
		<passes><c path="h3d.pass.PassObject"/></passes>
		<lights><c path="h3d.scene.Light"/></lights>
		<currentManager><c path="h3d.pass.ShaderManager"/></currentManager>
		<emit public="1" get="inline" set="null" line="43">
			<f a="mat:obj:?index" v="::0">
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : 0 }</e></m>
				<m n=":access"><e>h3d.mat.Pass</e></m>
			</meta>
		</emit>
		<start public="1" set="method" line="51"><f a=""><x path="Void"/></f></start>
		<nextPass public="1" get="inline" set="null" line="63"><f a=""><x path="Void"/></f></nextPass>
		<getGlobal public="1" set="method" line="68"><f a="name">
	<c path="String"/>
	<d/>
</f></getGlobal>
		<setGlobal public="1" get="inline" set="null" line="76"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setGlobal>
		<setGlobalID public="1" set="method" line="80"><f a="gid:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setGlobalID>
		<emitPass public="1" set="method" line="89"><f a="pass:obj">
	<c path="h3d.mat.Pass"/>
	<c path="h3d.scene.Object"/>
	<c path="h3d.pass.PassObject"/>
</f></emitPass>
		<allocShaderList public="1" set="method" line="104"><f a="s:?next">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></allocShaderList>
		<emitLight public="1" set="method" line="115"><f a="l">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></emitLight>
		<uploadParams public="1" set="method" line="120"><f a=""><x path="Void"/></f></uploadParams>
		<done public="1" set="method" line="126"><f a=""><x path="Void"/></f></done>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.PassObjects" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<name public="1"><c path="String"/></name>
		<passes public="1"><c path="h3d.pass.PassList"/></passes>
		<rendered public="1"><x path="Bool"/></rendered>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene._Renderer.SMap" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Renderer.hx" private="1" module="h3d.scene.Renderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene._Renderer.SMap.T"/>
</t></typedef>
	<enum path="h3d.scene.RenderMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<Default/>
		<LightProbe/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.scene.Renderer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Renderer.hx">
		<extends path="hxd.impl.AnyProps"/>
		<defaultPass><c path="h3d.pass.Base"/></defaultPass>
		<passObjects><t path="h3d.scene._Renderer.SMap"><c path="h3d.scene.PassObjects"/></t></passObjects>
		<allPasses><c path="Array"><c path="h3d.pass.Base"/></c></allPasses>
		<emptyPasses expr="new h3d.pass.PassList()">
			<c path="h3d.pass.PassList"/>
			<meta><m n=":value"><e>new h3d.pass.PassList()</e></m></meta>
		</emptyPasses>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<hasSetTarget expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasSetTarget>
		<frontToBack><f a="">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></frontToBack>
		<backToFront><f a="">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></backToFront>
		<effects public="1" expr="[]">
			<c path="Array"><c path="h3d.impl.RendererFX"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<renderMode public="1" expr="Default">
			<e path="h3d.scene.RenderMode"/>
			<meta><m n=":value"><e>Default</e></m></meta>
		</renderMode>
		<dispose public="1" set="method" line="45"><f a=""><x path="Void"/></f></dispose>
		<mark set="method" line="53"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></mark>
		<getPass public="1" params="T" set="method" line="56"><f a="c">
	<x path="Class"><c path="getPass.T"/></x>
	<c path="getPass.T"/>
</f></getPass>
		<getPassByName public="1" set="method" line="63"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Base"/>
</f></getPassByName>
		<debugCompileShader public="1" set="method" line="70"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></debugCompileShader>
		<hasFeature set="method" line="77"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getDefaultLight params="T" set="method" line="81"><f a="l">
	<c path="getDefaultLight.T"/>
	<c path="getDefaultLight.T"/>
</f></getDefaultLight>
		<getLightSystem set="method" line="85"><f a=""><c path="h3d.scene.LightSystem"/></f></getLightSystem>
		<time set="method" line="89"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></time>
		<depthSort set="method" line="93">
			<f a="frontToBack:passes">
				<x path="Bool"/>
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene.Object</e></m></meta>
		</depthSort>
		<clear get="inline" set="null" line="106"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<allocTarget get="inline" set="null" line="110">
			<f a="name:?depth:?size:?format" v=":true:1.:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ size : 1., depth : true }</e></m></meta>
		</allocTarget>
		<copy set="method" line="114"><f a="from:to:?blend">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></copy>
		<setTarget set="method" line="118"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTarget>
		<setTargets params="T" set="method" line="124"><f a="textures">
	<c path="Array"><c path="setTargets.T"/></c>
	<x path="Void"/>
</f></setTargets>
		<resetTarget set="method" line="130"><f a=""><x path="Void"/></f></resetTarget>
		<has set="method" line="137"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get set="method" line="141"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.PassList"/>
</f></get>
		<draw set="method" line="148"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></draw>
		<render set="method" line="152"><f a=""><x path="Void"/></f></render>
		<computeStatic set="method" line="156"><f a=""><x path="Void"/></f></computeStatic>
		<start public="1" set="method" line="160"><f a=""><x path="Void"/></f></start>
		<process public="1" set="method" line="163"><f a="passes">
	<c path="Array"><c path="h3d.scene.PassObjects"/></c>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hrt.prefab.rfx.RendererFX</e></m>
			<m n=":allow"><e>h3d.pass.Shadows</e></m>
		</meta>
	</class>
	<class path="h3d.scene.Scene" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Scene.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<camera public="1">
			<c path="h3d.Camera"/>
			<haxe_doc>The scene current camera.</haxe_doc>
		</camera>
		<lightSystem public="1">
			<c path="h3d.scene.LightSystem"/>
			<haxe_doc>The scene light system. Can be customized.</haxe_doc>
		</lightSystem>
		<renderer public="1" set="accessor">
			<c path="h3d.scene.Renderer"/>
			<haxe_doc>The scene renderer. Can be customized.</haxe_doc>
		</renderer>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<interactives><c path="Array"><c path="h3d.scene.Interactive"/></c></interactives>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h3d.scene.Interactive</e></m></meta>
		</events>
		<hitInteractives><c path="Array"><c path="h3d.scene.Interactive"/></c></hitInteractives>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<window><c path="hxd.Window"/></window>
		<setEvents public="1" set="method" line="53">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</setEvents>
		<addEventListener public="1" set="method" line="60">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="67">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<dispatchListeners public="1" set="method" line="77">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<set_renderer set="method" line="84"><f a="r">
	<c path="h3d.scene.Renderer"/>
	<c path="h3d.scene.Renderer"/>
</f></set_renderer>
		<sortHitPointByCameraDistance set="method" line="90"><f a="i1:i2">
	<c path="h3d.scene.Interactive"/>
	<c path="h3d.scene.Interactive"/>
	<x path="Int"/>
</f></sortHitPointByCameraDistance>
		<dispatchEvent public="1" set="method" line="99">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<isInteractiveVisible public="1" set="method" line="106">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<handleEvent public="1" set="method" line="116">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Null"><c path="h3d.scene.Interactive"/></x>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<clone public="1" set="method" line="232" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Scene"/>
</f></clone>
		<dispose public="1" set="method" line="242">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Free the GPU memory for this Scene and its children</haxe_doc>
		</dispose>
		<addEventTarget set="method" line="257">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="263">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</removeEventTarget>
		<setElapsedTime public="1" set="method" line="274">
			<f a="elapsedTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<hardwarePass><c path="h3d.pass.HardwarePick"/></hardwarePass>
		<hardwarePick public="1" set="method" line="287">
			<f a="pixelX:pixelY">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Use GPU rendering to pick a model at the given pixel position.
		hardwarePick() will check all scene visible meshes bounds against a ray cast with current camera, then draw them into a 1x1 pixel texture with a specific shader.
		The texture will then be read and the color will identify the object that was rendered at this pixel.
		This is a very precise way of doing scene picking since it performs exactly the same transformations (skinning, custom shaders, etc.) but might be more costly than using CPU colliders.
		Please note that when done during/after rendering, this might clear the screen on some platforms so it should always be done before rendering.</haxe_doc>
		</hardwarePick>
		<syncOnly public="1" set="method" line="339">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<computeStatic public="1" set="method" line="361">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform a rendering with `RendererContext.computingStatic=true`, allowing the computation of static shadow maps, etc.</haxe_doc>
		</computeStatic>
		<render public="1" set="method" line="375">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":access"><e>h3d.mat.Pass</e></m>
				<m n=":access"><e>h3d.scene.RenderContext</e></m>
			</meta>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<serializeScene public="1" set="method" line="458">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Serialize the scene content as HSD bytes (see hxd.fmt.hsd package). Requires -lib hxbit</haxe_doc>
		</serializeScene>
		<new public="1" set="method" line="37">
			<f a="?createRenderer:?createLightSystem" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ createLightSystem : true, createRenderer : true }</e></m></meta>
			<haxe_doc>Create a new scene. A default 3D scene is already available in `hxd.App.s3d`</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Scene is the root class for a 3D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Joint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Skin.hx" module="h3d.scene.Skin">
		<extends path="h3d.scene.Object"/>
		<skin public="1">
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</skin>
		<index public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</index>
		<getObjectByName public="1" set="method" line="16" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Joint"/>
</f></getObjectByName>
		<syncPos set="method" line="36" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>h3d.scene.Skin</e></m></meta>
		</syncPos>
		<new public="1" set="method" line="7"><f a="skin:j">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.anim.Joint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Skin" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/Skin.hx">
		<extends path="h3d.scene.MultiMaterial"/>
		<skinData><c path="h3d.anim.Skin"/></skinData>
		<currentRelPose><c path="Array"><c path="h3d.Matrix"/></c></currentRelPose>
		<currentAbsPose><c path="Array"><c path="h3d.Matrix"/></c></currentAbsPose>
		<currentPalette><c path="Array"><c path="h3d.Matrix"/></c></currentPalette>
		<splitPalette><c path="Array"><c path="Array"><c path="h3d.Matrix"/></c></c></splitPalette>
		<jointsUpdated><x path="Bool"/></jointsUpdated>
		<jointsAbsPosInv><c path="h3d.Matrix"/></jointsAbsPosInv>
		<paletteChanged><x path="Bool"/></paletteChanged>
		<skinShader><c path="h3d.shader.SkinBase"/></skinShader>
		<jointsGraphics><c path="h3d.scene.Graphics"/></jointsGraphics>
		<showJoints public="1"><x path="Bool"/></showJoints>
		<clone public="1" set="method" line="88" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Skin"/>
</f></clone>
		<getBoundsRec set="method" line="96" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getObjectByName public="1" set="method" line="117" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></getObjectByName>
		<getLocalCollider public="1" set="method" line="132" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<getGlobalCollider public="1" set="method" line="137" override="1"><f a=""><c path="h3d.col.SkinCollider"/></f></getGlobalCollider>
		<calcAbsPos set="method" line="143" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<getSkinData public="1" set="method" line="149"><f a=""><c path="h3d.anim.Skin"/></f></getSkinData>
		<setSkinData public="1" set="method" line="153">
			<f a="s:?shaderInit" v=":true">
				<c path="h3d.anim.Skin"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shaderInit : true }</e></m></meta>
		</setSkinData>
		<sync set="method" line="199" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncJoints set="method" line="206">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noDebug"/></meta>
		</syncJoints>
		<emit set="method" line="226" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<draw set="method" line="262" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="82"><f a="s:?mat:?parent">
	<c path="h3d.anim.Skin"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.LightSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/fwd/LightSystem.hx">
		<extends path="h3d.scene.LightSystem"/>
		<maxLightsPerObject public="1" expr="6">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</maxLightsPerObject>
		<globals><c path="hxsl.Globals"/></globals>
		<ambientShader><c path="hxsl.Shader"/></ambientShader>
		<perPixelLighting public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</perPixelLighting>
		<additiveLighting public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>In the additive lighting model (by default), the lights are added after the ambient.
		In the new non additive ligthning model, the lights will be modulated against the ambient, so an ambient of 1 will reduce lights intensities to 0.</haxe_doc>
		</additiveLighting>
		<get_additiveLighting set="method" line="23"><f a=""><x path="Bool"/></f></get_additiveLighting>
		<set_additiveLighting set="method" line="27"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_additiveLighting>
		<initLights public="1" set="method" line="31" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></initLights>
		<initGlobals public="1" set="method" line="37" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></initGlobals>
		<sortLight set="method" line="42"><f a="l1:l2">
	<c path="h3d.scene.Light"/>
	<c path="h3d.scene.Light"/>
	<x path="Int"/>
</f></sortLight>
		<computeLight public="1" set="method" line="48" override="1"><f a="obj:shaders">
	<c path="h3d.scene.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></computeLight>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene.fwd._Renderer.SMap" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/fwd/Renderer.hx" private="1" module="h3d.scene.fwd.Renderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene.fwd._Renderer.SMap.T"/>
</t></typedef>
	<class path="h3d.scene.fwd.DepthPass" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/fwd/Renderer.hx" module="h3d.scene.fwd.Renderer">
		<extends path="h3d.pass.Default"/>
		<depthMapId><x path="Int"/></depthMapId>
		<enableSky public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</enableSky>
		<getOutputs set="method" line="15" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="19" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.NormalPass" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/fwd/Renderer.hx" module="h3d.scene.fwd.Renderer">
		<extends path="h3d.pass.Default"/>
		<normalMapId><x path="Int"/></normalMapId>
		<getOutputs set="method" line="39" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="43" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.Renderer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/scene/fwd/Renderer.hx">
		<extends path="h3d.scene.Renderer"/>
		<def get="accessor" set="null"><c path="h3d.pass.Base"/></def>
		<depth public="1" expr="new DepthPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new DepthPass()</e></m></meta>
		</depth>
		<normal public="1" expr="new NormalPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new NormalPass()</e></m></meta>
		</normal>
		<shadow public="1" expr="new h3d.pass.DefaultShadowMap(1024)">
			<c path="h3d.pass.DefaultShadowMap"/>
			<meta><m n=":value"><e>new h3d.pass.DefaultShadowMap(1024)</e></m></meta>
		</shadow>
		<get_def get="inline" set="null" line="67"><f a=""><c path="h3d.pass.Base"/></f></get_def>
		<renderPass set="method" line="70"><f a="p:passes:?sort">
	<c path="h3d.pass.Base"/>
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></renderPass>
		<getPassByName public="1" set="method" line="74" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Base"/>
</f></getPassByName>
		<render set="method" line="80" override="1"><f a=""><x path="Void"/></f></render>
		<new public="1" set="method" line="61"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.AmbientLight" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/AmbientLight.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var global:{ var ambientLight : Vec3; @const
	var perPixelLighting : Bool};
	var pixelColor:Vec4;
	var lightPixelColor:Vec3;
	var lightColor:Vec3;
	@const var additive:Bool;
	function __init__() {
		lightColor = additive ? global.ambientLight : vec3(0.);
	};
	function __init__fragment() {
		lightPixelColor = additive ? global.ambientLight : vec3(0.);
	};
	function calcLight(lightColor:Vec3):Vec3 {
		return additive ? lightColor : (global.ambientLight + (1 - global.ambientLight).max(0.) * lightColor);
	};
	function vertex() {
		if (!global.perPixelLighting) pixelColor.rgb *= calcLight(lightColor);
	};
	function fragment() {
		if (global.perPixelLighting) pixelColor.rgb *= calcLight(lightPixelColor);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Base2d" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Base2d.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEWgzZC5zaGFkZXIuQmFzZTJkGgEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCHZpZXdwb3J0BQwCAAAcDm91dHB1dFBvc2l0aW9uBQwEAAAdCF9faW5pdF9fDgYAAB4GdmVydGV4DgYAAB8IZnJhZ21lbnQOBgAAAwIdAAAFBgYEAgsFDAkDKg4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIQ4CAgoKAg8FCgUMBQwGgQINBQwCDgUMBQwAAB4AAAUFCCADdG1wBQsEAAAJAykOAgoCDAUMEQAFCgEDAAAAAAAA8D8DBQsABgQCHAUMCQMqDgMJAx0OAgIgBQsCFAULAwkDHQ4CAiAFCwIVBQsDCgIMBQw5AAUKBQwFDAYECgIcBQwRAAUKBgEEBgAKAhwFDBEABQoKAhsFDBEABQoFCgUKCgIbBQw5AAUKBQoFCgsCGQIGgwoCHAUMEQAFCgIaBQoFCgAABgQCBgUMAhwFDAUMAAEfAAAFAgsGDgIYAgYJCgINBQwMAAMBA/yp8dJNYlA/AwICDAAAAAYEAgcFDAINBQwFDAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEWgzZC5zaGFkZXIuQmFzZTJkGgEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCHZpZXdwb3J0BQwCAAAcDm91dHB1dFBvc2l0aW9uBQwEAAAdCF9faW5pdF9fDgYAAB4GdmVydGV4DgYAAB8IZnJhZ21lbnQOBgAAAwIdAAAFBgYEAgsFDAkDKg4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIQ4CAgoKAg8FCgUMBQwGgQINBQwCDgUMBQwAAB4AAAUFCCADdG1wBQsEAAAJAykOAgoCDAUMEQAFCgEDAAAAAAAA8D8DBQsABgQCHAUMCQMqDgMJAx0OAgIgBQsCFAULAwkDHQ4CAiAFCwIVBQsDCgIMBQw5AAUKBQwFDAYECgIcBQwRAAUKBgEEBgAKAhwFDBEABQoKAhsFDBEABQoFCgUKCgIbBQw5AAUKBQoFCgsCGQIGgwoCHAUMEQAFCgIaBQoFCgAABgQCBgUMAhwFDAUMAAEfAAAFAgsGDgIYAgYJCgINBQwMAAMBA/yp8dJNYlA/AwICDAAAAAYEAgcFDAINBQwFDAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<zValue public="1" get="accessor" set="accessor"><x path="Float"/></zValue>
		<zValue__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</zValue__>
		<get_zValue get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_zValue>
		<set_zValue get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_zValue>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<isRelative public="1" get="accessor" set="accessor"><x path="Bool"/></isRelative>
		<isRelative__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isRelative__>
		<get_isRelative get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isRelative>
		<set_isRelative get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isRelative>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<absoluteMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixA>
		<absoluteMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixA__>
		<get_absoluteMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixA>
		<set_absoluteMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixA>
		<absoluteMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixB>
		<absoluteMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixB__>
		<get_absoluteMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixB>
		<set_absoluteMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixB>
		<filterMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixA>
		<filterMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixA__>
		<get_filterMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixA>
		<set_filterMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixA>
		<filterMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixB>
		<filterMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixB__>
		<get_filterMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixB>
		<set_filterMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixB>
		<hasUVPos public="1" get="accessor" set="accessor"><x path="Bool"/></hasUVPos>
		<hasUVPos__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasUVPos__>
		<get_hasUVPos get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasUVPos>
		<set_hasUVPos get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasUVPos>
		<uvPos public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvPos>
		<uvPos__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvPos__>
		<get_uvPos get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvPos>
		<set_uvPos get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvPos>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<pixelAlign public="1" get="accessor" set="accessor"><x path="Bool"/></pixelAlign>
		<pixelAlign__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</pixelAlign__>
		<get_pixelAlign get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixelAlign>
		<set_pixelAlign get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixelAlign>
		<halfPixelInverse public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></halfPixelInverse>
		<halfPixelInverse__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</halfPixelInverse__>
		<get_halfPixelInverse get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_halfPixelInverse>
		<set_halfPixelInverse get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_halfPixelInverse>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var position : Vec2; var uv : Vec2; var color : Vec4};
	var output:{ var position : Vec4; var color : Vec4};
	@global var time:Float;
	@param var zValue:Float;
	@param var texture:Sampler2D;
	var spritePosition:Vec4;
	var absolutePosition:Vec4;
	var pixelColor:Vec4;
	var textureColor:Vec4;
	@var var calculatedUV:Vec2;
	@const var isRelative:Bool;
	@param var color:Vec4;
	@param var absoluteMatrixA:Vec3;
	@param var absoluteMatrixB:Vec3;
	@param var filterMatrixA:Vec3;
	@param var filterMatrixB:Vec3;
	@const var hasUVPos:Bool;
	@param var uvPos:Vec4;
	@const var killAlpha:Bool;
	@const var pixelAlign:Bool;
	@param var halfPixelInverse:Vec2;
	@param var viewport:Vec4;
	var outputPosition:Vec4;
	function __init__() {
		spritePosition = vec4(input.position, zValue, 1);
		if (isRelative) {
			absolutePosition.x = vec3(spritePosition.xy, 1).dot(absoluteMatrixA);
			absolutePosition.y = vec3(spritePosition.xy, 1).dot(absoluteMatrixB);
			absolutePosition.zw = spritePosition.zw;
		} else absolutePosition = spritePosition;
		calculatedUV = hasUVPos ? input.uv * uvPos.zw + uvPos.xy : input.uv;
		pixelColor = isRelative ? color * input.color : input.color;
		textureColor = texture.get(calculatedUV);
		pixelColor *= textureColor;
	};
	function vertex() {
		var tmp = vec3(absolutePosition.xy, 1);
		outputPosition = vec4(tmp.dot(filterMatrixA), tmp.dot(filterMatrixB), absolutePosition.zw);
		outputPosition.xy = (outputPosition.xy + viewport.xy) * viewport.zw;
		if (pixelAlign) outputPosition.xy -= halfPixelInverse;
		output.position = outputPosition;
	};
	function fragment() {
		if (killAlpha && pixelColor.a < 0.001) discard;
		output.color = pixelColor;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.BaseMesh" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/BaseMesh.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<specularPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularPower__>
		<get_specularPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularPower>
		<set_specularPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularPower>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularAmount__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularAmount__>
		<get_specularAmount get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAmount>
		<set_specularAmount get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAmount>
		<specularColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></specularColor>
		<specularColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularColor__>
		<get_specularColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularColor>
		<set_specularColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularColor>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var position : Vec3; var projFlip : Float; var projDiag : Vec3; var viewProj : Mat4; var inverseViewProj : Mat4; var zNear : Float; var zFar : Float; @var
	var dir : Vec3};
	@global var global:{ var time : Float; var pixelSize : Vec2; @perObject
	var modelView : Mat4; @perObject
	var modelViewInverse : Mat4};
	@input var input:{ var position : Vec3; var normal : Vec3};
	var output:{ var position : Vec4; var color : Vec4; var depth : Float; var normal : Vec3; var worldDist : Float};
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	var transformedNormal:Vec3;
	var projectedPosition:Vec4;
	var pixelColor:Vec4;
	var depth:Float;
	var screenUV:Vec2;
	var specPower:Float;
	var specColor:Vec3;
	var worldDist:Float;
	@param var color:Vec4;
	@range(0, 100) @param var specularPower:Float;
	@range(0, 10) @param var specularAmount:Float;
	@param var specularColor:Vec3;
	function __init__() {
		relativePosition = input.position;
		transformedPosition = relativePosition * global.modelView.mat3x4();
		projectedPosition = vec4(transformedPosition, 1) * camera.viewProj;
		transformedNormal = (input.normal * global.modelView.mat3()).normalize();
		camera.dir = (camera.position - transformedPosition).normalize();
		pixelColor = color;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		worldDist = length(transformedPosition - camera.position) / camera.zFar;
	};
	function __init__fragment() {
		transformedNormal = transformedNormal.normalize();
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
	};
	function vertex() {
		output.position = projectedPosition * vec4(1, camera.projFlip, 1, 1);
		pixelTransformedPosition = transformedPosition;
	};
	function fragment() {
		output.color = pixelColor;
		output.depth = depth;
		output.normal = transformedNormal;
		output.worldDist = worldDist;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Blur" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Blur.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<cameraInverseViewProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cameraInverseViewProj>
		<cameraInverseViewProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cameraInverseViewProj__>
		<get_cameraInverseViewProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameraInverseViewProj>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<depthTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></depthTexture>
		<depthTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</depthTexture__>
		<get_depthTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_depthTexture>
		<set_depthTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_depthTexture>
		<Quality public="1" get="accessor" set="accessor"><x path="Int"/></Quality>
		<Quality__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</Quality__>
		<get_Quality get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Quality>
		<set_Quality get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Quality>
		<isDepth public="1" get="accessor" set="accessor"><x path="Bool"/></isDepth>
		<isDepth__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepth__>
		<get_isDepth get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepth>
		<set_isDepth get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepth>
		<values public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></values>
		<values__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</values__>
		<get_values get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_values>
		<set_values get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_values>
		<offsets public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></offsets>
		<offsets__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</offsets__>
		<get_offsets get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_offsets>
		<set_offsets get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_offsets>
		<pixel public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></pixel>
		<pixel__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pixel__>
		<get_pixel get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixel>
		<set_pixel get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixel>
		<hasFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></hasFixedColor>
		<hasFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasFixedColor__>
		<get_hasFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasFixedColor>
		<set_hasFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasFixedColor>
		<smoothFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></smoothFixedColor>
		<smoothFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</smoothFixedColor__>
		<get_smoothFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_smoothFixedColor>
		<set_smoothFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_smoothFixedColor>
		<fixedColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></fixedColor>
		<fixedColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</fixedColor__>
		<get_fixedColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fixedColor>
		<set_fixedColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fixedColor>
		<isDepthDependant public="1" get="accessor" set="accessor"><x path="Bool"/></isDepthDependant>
		<isDepthDependant__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepthDependant__>
		<get_isDepthDependant get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepthDependant>
		<set_isDepthDependant get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepthDependant>
		<hasNormal public="1" get="accessor" set="accessor"><x path="Bool"/></hasNormal>
		<hasNormal__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasNormal__>
		<get_hasNormal get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasNormal>
		<set_hasNormal get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasNormal>
		<normalTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></normalTexture>
		<normalTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</normalTexture__>
		<get_normalTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normalTexture>
		<set_normalTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normalTexture>
		<isCube public="1" get="accessor" set="accessor"><x path="Bool"/></isCube>
		<isCube__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isCube__>
		<get_isCube get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCube>
		<set_isCube get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCube>
		<cubeTexture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></cubeTexture>
		<cubeTexture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</cubeTexture__>
		<get_cubeTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeTexture>
		<set_cubeTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeTexture>
		<cubeDir public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cubeDir>
		<cubeDir__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cubeDir__>
		<get_cubeDir get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeDir>
		<set_cubeDir get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeDir>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var cameraInverseViewProj:Mat4;
	@param var texture:Sampler2D;
	@param var depthTexture:Sampler2D;
	@param @const var Quality:Int;
	@param @const var isDepth:Bool;
	@param var values:Array<Float,Quality>;
	@param var offsets:Array<Float,Quality>;
	@param var pixel:Vec2;
	@const var hasFixedColor:Bool;
	@const var smoothFixedColor:Bool;
	@param var fixedColor:Vec4;
	@param @const var isDepthDependant:Bool;
	@param @const var hasNormal:Bool;
	@param var normalTexture:Sampler2D;
	@param @const var isCube:Bool;
	@param var cubeTexture:SamplerCube;
	@param var cubeDir:Mat3;
	function fragment() {
		if (isDepthDependant) {
			var pcur = getPosition(input.uv);
			var ccur = texture.get(input.uv);
			var color = vec4(0, 0, 0, 0);
			var ncur = unpackNormal(normalTexture.get(input.uv));
			@unroll for (i  in  -Quality + 1 ... Quality) {
				var uv = input.uv + pixel * offsets[i < 0 ? -i : i];
				var c = texture.get(uv);
				var p = getPosition(uv);
				var d = (p - pcur).dot(p - pcur);
				var n = unpackNormal(normalTexture.get(uv));
				c = mix(ccur, c, ncur.dot(n));
				c = mix(c, ccur, ((d - 0.001).max(0.) * 100000).min(1.));
				color += c * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		} else if (isDepth) {
			var val = 0.;
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) val += unpack(cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir)) * values[i < 0 ? -i : i] else val += unpack(texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i)) * values[i < 0 ? -i : i];
			};
			pixelColor = pack(val.min(0.9999999));
		} else {
			var color = vec4(0, 0, 0, 0);
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) color += cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir) * values[i < 0 ? -i : i] else color += texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i) * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		};
		if (hasFixedColor) {
			if (smoothFixedColor) pixelColor.a *= fixedColor.a else pixelColor.a = fixedColor.a * float(pixelColor.a > 0);
			pixelColor.rgb = fixedColor.rgb * pixelColor.a;
		};
	};
	function getPosition(uv:Vec2):Vec3 {
		var depth = unpack(depthTexture.get(uv));
		var temp = vec4(uvToScreen(uv), depth, 1) * cameraInverseViewProj;
		var originWS = temp.xyz / temp.w;
		return originWS;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<abstract path="h3d.shader.BufferKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1" final="1">
	<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Globals>
	<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Params>
	<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Textures>
	<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Buffers>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1" final="1">
		<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Globals>
		<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Params>
		<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Textures>
		<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Buffers>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.shader.ShaderBufferData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers"><t path="hxd.impl.Float32Array"/></typedef>
	<class path="h3d.shader.ShaderBuffers" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<globals public="1"><t path="h3d.shader.ShaderBufferData"/></globals>
		<params public="1"><t path="h3d.shader.ShaderBufferData"/></params>
		<tex public="1"><x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x></tex>
		<buffers public="1"><x path="haxe.ds.Vector"><c path="h3d.Buffer"/></x></buffers>
		<grow public="1" set="method" line="26"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="19"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.Buffers" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Buffers.hx">
		<vertex public="1"><c path="h3d.shader.ShaderBuffers"/></vertex>
		<fragment public="1"><c path="h3d.shader.ShaderBuffers"/></fragment>
		<grow public="1" get="inline" set="null" line="49"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="44"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.ColorAdd" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/ColorAdd.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16">
			<f a="?color" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var color:Vec3;
	function fragment() {
		pixelColor.rgb += color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorKey" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/ColorKey.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorKey public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorKey>
		<colorKey__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorKey__>
		<get_colorKey get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorKey>
		<set_colorKey get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorKey>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15">
			<f a="?v" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var colorKey:Vec4;
	var textureColor:Vec4;
	function fragment() {
		var cdiff = textureColor - colorKey;
		if (cdiff.dot(cdiff) < 0.00001) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorMatrix" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/ColorMatrix.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<matrix public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></matrix>
		<matrix__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matrix__>
		<get_matrix get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_matrix>
		<set_matrix get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_matrix>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a="?m">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var matrix:Mat4;
	function fragment() {
		pixelColor = vec4((vec4(pixelColor.rgb, 1.) * matrix).rgb, (pixelColor * matrix).a);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.DirShadow" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/DirShadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<enable public="1" get="accessor" set="accessor"><x path="Bool"/></enable>
		<enable__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</enable__>
		<get_enable get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_enable>
		<set_enable get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_enable>
		<USE_ESM public="1" get="accessor" set="accessor"><x path="Bool"/></USE_ESM>
		<USE_ESM__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</USE_ESM__>
		<get_USE_ESM get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_USE_ESM>
		<set_USE_ESM get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_USE_ESM>
		<shadowPower public="1" get="accessor" set="accessor"><x path="Float"/></shadowPower>
		<shadowPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowPower__>
		<get_shadowPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowPower>
		<set_shadowPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowPower>
		<USE_PCF public="1" get="accessor" set="accessor"><x path="Bool"/></USE_PCF>
		<USE_PCF__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</USE_PCF__>
		<get_USE_PCF get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_USE_PCF>
		<set_USE_PCF get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_USE_PCF>
		<pcfQuality public="1" get="accessor" set="accessor"><x path="Int"/></pcfQuality>
		<pcfQuality__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pcfQuality__>
		<get_pcfQuality get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pcfQuality>
		<set_pcfQuality get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pcfQuality>
		<pcfScale public="1" get="accessor" set="accessor"><x path="Float"/></pcfScale>
		<pcfScale__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pcfScale__>
		<get_pcfScale get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pcfScale>
		<set_pcfScale get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pcfScale>
		<shadowRes public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></shadowRes>
		<shadowRes__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowRes__>
		<get_shadowRes get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowRes>
		<set_shadowRes get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowRes>
		<shadowMap public="1" get="accessor" set="accessor"><t path="hxsl.ChannelTextureType"/></shadowMap>
		<shadowMap__>
			<t path="hxsl.ChannelTextureType"/>
			<meta><m n=":noCompletion"/></meta>
		</shadowMap__>
		<get_shadowMap get="inline" set="null" line="5">
			<f a=""><t path="hxsl.ChannelTextureType"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowMap>
		<set_shadowMap get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.ChannelTextureType"/>
				<t path="hxsl.ChannelTextureType"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowMap>
		<shadowMapChannel__ expr="Unknown">
			<e path="hxsl.Channel"/>
			<meta><m n=":value"><e>Unknown</e></m></meta>
		</shadowMapChannel__>
		<shadowMapChannel public="1" get="accessor" set="accessor"><e path="hxsl.Channel"/></shadowMapChannel>
		<get_shadowMapChannel get="inline" set="null" line="215"><f a=""><e path="hxsl.Channel"/></f></get_shadowMapChannel>
		<set_shadowMapChannel get="inline" set="null" line="216"><f a="v">
	<e path="hxsl.Channel"/>
	<e path="hxsl.Channel"/>
</f></set_shadowMapChannel>
		<shadowProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></shadowProj>
		<shadowProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowProj__>
		<get_shadowProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowProj>
		<set_shadowProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowProj>
		<shadowBias public="1" get="accessor" set="accessor"><x path="Float"/></shadowBias>
		<shadowBias__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowBias__>
		<get_shadowBias get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowBias>
		<set_shadowBias get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowBias>
		<poissonDiskLow public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskLow>
		<poissonDiskLow__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskLow__>
		<get_poissonDiskLow get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskLow>
		<set_poissonDiskLow get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskLow>
		<poissonDiskHigh public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskHigh>
		<poissonDiskHigh__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskHigh__>
		<get_poissonDiskHigh get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskHigh>
		<set_poissonDiskHigh get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskHigh>
		<poissonDiskVeryHigh public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskVeryHigh>
		<poissonDiskVeryHigh__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskVeryHigh__>
		<get_poissonDiskVeryHigh get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskVeryHigh>
		<set_poissonDiskVeryHigh get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskVeryHigh>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="93"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const var enable:Bool;
	@const var USE_ESM:Bool;
	@param var shadowPower:Float;
	@const var USE_PCF:Bool;
	@const var pcfQuality:Int;
	@param var pcfScale:Float;
	@param var shadowRes:Vec2;
	@param var shadowMap:Channel;
	@param var shadowProj:Mat3x4;
	@param var shadowBias:Float;
	var transformedPosition:Vec3;
	var shadow:Float;
	var dirShadow:Float;
	@param var poissonDiskLow:Array<Vec4,4>;
	@param var poissonDiskHigh:Array<Vec4,12>;
	@param var poissonDiskVeryHigh:Array<Vec4,64>;
	function rand(v:Float):Float {
		var dp = dot(vec4(v), vec4(12.9898, 78.233, 45.164, 94.673));
		return fract(sin(dp) * 43758.5453);
	};
	function fragment() {
		if (enable) {
			if (USE_PCF) {
				shadow = 1.0;
				var texelSize = 1.0 / shadowRes;
				var shadowPos = transformedPosition * shadowProj;
				var shadowUv = screenToUv(shadowPos.xy);
				var zMax = shadowPos.z.saturate();
				var rot = rand(transformedPosition.x + transformedPosition.y + transformedPosition.z) * 3.14 * 2;
				switch (pcfQuality) {
					case 1:
						var sampleStrength = 1.0 / 4.0;
						for (i  in  0 ... 4) {
							var offset = poissonDiskLow[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
					case 2:
						var sampleStrength = 1.0 / 12.0;
						for (i  in  0 ... 12) {
							var offset = poissonDiskHigh[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
					case 3:
						var sampleStrength = 1.0 / 64.0;
						for (i  in  0 ... 64) {
							var offset = poissonDiskVeryHigh[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
				};
			} else if (USE_ESM) {
				var shadowPos = transformedPosition * shadowProj;
				var depth = shadowMap.get(screenToUv(shadowPos.xy));
				var zMax = shadowPos.z.saturate();
				var delta = (depth + shadowBias).min(zMax) - zMax;
				shadow = exp(shadowPower * delta).saturate();
			} else {
				var shadowPos = transformedPosition * shadowProj;
				var shadowUv = screenToUv(shadowPos.xy);
				var depth = shadowMap.get(shadowUv.xy);
				shadow = shadowPos.z - shadowBias > depth ? 0 : 1;
			};
		};
		dirShadow = shadow;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.GenTexture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/GenTexture.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<mode public="1" get="accessor" set="accessor"><x path="Int"/></mode>
		<mode__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mode__>
		<get_mode get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mode>
		<set_mode get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mode>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const var mode:Int;
	@param var color:Vec4;
	function fragment() {
		switch (mode) {
			case 0:
				pixelColor = output.position.xy.length() > 1 ? vec4(0.) : color;			
		};
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.LineShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/LineShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<lengthScale public="1" get="accessor" set="accessor"><x path="Float"/></lengthScale>
		<lengthScale__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</lengthScale__>
		<get_lengthScale get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthScale>
		<set_lengthScale get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lengthScale>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<width__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</width__>
		<get_width get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="53">
			<f a="?width:?lengthScale" v="1.5:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lengthScale : 1., width : 1.5 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var viewProj : Mat4};
	@global var global:{ var pixelSize : Vec2; @perObject
	var modelView : Mat4};
	@input var input:{ var position : Vec3; var normal : Vec3; var uv : Vec2};
	var output:{ var position : Vec4};
	var transformedNormal:Vec3;
	var transformedPosition:Vec3;
	var projectedPosition:Vec4;
	@param var lengthScale:Float;
	@param var width:Float;
	var pdir:Vec4;
	function __init__() {
		{
			var dir = input.normal * global.modelView.mat3();
			pdir = vec4(dir * mat3(camera.view), 1) * camera.proj;
			pdir.xy *= 1 / sqrt(pdir.x * pdir.x + pdir.y * pdir.y);
			transformedPosition += dir * input.uv.x * lengthScale;
			transformedNormal = dir.normalize();
		};
	};
	function vertex() {
		projectedPosition.xy += (pdir.yx * vec2(1, -1)) * (input.uv.y - 0.5) * projectedPosition.z * global.pixelSize * width;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.MinMaxShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/MinMaxShader.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texA>
		<texA__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texB>
		<texB__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texA:Sampler2D;
	@param var texB:Sampler2D;
	@const var isMax:Bool;
	function fragment() {
		var a = texA.get(calculatedUV);
		var b = texB.get(calculatedUV);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.CubeMinMaxShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/MinMaxShader.hx" module="h3d.shader.MinMaxShader">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA&quot;" line="21" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texA>
		<texA__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texB>
		<texB__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="21">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="21">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="21">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="21" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@param var texA:SamplerCube;
	@param var texB:SamplerCube;
	@const var isMax:Bool;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		var dir = vec3(uv, 1) * mat;
		var a = texA.get(dir);
		var b = texB.get(dir);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.NormalMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/NormalMap.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="43"><f a="?texture">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@global var camera:{ var position : Vec3; @var
	var dir : Vec3};
	@global var global:{ @perObject
	var modelView : Mat4};
	@input var input:{ var normal : Vec3; var tangent : Vec3};
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@var var transformedTangent:Vec4;
	function __init__vertex() {
		transformedTangent = vec4(input.tangent * global.modelView.mat3(), input.tangent.dot(input.tangent) > 0.5 ? 1. : -1.);
	};
	function fragment() {
		var n = transformedNormal;
		var nf = unpackNormal(texture.get(calculatedUV));
		var tanX = transformedTangent.xyz.normalize();
		var tanY = n.cross(tanX) * -transformedTangent.w;
		transformedNormal = (nf.x * tanX + nf.y * tanY + nf.z * n).normalize();
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Shadow" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Shadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var shadow:{ var map : Channel; var proj : Mat3x4; var color : Vec3; var power : Float; var bias : Float};
	var pixelColor:Vec4;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	@private var shadowPos:Vec3;
	function fragment() {
		var shadowPos = pixelTransformedPosition * shadow.proj;
		var depth = shadow.map.get(screenToUv(shadowPos.xy));
		var zMax = shadowPos.z.saturate();
		var delta = (depth + shadow.bias).min(zMax) - zMax;
		var shade = exp(shadow.power * delta).saturate();
		pixelColor.rgb *= (1 - shade) * shadow.color.rgb + shade;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinBase" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/SkinBase.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<MaxBones public="1" get="accessor" set="accessor"><x path="Int"/></MaxBones>
		<MaxBones__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MaxBones__>
		<get_MaxBones get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_MaxBones>
		<set_MaxBones get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_MaxBones>
		<bonesMatrixes public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Matrix"/></c></bonesMatrixes>
		<bonesMatrixes__ expr="new Array()">
			<c path="Array"><t path="hxsl.Matrix"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</bonesMatrixes__>
		<get_bonesMatrixes get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Matrix"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bonesMatrixes>
		<set_bonesMatrixes get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Matrix"/></c>
				<c path="Array"><t path="hxsl.Matrix"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bonesMatrixes>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@const var MaxBones:Int;
	@ignore @param var bonesMatrixes:Array<Mat3x4,MaxBones>;
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Skin" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Skin.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAAAAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCgkEAAAABAABCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAgAAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAAAAABCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgIKCQQAAAAEAAEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAACAABCAYFCwULCgIJBQsIAAMFCwULBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAAAAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCgkEAAAABAABCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAgAAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAAAAABCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgIKCQQAAAAEAAEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAACAABCAYFCwULCgIJBQsIAAMFCwULBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinTangent" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/SkinTangent.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAAAAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCwkEAAAABAABCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAgAAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgILCQQAAAAEAAEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAACAABCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAQAAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAgAAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAAAAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCwkEAAAABAABCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAgAAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgILCQQAAAAEAAEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAACAABCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAQAAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAgAAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var tangent : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
		transformedTangent = vec4(normalize((input.tangent.xyz * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z), transformedTangent.w);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SpecularTexture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/SpecularTexture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a="?tex">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var specColor:Vec3;
	function fragment() {
		specColor *= texture.get(calculatedUV).rgb;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Texture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/Texture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<specularAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></specularAlpha>
		<specularAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</specularAlpha__>
		<get_specularAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAlpha>
		<set_specularAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAlpha>
		<killAlphaThreshold public="1" get="accessor" set="accessor"><x path="Float"/></killAlphaThreshold>
		<killAlphaThreshold__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</killAlphaThreshold__>
		<get_killAlphaThreshold get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlphaThreshold>
		<set_killAlphaThreshold get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlphaThreshold>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="37"><f a="?tex">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var uv : Vec2};
	@const var additive:Bool;
	@const var killAlpha:Bool;
	@const var specularAlpha:Bool;
	@range(0, 1) @param var killAlphaThreshold:Float;
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var pixelColor:Vec4;
	var specColor:Vec3;
	function vertex() {
		calculatedUV = input.uv;
	};
	function fragment() {
		var c = texture.get(calculatedUV);
		if (killAlpha && c.a - killAlphaThreshold < 0) discard;
		if (additive) pixelColor += c else pixelColor *= c;
		if (specularAlpha) specColor *= c.aaa;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.UVDelta" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/UVDelta.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<uvDelta public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvDelta>
		<uvDelta__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvDelta__>
		<get_uvDelta get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvDelta>
		<set_uvDelta get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvDelta>
		<uvScale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvScale>
		<uvScale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvScale__>
		<get_uvScale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvScale>
		<set_uvScale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvScale>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="14">
			<f a="?dx:?dy:?sx:?sy" v="0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sy : 1., sx : 1., dy : 0., dx : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var uvDelta:Vec2;
	@param var uvScale:Vec2;
	var calculatedUV:Vec2;
	function vertex() {
		calculatedUV = calculatedUV * uvScale + uvDelta;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VertexColorAlpha" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/VertexColorAlpha.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var color : Vec4};
	var pixelColor:Vec4;
	@const var additive:Bool;
	function fragment() {
		if (additive) pixelColor += input.color else pixelColor *= input.color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VolumeDecal" params="" file="/usr/local/lib/haxeLibrary/heaps/git/h3d/shader/VolumeDecal.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<scale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></scale>
		<scale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</scale__>
		<get_scale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<set_scale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scale>
		<normal public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></normal>
		<normal__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</normal__>
		<get_normal get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normal>
		<set_normal get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normal>
		<tangent public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></tangent>
		<tangent__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</tangent__>
		<get_tangent get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_tangent>
		<set_tangent get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_tangent>
		<isCentered public="1" get="accessor" set="accessor"><x path="Bool"/></isCentered>
		<isCentered__ expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isCentered__>
		<get_isCentered get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCentered>
		<set_isCentered get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCentered>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="42"><f a="objectWidth:objectHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@:import BaseMesh;
	@global var depthMap:Channel;
	@param var scale:Vec2;
	@param var normal:Vec3;
	@param var tangent:Vec3;
	@const var isCentered:Bool = true;
	var calculatedUV:Vec2;
	var transformedTangent:Vec4;
	function __init__vertex() {
		transformedNormal = (normal * global.modelView.mat3()).normalize();
		transformedTangent = vec4((tangent * global.modelView.mat3()).normalize(), 1.);
	};
	function fragment() {
		var matrix = camera.inverseViewProj * global.modelViewInverse;
		var screenPos = projectedPosition.xy / projectedPosition.w;
		var ruv = vec4(screenPos, depthMap.get(screenToUv(screenPos)), 1);
		var wpos = ruv * matrix;
		var ppos = ruv * camera.inverseViewProj;
		pixelTransformedPosition = ppos.xyz / ppos.w;
		calculatedUV = scale * (wpos.xy / wpos.w);
		if (isCentered) calculatedUV += 0.5;
		if (min(min(calculatedUV.x, calculatedUV.y), min(1 - calculatedUV.x, 1 - calculatedUV.y)) < 0) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/local/lib/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/usr/local/lib/haxe/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<callStack public="1" set="method" line="51" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
	</callStack>
	<exceptionStack public="1" set="method" line="62" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
	</exceptionStack>
	<toString public="1" set="method" line="70" static="1">
		<f a="stack">
			<x path="haxe.CallStack"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
	</toString>
	<subtract public="1" set="method" line="83" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<equalItems set="method" line="118" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<itemToString set="method" line="154" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<callStack public="1" set="method" line="51" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="62" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="70" static="1">
			<f a="stack">
				<x path="haxe.CallStack"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<subtract public="1" set="method" line="83" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<equalItems set="method" line="118" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<itemToString set="method" line="154" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="sys.thread.Mutex" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/thread/Mutex.hx">
		<m><d/></m>
		<acquire public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>The current thread acquire the mutex or wait if not available.
		The same thread can acquire several times the same mutex but
		must release it as many times it has been acquired.</haxe_doc>
		</acquire>
		<release public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Release a mutex that has been acquired by the current thread.
		The behavior is undefined if the current thread does not own
		the mutex.</haxe_doc>
		</release>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a mutex.</haxe_doc>
		</new>
		<haxe_doc>Creates a mutex, which can be used to acquire a temporary lock
	to access some ressource. The main difference with a lock is
	that a mutex must always be released by the owner thread.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread.Lock" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/thread/Lock.hx">
		<l><d/></l>
		<wait public="1" set="method" line="33">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ timeout : -1 }</e></m>
			</meta>
			<haxe_doc>Waits for the lock to be released, or `timeout` (in seconds)
		to expire. Returns `true` if the lock is released and `false`
		if a time-out occurs.</haxe_doc>
		</wait>
		<release public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Releases the lock once.

		The thread does not need to own the lock in order to release
		it. Each call to `release` allows exactly one call to `wait`
		to execute.</haxe_doc>
		</release>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new Lock which is initially locked.</haxe_doc>
		</new>
		<haxe_doc>A Lock allows blocking execution until it has been unlocked. It keeps track
	of how often `release` has been called, and blocks exactly as many `wait`
	calls.

	The order of the `release` and `wait` calls is irrelevant. That is, a Lock
	can be released before anyone waits for it. In that case, the `wait` call
	will execute immediately.

	Usage example:

	```haxe
	var lock = new Lock();
	var elements = [1, 2, 3];
	for (element in elements) {
		// Create one thread per element
		new Thread(function() {
			trace(element);
			Sys.sleep(1);
			// Release once per thread = 3 times
			lock.release();
		});
	}
	for (_ in elements) {
		// Wait 3 times
		lock.wait();
	}
	trace("All threads finished");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="/usr/local/lib/haxe/std/haxe/EntryPoint.hx">
		<sleepLock expr="new Lock()" line="37" static="1">
			<c path="sys.thread.Lock"/>
			<meta><m n=":value"><e>new Lock()</e></m></meta>
		</sleepLock>
		<mutex expr="new Mutex()" line="38" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mutex>
		<pending expr="new Array&lt;Void&gt;()" line="40" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Array<Void>()]]></e></m></meta>
		</pending>
		<threadCount public="1" set="null" expr="0" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</threadCount>
		<processEvents set="method" line="85" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="108" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="/usr/local/lib/haxe/std/haxe/EnumFlags.hx">
		<this><x path="Int"/></this>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.

	Enum constructor indices are preserved from Haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as `has(EnumCtor)`. Otherwise
	`Type.enumIndex()` reflection is used.</haxe_doc>
		<impl><class path="haxe._EnumFlags.EnumFlags_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/EnumFlags.hx" private="1" module="haxe.EnumFlags" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Exception.hx">
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="26" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="48"><f a=""><x path="Any"/></f></unwrap>
		<get_native final="1" set="method" line="74"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="36">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe._Int64.___Int64" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" extern="1">
		<make public="1" set="method" static="1">
			<f a="high:low">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_make"</e></m></meta>
		</make>
		<ofInt public="1" set="method" static="1">
			<f a="value">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct"</e></m></meta>
		</ofInt>
		<isInt64 public="1" set="method" static="1">
			<f a="d">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct::is"</e></m></meta>
		</isInt64>
		<isNeg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_neg"</e></m></meta>
		</isNeg>
		<isZero public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_zero"</e></m></meta>
		</isZero>
		<compare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_compare"</e></m></meta>
		</compare>
		<ucompare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ucompare"</e></m></meta>
		</ucompare>
		<toString public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_to_string"</e></m></meta>
		</toString>
		<neg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neg"</e></m></meta>
		</neg>
		<preIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_increment"</e></m></meta>
		</preIncrement>
		<postIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_increment"</e></m></meta>
		</postIncrement>
		<preDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_decrement"</e></m></meta>
		</preDecrement>
		<postDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_decrement"</e></m></meta>
		</postDecrement>
		<add public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</add>
		<addInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</addInt>
		<sub public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</sub>
		<subInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</subInt>
		<intSub public="1" set="method" static="1">
			<f a="a:b">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</intSub>
		<mul public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mul"</e></m></meta>
		</mul>
		<div public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_div"</e></m></meta>
		</div>
		<mod public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mod"</e></m></meta>
		</mod>
		<eq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eq>
		<eqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eqInt>
		<neq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neq>
		<neqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neqInt>
		<complement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_complement"</e></m></meta>
		</complement>
		<bitAnd public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_and"</e></m></meta>
		</bitAnd>
		<bitOr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_or"</e></m></meta>
		</bitOr>
		<bitXor public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_xor"</e></m></meta>
		</bitXor>
		<shl public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shl"</e></m></meta>
		</shl>
		<shr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shr"</e></m></meta>
		</shr>
		<ushr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ushr"</e></m></meta>
		</ushr>
		<high public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_high"</e></m></meta>
		</high>
		<low public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_low"</e></m></meta>
		</low>
		<get public="1" set="method"><f a=""><x path="cpp.Int64"/></f></get>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":notNull"/>
			<m n=":include"><e>"cpp/Int64.h"</e></m>
			<m n=":native"><e>"cpp::Int64Struct"</e></m>
		</meta>
	</class>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64"><c path="haxe._Int64.___Int64"/></typedef>
	<abstract path="haxe.Int64" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.Log" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Log.hx">
		<nativeTrace set="method" static="1">
			<f a="message:posInfo">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__trace"</e></m></meta>
		</nativeTrace>
		<trace public="1" set="dynamic" line="29" static="1">
			<f a="v:?infos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="/usr/local/lib/haxe/std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<stop public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the event from firing anymore.</haxe_doc>
		</stop>
		<new set="method" line="18"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="/usr/local/lib/haxe/std/haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<hasEvents public="1" set="method" line="66" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<add public="1" set="method" line="87" static="1">
			<f a="f:?priority" v=":0">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.MainEvent"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0 }</e></m></meta>
			<haxe_doc>Add a pending event to be run into the main loop.</haxe_doc>
		</add>
		<sortEvents set="method" line="99" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="164" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="16" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</callStack>
		<exceptionStack public="1" set="method" line="21" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</exceptionStack>
		<toHaxe public="1" set="method" line="25" static="1">
			<f a="native:?skip" v=":0">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/local/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Resource" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/Resource.hx">
		<listNames public="1" set="method" line="27" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Lists all available resource names. The resource name is the name part
		of the `--resource file@name` command line parameter.</haxe_doc>
		</listNames>
		<getString public="1" set="method" line="31" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Retrieves the resource identified by `name` as a `String`.

		If `name` does not match any resource name, `null` is returned.</haxe_doc>
		</getString>
		<getBytes public="1" set="method" line="35" static="1">
			<f a="name">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Retrieves the resource identified by `name` as an instance of
		haxe.io.Bytes.

		If `name` does not match any resource name, `null` is returned.</haxe_doc>
		</getBytes>
		<haxe_doc>Resource can be used to access resources that were added through the
	`--resource file@name` command line parameter.

	Depending on their type they can be obtained as `String` through
	`getString(name)`, or as binary data through `getBytes(name)`.

	A list of all available resource names can be obtained from `listNames()`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.Serializer" params="" file="/usr/local/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="72" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<run public="1" set="method" line="582" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

	This is a convenience function for creating a new instance of
	Serializer, serialize `v` into it and obtain the result through a call
	to `toString()`.</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<__getField get="inline" set="null" line="556"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></__getField>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.TimerList" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/haxe/Timer.hx" module="haxe.Timer"><c path="Array"><c path="haxe.Timer"/></c></typedef>
	<class path="nme.app.IPollClient" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/IPollClient.hx" interface="1">
		<onPoll public="1" set="method"><f a="timestamp">
	<x path="Float"/>
	<x path="Void"/>
</f></onPoll>
		<getNextWake public="1" set="method"><f a="defaultWake:timestamp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getNextWake>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="haxe.TimerPollClient" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/haxe/Timer.hx" module="haxe.Timer">
		<implements path="nme.app.IPollClient"/>
		<onPoll public="1" set="method" line="102"><f a="timestamp">
	<x path="Float"/>
	<x path="Void"/>
</f></onPoll>
		<getNextWake public="1" set="method" line="103"><f a="defaultWake:timestamp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getNextWake>
		<new public="1" set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.Timer" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/haxe/Timer.hx">
		<sRunningTimers expr="null" line="110" static="1">
			<t path="haxe.TimerList"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</sRunningTimers>
		<sPollClient expr="null" line="111" static="1">
			<c path="nme.app.IPollClient"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</sPollClient>
		<measure public="1" params="T" set="method" line="134" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<c path="measure.T"/>
</f></measure>
		<nmeGetNextWake public="1" set="method" line="153" static="1">
			<f a="inDefaultWake:inStamp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</nmeGetNextWake>
		<nmeCheckTimers public="1" set="method" line="184" static="1">
			<f a="inStamp">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</nmeCheckTimers>
		<delay public="1" set="method" line="218" static="1"><f a="f:time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="231" static="1"><f a=""><x path="Float"/></f></stamp>
		<nme_time_stamp expr="nme.PrimeLoader.load(&quot;nme_time_stamp&quot;, &quot;d&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Float"/></f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_time_stamp", "d")</e></m></meta>
		</nme_time_stamp>
		<mTime><x path="Float"/></mTime>
		<mFireAt><x path="Float"/></mFireAt>
		<mRunning><x path="Bool"/></mRunning>
		<run public="1" set="dynamic" line="143"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="145"><f a=""><x path="Void"/></f></stop>
		<nmeCheck set="method" line="172"><f a="inTime">
	<x path="Float"/>
	<x path="Void"/>
</f></nmeCheck>
		<new public="1" set="method" line="118"><f a="inTimeMs">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="/usr/local/lib/haxe/std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="476"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="479"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="474"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/local/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="65" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="70" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="72" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="464" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its `unserialize()` method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="144"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="169"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="184"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="199"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="231">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="/usr/local/lib/haxe/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/projects/May2019/May2020/lime/src/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="505" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="535" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns bytes representation of the given String, using specific encoding (UTF-8 by default)</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="597" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<ofHex public="1" set="method" line="614" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Convert hexadecimal string to Bytes.
		Support only straight hex string ( Example: "0FDA14058916052309" )</haxe_doc>
		</ofHex>
		<fastGet public="1" get="inline" set="null" line="635" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="52">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</get>
		<set public="1" get="inline" set="null" line="69">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</set>
		<blit public="1" set="method" line="88"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method" line="127">
			<f a="pos:len:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fill>
		<sub public="1" set="method" line="147"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="175"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<getDouble public="1" get="inline" set="null" line="226">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the IEEE double precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getDouble>
		<getFloat public="1" get="inline" set="null" line="248">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setDouble public="1" set="method" line="272">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Store the IEEE double precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" set="method" line="298">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getUInt16 public="1" get="inline" set="null" line="318">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</getUInt16>
		<setUInt16 public="1" get="inline" set="null" line="330">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="343">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt32>
		<getInt64 public="1" get="inline" set="null" line="361">
			<f a="pos">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt64>
		<setInt32 public="1" get="inline" set="null" line="369">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt32>
		<setInt64 public="1" get="inline" set="null" line="384">
			<f a="pos:v">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt64>
		<getString public="1" set="method" line="390">
			<f a="pos:len:?encoding">
				<x path="Int"/>
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getString>
		<readString public="1" get="inline" set="null" line="455">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"readString is deprecated, use getString instead"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</readString>
		<toString public="1" set="method" line="463">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns string representation of the bytes as UTF8</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="484"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="500"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="43"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="haxe.crypto.Base64" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Base64.hx">
		<CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</CHARS>
		<BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(CHARS)" line="30" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(CHARS)</e></m></meta>
		</BYTES>
		<encode public="1" set="method" line="35" static="1">
			<f a="bytes:?complement" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</encode>
		<decode public="1" set="method" line="48" static="1">
			<f a="str:?complement" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</decode>
		<haxe_doc>Allows one to encode/decode String and bytes using Base64 encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows one to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="120" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="57"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="63"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="69"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="75"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="81"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="154"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="158"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="162"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="166"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="170"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="174"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="178"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Sha1.hx">
		<make public="1" set="method" line="35" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="115" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="50"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="142">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="155">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="/usr/local/lib/haxe/std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="43"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="55"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/local/lib/haxe/std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.IntMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="81">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(int key, ::null value) { __int_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(int key, bool value) { __int_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(int key, char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, signed char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, short value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned short value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, int value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned int value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, float value) { __int_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(int key, double value) { __int_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(int key, ::String value) { __int_hash_set_string(HX_MAP_THIS,key,value); }\n\n  template<typename V, typename H>\n  inline void set(int key, const ::cpp::Struct<V,H> &value) {__int_hash_set(HX_MAP_THIS,key,value); }\n  template<typename F>\n  inline void set(int key, const ::cpp::Function<F> &value) {__int_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(int key, const ::cpp::Pointer<V> &value) {__int_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  template<typename VALUE>\n  inline void set(Dynamic &key, const VALUE &value) { set( (int)key, value ); }\n\n  inline bool get_bool(int key) { return __int_hash_get_bool(h,key); }\n  inline int get_int(int key) { return __int_hash_get_int(h,key); }\n  inline Float get_float(int key) { return __int_hash_get_float(h,key); }\n  inline String get_string(int key) { return __int_hash_get_string(h,key); }\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<isEmpty public="1" set="method" line="113">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="137">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/local/lib/haxe/std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.ObjectMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(Dynamic key, ::null value) { __object_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, bool value) { __object_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, signed char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, short value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned short value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, int value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned int value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, float value) { __object_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, double value) { __object_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, ::String value) { __object_hash_set_string(HX_MAP_THIS,key,value); }\n\n\n  template<typename V, typename H>\n  inline void set(Dynamic key, const ::cpp::Struct<V,H> &value) {__object_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(Dynamic key, const ::cpp::Function<V> &value) {__object_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n  template<typename V>\n  inline void set(Dynamic key, const ::cpp::Pointer<V> &value) {__object_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  inline bool get_bool(Dynamic key) { return __object_hash_get_bool(h,key); }\n  inline int get_int(Dynamic key) { return __object_hash_get_int(h,key); }\n  inline Float get_float(Dynamic key) { return __object_hash_get_float(h,key); }\n  inline String get_string(Dynamic key) { return __object_hash_get_string(h,key); }\n\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/usr/local/lib/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/local/lib/haxe/std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.StringMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="81">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(String key, ::null value) { __string_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(String key, bool value) { __string_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(String key, char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, signed char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, float value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(String key, double value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(String key, ::String value) { __string_hash_set_string(HX_MAP_THIS,key,value); }\n\n  template<typename V, typename H>\n  inline void set(String key, const ::cpp::Struct<V,H> &value) {__string_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(String key, const ::cpp::Function<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n  template<typename V>\n  inline void set(String key, const ::cpp::Pointer<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  template<typename VALUE>\n  inline void set(Dynamic &key, const VALUE &value) { set( (String)key, value ); }\n\n  inline bool get_bool(String key) { return __string_hash_get_bool(h,key); }\n  inline int get_int(String key) { return __string_hash_get_int(h,key); }\n  inline Float get_float(String key) { return __string_hash_get_float(h,key); }\n  inline String get_string(String key) { return __string_hash_get_string(h,key); }\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.AsVar" params="T" file="/usr/local/lib/haxe/std/haxe/extern/AsVar.hx">
		<from><icast><c path="haxe.extern.AsVar.T"/></icast></from>
		<this><c path="haxe.extern.AsVar.T"/></this>
		<to><icast><c path="haxe.extern.AsVar.T"/></icast></to>
		<haxe_doc>If this type is used as an argument type, the compiler ensures that
	argument expressions are bound to a local variable.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
		<impl><class path="haxe.extern._AsVar.AsVar_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/extern/AsVar.hx" private="1" module="haxe.extern.AsVar" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.format.JsonParser" params="" file="/usr/local/lib/haxe/std/haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<doParse set="method" line="56"><f a=""><d/></f></doParse>
		<parseRec set="method" line="70"><f a=""><d/></f></parseRec>
		<parseString set="method" line="152"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="312"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="317"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="/usr/local/lib/haxe/std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a="key:value">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<write set="method" line="81"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<addChar get="inline" set="null" line="140"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addChar>
		<add get="inline" set="null" line="148"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<classString set="method" line="157"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<fieldsString set="method" line="165"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="196"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/usr/local/lib/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="/usr/local/lib/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<new public="1" set="method" line="32"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/usr/local/lib/haxe/std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<addInt32 public="1" set="method" line="133"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<addInt64 public="1" set="method" line="144"><f a="v">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></addInt64>
		<getBytes public="1" set="method" line="201">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="cpp.UInt8"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/usr/local/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readUntil public="1" set="method" line="163">
			<f a="end">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read a string until a character code specified by `end` is occurred.

		The final character is not included in the resulting string.</haxe_doc>
		</readUntil>
		<readLine public="1" set="method" line="176">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read a line of text separated by CR and/or LF bytes.

		The CR/LF characters are not included in the resulting string.</haxe_doc>
		</readLine>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readDouble public="1" set="method" line="208">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readDouble>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readUInt24 public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt24>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<set_position set="method" line="83">
			<f a="p">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":accessor"/></meta>
		</set_position>
		<readByte public="1" set="method" line="96" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="119" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/local/lib/haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="103">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeFloat public="1" set="method" line="133">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="178">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="225">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="137">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="/usr/local/lib/haxe/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/usr/local/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/local/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="/usr/local/lib/haxe/std/haxe/io/FPHelper.hx">
		<i32ToFloat public="1" set="method" line="133" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i32ToFloat>
		<floatToI32 public="1" set="method" line="177" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</floatToI32>
		<i64ToDouble public="1" set="method" line="214" static="1">
			<f a="low:high">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i64ToDouble>
		<doubleToI64 public="1" set="method" line="268" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns an Int64 representing the bytes representation of the double precision IEEE float value.
		WARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.
		We still ensure that this is safe to use in a multithread environment</haxe_doc>
		</doubleToI64>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="/usr/local/lib/haxe/std/haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="/usr/local/lib/haxe/std/haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.Path" params="" file="/usr/local/lib/haxe/std/haxe/io/Path.hx">
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<withExtension public="1" set="method" line="175" static="1">
			<f a="path:ext">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are `null`, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="299" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<isAbsolute public="1" set="method" line="314" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the path is an absolute path, and `false` otherwise.</haxe_doc>
		</isAbsolute>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/usr/local/lib/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="51">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.Binop" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd><haxe_doc>`+`</haxe_doc></OpAdd>
		<OpMult><haxe_doc>`*`</haxe_doc></OpMult>
		<OpDiv><haxe_doc>`/`</haxe_doc></OpDiv>
		<OpSub><haxe_doc>`-`</haxe_doc></OpSub>
		<OpAssign><haxe_doc>`=`</haxe_doc></OpAssign>
		<OpEq><haxe_doc>`==`</haxe_doc></OpEq>
		<OpNotEq><haxe_doc>`!=`</haxe_doc></OpNotEq>
		<OpGt><haxe_doc><![CDATA[`>`]]></haxe_doc></OpGt>
		<OpGte><haxe_doc><![CDATA[`>=`]]></haxe_doc></OpGte>
		<OpLt><haxe_doc><![CDATA[`<`]]></haxe_doc></OpLt>
		<OpLte><haxe_doc><![CDATA[`<=`]]></haxe_doc></OpLte>
		<OpAnd><haxe_doc><![CDATA[`&`]]></haxe_doc></OpAnd>
		<OpOr><haxe_doc>`|`</haxe_doc></OpOr>
		<OpXor><haxe_doc>`^`</haxe_doc></OpXor>
		<OpBoolAnd><haxe_doc><![CDATA[`&&`]]></haxe_doc></OpBoolAnd>
		<OpBoolOr><haxe_doc>`||`</haxe_doc></OpBoolOr>
		<OpShl><haxe_doc><![CDATA[`<<`]]></haxe_doc></OpShl>
		<OpShr><haxe_doc><![CDATA[`>>`]]></haxe_doc></OpShr>
		<OpUShr><haxe_doc><![CDATA[`>>>`]]></haxe_doc></OpUShr>
		<OpMod><haxe_doc>`%`</haxe_doc></OpMod>
		<OpAssignOp a="op">
			<e path="haxe.macro.Binop"/>
			<haxe_doc><![CDATA[`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`]]></haxe_doc>
		</OpAssignOp>
		<OpInterval><haxe_doc>`...`</haxe_doc></OpInterval>
		<OpArrow><haxe_doc><![CDATA[`=>`]]></haxe_doc></OpArrow>
		<OpIn><haxe_doc>`in`</haxe_doc></OpIn>
		<haxe_doc>A binary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement><haxe_doc>`++`</haxe_doc></OpIncrement>
		<OpDecrement><haxe_doc>`--`</haxe_doc></OpDecrement>
		<OpNot><haxe_doc>`!`</haxe_doc></OpNot>
		<OpNeg><haxe_doc>`-`</haxe_doc></OpNeg>
		<OpNegBits><haxe_doc>`~`</haxe_doc></OpNegBits>
		<haxe_doc>A unary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="27" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="27" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="39" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="39" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="68" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="68" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml.Access" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<innerData public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
	</innerData>
	<get_innerData set="method" line="215" static="1">
		<f a="this">
			<c path="Xml"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_innerData>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.Access_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<innerData public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
		</innerData>
		<get_innerData set="method" line="215" static="1">
			<f a="this">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_innerData>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Parser.S" params="" file="/usr/local/lib/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="/usr/local/lib/haxe/std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="/usr/local/lib/haxe/std/haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="/usr/local/lib/haxe/std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Compress" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init set="method" static="1">
			<f a="level">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_init"</e></m></meta>
		</_deflate_init>
		<_deflate_bound set="method" static="1">
			<f a="handle:length">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_bound"</e></m></meta>
		</_deflate_bound>
		<_deflate_buffer set="method" static="1">
			<f a="handle:src:srcPos:dest:destPos">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_buffer"</e></m></meta>
		</_deflate_buffer>
		<_deflate_end set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_end"</e></m></meta>
		</_deflate_end>
		<_set_flush_mode set="method" static="1">
			<f a="handle:flushMode">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_zip_set_flush_mode"</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/zlib/Build.xml\" />"]]></e></m>
		</meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="/usr/local/lib/haxe/std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="/usr/local/lib/haxe/std/cpp/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="45" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init set="method" static="1">
			<f a="windowBits">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_init"</e></m></meta>
		</_inflate_init>
		<_inflate_buffer set="method" static="1">
			<f a="handle:src:srcPos:dest:destPos">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_buffer"</e></m></meta>
		</_inflate_buffer>
		<_inflate_end set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_end"</e></m></meta>
		</_inflate_end>
		<_set_flush_mode set="method" static="1">
			<f a="handle:flushMode">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_zip_set_flush_mode"</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37">
			<f a="f">
				<e path="haxe.zip.FlushMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="?windowBits">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/zlib/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="hxGeomAlgo.Debug" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Debug.hx">
		<assert public="1" get="inline" set="null" line="22" static="1">
			<f a="cond:?message:?pos">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used for sanity-checks throughout the code when in debug mode (or if -D GEOM_CHECKS is passed to the compiler).
   * Should be automatically stripped out by the compiler in release mode (or if -D NO_GEOM_CHECKS is passed to the compiler).</haxe_doc>
		</assert>
		<haxe_doc>* @author azrafe7</haxe_doc>
	</class>
	<class path="hxGeomAlgo.HomogCoord" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/HomogCoord.hx">
		<INFINITY public="1" expr="new HomogCoord()" line="19" static="1">
			<c path="hxGeomAlgo.HomogCoord"/>
			<meta><m n=":value"><e>new HomogCoord()</e></m></meta>
		</INFINITY>
		<det public="1" set="method" line="63" static="1"><f a="p:q:r">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Float"/>
</f></det>
		<ccw public="1" set="method" line="67" static="1"><f a="p:q:r">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Bool"/>
</f></ccw>
		<cw public="1" set="method" line="71" static="1"><f a="p:q:r">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Bool"/>
</f></cw>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<w public="1"><x path="Float"/></w>
		<add public="1" set="method" line="31"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></add>
		<sub public="1" set="method" line="33"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></sub>
		<neg public="1" set="method" line="35"><f a=""><c path="hxGeomAlgo.HomogCoord"/></f></neg>
		<mul public="1" set="method" line="37"><f a="m">
	<x path="Float"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></mul>
		<div public="1" set="method" line="39"><f a="m">
	<x path="Float"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></div>
		<normalize public="1" set="method" line="41"><f a=""><c path="hxGeomAlgo.HomogCoord"/></f></normalize>
		<lengthSquared public="1" set="method" line="43"><f a=""><x path="Float"/></f></lengthSquared>
		<length public="1" set="method" line="45"><f a=""><x path="Float"/></f></length>
		<perp public="1" set="method" line="47"><f a=""><c path="hxGeomAlgo.HomogCoord"/></f></perp>
		<dotPoint public="1" set="method" line="49"><f a="p">
	<x path="hxGeomAlgo.HxPoint"/>
	<x path="Float"/>
</f></dotPoint>
		<dot public="1" set="method" line="51"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Float"/>
</f></dot>
		<perpdot public="1" set="method" line="53"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Float"/>
</f></perpdot>
		<dotperp public="1" set="method" line="55"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Float"/>
</f></dotperp>
		<equals public="1" set="method" line="57"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<x path="Bool"/>
</f></equals>
		<left public="1" set="method" line="59"><f a="p">
	<x path="hxGeomAlgo.HxPoint"/>
	<x path="Bool"/>
</f></left>
		<right public="1" set="method" line="61"><f a="p">
	<x path="hxGeomAlgo.HxPoint"/>
	<x path="Bool"/>
</f></right>
		<toScreen public="1" set="method" line="75"><f a=""><x path="hxGeomAlgo.HxPoint"/></f></toScreen>
		<toPoint public="1" set="method" line="79"><f a=""><x path="hxGeomAlgo.HxPoint"/></f></toPoint>
		<meet public="1" set="method" line="81"><f a="p">
	<c path="hxGeomAlgo.HomogCoord"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></meet>
		<meetPoint public="1" set="method" line="85"><f a="p">
	<x path="hxGeomAlgo.HxPoint"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></meetPoint>
		<toString public="1" set="method" line="89"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25">
			<f a="?x:?y:?w" v="0:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxGeomAlgo.HxPoint" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/HxPoint.hx">
		<from>
			<icast><c path="hxGeomAlgo.HxPointData"/></icast>
			<icast field="fromFlashPoint"><t path="flash.geom.Point"/></icast>
			<icast field="fromPointStruct"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></icast>
		</from>
		<this><c path="hxGeomAlgo.HxPointData"/></this>
		<to>
			<icast><c path="hxGeomAlgo.HxPointData"/></icast>
			<icast field="toFlashPoint"><c path="nme.geom.Point"/></icast>
			<icast field="toPointStruct"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></icast>
		</to>
		<haxe_doc>* Minimal Point class (auto-converting to/from flash.geom.Point and {x:Float, y:Float}).
 * 
 * @author azrafe7</haxe_doc>
		<meta><m n=":expose"/></meta>
		<impl><class path="hxGeomAlgo._HxPoint.HxPoint_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/HxPoint.hx" private="1" module="hxGeomAlgo.HxPoint" final="1">
	<EMPTY public="1" set="null" expr="new HxPoint(Math.NaN, Math.NaN)" line="11" static="1">
		<x path="hxGeomAlgo.HxPoint"/>
		<meta><m n=":value"><e>new HxPoint(Math.NaN, Math.NaN)</e></m></meta>
	</EMPTY>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="14" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<set_x get="inline" set="null" line="15" static="1">
		<f a="this:value">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="18" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_y get="inline" set="null" line="19" static="1">
		<f a="this:value">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<_new public="1" set="method" line="21" static="1">
		<f a="?x:?y" v="0:0">
			<x path="Float"/>
			<x path="Float"/>
			<x path="hxGeomAlgo.HxPoint"/>
		</f>
		<meta>
			<m n=":value"><e>{ y : 0, x : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<setTo public="1" set="method" line="26" static="1">
		<f a="this:newX:newY">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setTo>
	<equals public="1" get="inline" set="null" line="32" static="1">
		<f a="this:p">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="hxGeomAlgo.HxPoint"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</equals>
	<clone public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<x path="hxGeomAlgo.HxPoint"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<toString public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<fromFlashPoint get="inline" set="null" line="48" static="1">
		<f a="p">
			<t path="flash.geom.Point"/>
			<x path="hxGeomAlgo.HxPoint"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFlashPoint>
	<toFlashPoint get="inline" set="null" line="53" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<c path="nme.geom.Point"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFlashPoint>
	<fromPointStruct get="inline" set="null" line="59" static="1">
		<f a="p">
			<a>
				<y><x path="Float"/></y>
				<x><x path="Float"/></x>
			</a>
			<x path="hxGeomAlgo.HxPoint"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPointStruct>
	<toPointStruct get="inline" set="null" line="64" static="1">
		<f a="this">
			<c path="hxGeomAlgo.HxPointData"/>
			<a>
				<y><x path="Float"/></y>
				<x><x path="Float"/></x>
			</a>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toPointStruct>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":expose"/>
	</meta>
</class></impl>
	</abstract>
	<class path="hxGeomAlgo.HxPointData" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/HxPoint.hx" module="hxGeomAlgo.HxPoint">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toString public="1" get="inline" set="null" line="82"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="76">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._HxPoint.HxPoint_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/HxPoint.hx" private="1" module="hxGeomAlgo.HxPoint" final="1">
		<EMPTY public="1" set="null" expr="new HxPoint(Math.NaN, Math.NaN)" line="11" static="1">
			<x path="hxGeomAlgo.HxPoint"/>
			<meta><m n=":value"><e>new HxPoint(Math.NaN, Math.NaN)</e></m></meta>
		</EMPTY>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="14" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<set_x get="inline" set="null" line="15" static="1">
			<f a="this:value">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="18" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_y get="inline" set="null" line="19" static="1">
			<f a="this:value">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<_new public="1" set="method" line="21" static="1">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<meta>
				<m n=":value"><e>{ y : 0, x : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<setTo public="1" set="method" line="26" static="1">
			<f a="this:newX:newY">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setTo>
		<equals public="1" get="inline" set="null" line="32" static="1">
			<f a="this:p">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</equals>
		<clone public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<toString public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<fromFlashPoint get="inline" set="null" line="48" static="1">
			<f a="p">
				<t path="flash.geom.Point"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFlashPoint>
		<toFlashPoint get="inline" set="null" line="53" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<c path="nme.geom.Point"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFlashPoint>
		<fromPointStruct get="inline" set="null" line="59" static="1">
			<f a="p">
				<a>
					<y><x path="Float"/></y>
					<x><x path="Float"/></x>
				</a>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPointStruct>
		<toPointStruct get="inline" set="null" line="64" static="1">
			<f a="this">
				<c path="hxGeomAlgo.HxPointData"/>
				<a>
					<y><x path="Float"/></y>
					<x><x path="Float"/></x>
				</a>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toPointStruct>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<typedef path="hxGeomAlgo.Poly" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/PolyTools.hx" module="hxGeomAlgo.PolyTools"><c path="Array"><x path="hxGeomAlgo.HxPoint"/></c></typedef>
	<typedef path="hxGeomAlgo.Tri" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/PolyTools.hx" module="hxGeomAlgo.PolyTools"><t path="hxGeomAlgo.Poly"/></typedef>
	<typedef path="hxGeomAlgo.Diagonal" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/PolyTools.hx" module="hxGeomAlgo.PolyTools">
		<a>
			<to><x path="Int"/></to>
			<from><x path="Int"/></from>
		</a>
		<meta><m n=":expose"/></meta>
	</typedef>
	<class path="hxGeomAlgo.PolyTools" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/PolyTools.hx">
		<point expr="new HxPoint()" line="31" static="1">
			<x path="hxGeomAlgo.HxPoint"/>
			<meta><m n=":value"><e>new HxPoint()</e></m></meta>
		</point>
		<zero public="1" expr="new HxPoint(0, 0)" line="33" static="1">
			<x path="hxGeomAlgo.HxPoint"/>
			<meta><m n=":value"><e>new HxPoint(0, 0)</e></m></meta>
		</zero>
		<EPSILON public="1" expr=".00000001" line="35" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>.00000001</e></m></meta>
		</EPSILON>
		<isCCW public="1" set="method" line="39" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `poly` is counterclockwise (assumes y axis pointing down).</haxe_doc>
		</isCCW>
		<isCW public="1" set="method" line="51" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `poly` is clockwise (assumes y axis pointing down).</haxe_doc>
		</isCW>
		<makeCCW public="1" set="method" line="63" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Makes `poly` counterclockwise (in place). Returns true if reversed.</haxe_doc>
		</makeCCW>
		<makeCW public="1" set="method" line="76" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Makes `poly` clockwise (in place). Returns true if reversed.</haxe_doc>
		</makeCW>
		<isConvex public="1" set="method" line="91" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Assuming the polygon is simple (not self-intersecting), checks if it is convex.</haxe_doc>
		</isConvex>
		<isSimple public="1" set="method" line="124" static="1">
			<f a="poly">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if the polygon is simple (not self-intersecting).</haxe_doc>
		</isSimple>
		<segmentIntersect public="1" set="method" line="159" static="1">
			<f a="p0:p1:q0:q1">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<haxe_doc>* Returns the intersection point between segments p0-p1 and q0-q1. Null if no intersection is found.</haxe_doc>
		</segmentIntersect>
		<findDuplicatePoints public="1" set="method" line="203" static="1">
			<f a="poly:?consecutiveOnly:?wrapAround" v=":true:true">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ wrapAround : true, consecutiveOnly : true }</e></m></meta>
			<haxe_doc>* Returns indices of duplicate points in `poly` (or an empty array if none are found).
   * NOTE: indices in the result are guaranteed to be in ascending order.
   * 
   * @param consecutiveOnly		if true only equal adjacent points are reported
   * @param wrapAround			if true also first vs last point will be checked</haxe_doc>
		</findDuplicatePoints>
		<intersection public="1" set="method" line="224" static="1">
			<f a="p1:p2:q1:q2">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Finds the intersection point between lines extending the segments `p1`-`p2` and `q1`-`q2`. Returns null if they're parallel.</haxe_doc>
		</intersection>
		<isReflex public="1" set="method" line="245" static="1">
			<f a="poly:idx">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `poly` vertex at idx is a reflex vertex.</haxe_doc>
		</isReflex>
		<at public="1" get="inline" set="null" line="251" static="1">
			<f a="poly:idx">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Int"/>
				<x path="hxGeomAlgo.HxPoint"/>
			</f>
			<haxe_doc>Gets `poly` vertex at `idx` (wrapping around if needed).</haxe_doc>
		</at>
		<wrappedIdx public="1" get="inline" set="null" line="258" static="1">
			<f a="poly:idx">
				<t path="hxGeomAlgo.Poly"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Gets usable `idx` from `poly` (wrapping around if needed).</haxe_doc>
		</wrappedIdx>
		<side public="1" get="inline" set="null" line="266" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the side (signed area) of `p` relative to the line extending `b`-`a` (> 0 -> left, < 0 -> right, == 0 -> collinear).]]></haxe_doc>
		</side>
		<isLeft public="1" get="inline" set="null" line="272" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `p` is on the left of the line extending `b`-`a`.</haxe_doc>
		</isLeft>
		<isLeftOrOn public="1" get="inline" set="null" line="278" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `p` is on the left or collinear to the line extending `b`-`a`.</haxe_doc>
		</isLeftOrOn>
		<isRight public="1" get="inline" set="null" line="284" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `p` is on the right of the line extending `b`-`a`.</haxe_doc>
		</isRight>
		<isRightOrOn public="1" get="inline" set="null" line="290" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `p` is on the right or collinear to the line extending `b`-`a`.</haxe_doc>
		</isRightOrOn>
		<isCollinear public="1" get="inline" set="null" line="296" static="1">
			<f a="p:a:b">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the specified triangle is degenerate (collinear points).</haxe_doc>
		</isCollinear>
		<distance public="1" get="inline" set="null" line="302" static="1">
			<f a="v:w">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Distance from `v` to `w`.</haxe_doc>
		</distance>
		<distanceToSegment public="1" get="inline" set="null" line="305" static="1">
			<f a="p:v:w">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Perpendicular distance from `p` to line segment `v`-`w`.</haxe_doc>
		</distanceToSegment>
		<distanceSquared public="1" get="inline" set="null" line="308" static="1">
			<f a="v:w">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Squared distance from `v` to `w`.</haxe_doc>
		</distanceSquared>
		<distanceToSegmentSquared public="1" set="method" line="311" static="1">
			<f a="p:v:w">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Squared perpendicular distance from `p` to line segment `v`-`w`.</haxe_doc>
		</distanceToSegmentSquared>
		<getCentroid public="1" set="method" line="321" static="1"><f a="poly">
	<t path="hxGeomAlgo.Poly"/>
	<x path="hxGeomAlgo.HxPoint"/>
</f></getCentroid>
		<getArea public="1" set="method" line="342" static="1"><f a="poly">
	<t path="hxGeomAlgo.Poly"/>
	<x path="Float"/>
</f></getArea>
		<meet public="1" set="method" line="353" static="1"><f a="p:q">
	<x path="hxGeomAlgo.HxPoint"/>
	<x path="hxGeomAlgo.HxPoint"/>
	<c path="hxGeomAlgo.HomogCoord"/>
</f></meet>
		<dot public="1" set="method" line="359" static="1">
			<f a="p:q">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Dot product.</haxe_doc>
		</dot>
		<sqr public="1" get="inline" set="null" line="365" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Returns `x` squared.</haxe_doc>
		</sqr>
		<eq public="1" get="inline" set="null" line="368" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Returns true if `a` is _acceptably_ equal to `b` (i.e. `a` is within EPSILON distance from `b`).</haxe_doc>
		</eq>
		<clear public="1" params="T" get="inline" set="null" line="374" static="1">
			<f a="array">
				<c path="Array"><c path="clear.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Empties an array of its contents.</haxe_doc>
		</clear>
		<toFloatArray public="1" set="method" line="384" static="1">
			<f a="poly:?out">
				<t path="hxGeomAlgo.Poly"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc><![CDATA[Converts a poly defined by an Array<HxPoint> to an Array<Float> (appending values to `out` if specified).]]></haxe_doc>
		</toFloatArray>
		<reverseFloatArray public="1" set="method" line="397" static="1">
			<f a="poly:?inPlace" v=":false">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ inPlace : false }</e></m></meta>
			<haxe_doc>Reverses the coords of the 2D float array `poly` (doing it `inPlace` if specified).</haxe_doc>
		</reverseFloatArray>
		<flatten public="1" params="T" set="method" line="412" static="1">
			<f a="array:?out">
				<c path="Array"><c path="Array"><c path="flatten.T"/></c></c>
				<c path="Array"><c path="flatten.T"/></c>
				<c path="Array"><c path="flatten.T"/></c>
			</f>
			<haxe_doc>Converts an Array of Arrays into a 'flattened' Array (appending values to `out` if specified).</haxe_doc>
		</flatten>
		<toPointArray public="1" set="method" line="424" static="1">
			<f a="poly:?out">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><t path="hxGeomAlgo.Poly"/></x>
				<t path="hxGeomAlgo.Poly"/>
			</f>
			<haxe_doc><![CDATA[Converts a poly defined by an Array<Float> to an Array<HxPoint> (appending values to `out` if specified).]]></haxe_doc>
		</toPointArray>
		<inflateLine public="1" set="method" line="439" static="1">
			<f a="start:end:thickness">
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="hxGeomAlgo.HxPoint"/>
				<x path="Float"/>
				<t path="hxGeomAlgo.Poly"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Expands a line into a rectangular poly, offsetting it by half-`thickness` along its normals.</haxe_doc>
		</inflateLine>
		<clip public="1" set="method" line="457" static="1">
			<f a="subjPoly:clipPoly">
				<t path="hxGeomAlgo.Poly"/>
				<t path="hxGeomAlgo.Poly"/>
				<c path="Array"><t path="hxGeomAlgo.Poly"/></c>
			</f>
			<haxe_doc>* Clips `subjPoly` with `clipPoly` (using the Sutherland-Hodgman algorithm).
   * 
   * NOTE: expects simple polygons, and `clipPoly` MUST be convex.
   * 
   * @see https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm</haxe_doc>
		</clip>
		<exposeEnum public="1" params="T" set="method" line="502" static="1">
			<f a="enumClass:?as">
				<x path="Enum"><c path="exposeEnum.T"/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noUsing"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Used internally to expose enums in js.</haxe_doc>
		</exposeEnum>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<enum path="hxGeomAlgo.WindingRule" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" module="hxGeomAlgo.Tess2">
		<ODD/>
		<NON_ZERO/>
		<POSITIVE/>
		<NEGATIVE/>
		<ABS_GEQ_TWO/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":expose"/>
		</meta>
	</enum>
	<enum path="hxGeomAlgo.ResultType" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" module="hxGeomAlgo.Tess2">
		<POLYGONS/>
		<CONNECTED_POLYGONS/>
		<BOUNDARY_CONTOURS/>
		<EXPERIMENTAL_DELAUNAY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":expose"/>
		</meta>
	</enum>
	<typedef path="hxGeomAlgo.TessResult" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" module="hxGeomAlgo.Tess2"><a>
	<vertices><c path="Array"><x path="Float"/></c></vertices>
	<vertexIndices><c path="Array"><x path="Int"/></c></vertexIndices>
	<vertexCount><x path="Int"/></vertexCount>
	<elements><c path="Array"><x path="Int"/></c></elements>
	<elementCount><x path="Int"/></elementCount>
</a></typedef>
	<class path="hxGeomAlgo.Tess2" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx">
		<tesselate public="1" set="method" line="124" static="1">
			<f a="contours:?windingRule:?resultType:?polySize:?vertexDim:?normal" v=":null:null:3:2:null">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<e path="hxGeomAlgo.WindingRule"/>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<t path="hxGeomAlgo.TessResult"/>
			</f>
			<meta><m n=":value"><e>{ normal : null, vertexDim : 2, polySize : 3, resultType : null, windingRule : null }</e></m></meta>
			<haxe_doc><![CDATA[* Tesselates the specified `contours`.
   * 
   * (see Tess2.convertResult() for an easy way to use the returned TessResult)
   * 
   * @param	contours		Array of polygons to tesselate. Each poly is specified as a sequence of point coords (i.e. [x0, y0, x1, y1, x2, y2, ...]).
   * @param	windingRule		Winding rule to apply. Deaults to WindingRule.ODD.
   * @param	resultType		The result type you want as output. Defaults to ResultType.POLYGONS.
   * @param	polySize		Max dimesion of the polygons resulting from the tesselation. Defaults to 3 (not considered if resultType is BOUNDARY_CONTOURS or EXPERIMENTAL_DELAUNAY).
   * @param	vertexDim		Pass 2 when working with 2D polys (default), or 3 for 3D.
   * @param	normal			Array of length 3 representing the normals in each plane.
   * 
   * @return A structure of TessResult type, composed of the following fields:
   *		   { 
   *				vertices:Array<Float>;		// A sequence of point coords in the same format of `contours`.
   *				vertexIndices:Array<Int>;	// A sequence of indices that map into the original `contours` joined together.
   *				vertexCount:Int;			// The number of vertices.
   *				elements:Array<Int>;		// Elements' indices whose meaning depends on the ResultType used.
   *				elementCount:Int;			// The number of elements found.
   * 		   };]]></haxe_doc>
		</tesselate>
		<union public="1" set="method" line="149" static="1">
			<f a="contoursA:contoursB:?resultType:?polySize:?vertexDim" v="::null:3:2">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="hxGeomAlgo.TessResult"/>
			</f>
			<meta><m n=":value"><e>{ vertexDim : 2, polySize : 3, resultType : null }</e></m></meta>
			<haxe_doc>* Computes the union between `contoursA` and `contoursB`. 
   *
   * @see "CSG Uses for Winding Rules" section on http://www.glprogramming.com/red/chapter11.html</haxe_doc>
		</union>
		<intersection public="1" set="method" line="160" static="1">
			<f a="contoursA:contoursB:?resultType:?polySize:?vertexDim" v="::null:3:2">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="hxGeomAlgo.TessResult"/>
			</f>
			<meta><m n=":value"><e>{ vertexDim : 2, polySize : 3, resultType : null }</e></m></meta>
			<haxe_doc>* Computes the intersection between `contoursA` and `contoursB`.
   *
   * @see "CSG Uses for Winding Rules" section on http://www.glprogramming.com/red/chapter11.html</haxe_doc>
		</intersection>
		<difference public="1" set="method" line="171" static="1">
			<f a="contoursA:contoursB:?resultType:?polySize:?vertexDim" v="::null:3:2">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="hxGeomAlgo.TessResult"/>
			</f>
			<meta><m n=":value"><e>{ vertexDim : 2, polySize : 3, resultType : null }</e></m></meta>
			<haxe_doc>* Computes `contoursA` - `contoursB`.
   *
   * @see "CSG Uses for Winding Rules" section on http://www.glprogramming.com/red/chapter11.html</haxe_doc>
		</difference>
		<convertResult public="1" set="method" line="189" static="1">
			<f a="vertices:elements:resultType:polySize:?out">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<c path="Array"><t path="hxGeomAlgo.Poly"/></c>
				<c path="Array"><t path="hxGeomAlgo.Poly"/></c>
			</f>
			<haxe_doc>* Converts the results from tesselate() in a more manageable output.
   * 
   * @param	vertices	A sequence of point coords in the same format of `contours`. Typically the `vertices` field of Tess2.tesselate() output.
   * @param	elements	A sequence of elements. Typically the `vertices` field of Tess2.tesselate() output.
   * @param	resultType	The `resultType` passed to Tess2.tesselate().
   * @param	polySize	The `polySize` passed to Tess2.tesselate().
   * @param	out			The output will be appended to this array of polygons (if specified).
   * 
   * @return An array of polygons.</haxe_doc>
		</convertResult>
		<haxe_doc>* Class offering a quick wrapper around Tesselator functions.
 * 
 * For more info about how to use this class see the demo by Mikko Mononen on (https://github.com/memononen/tess2.js).
 * Live version rehosted here (https://dl.dropboxusercontent.com/u/32864004/dev/FPDemo/tess2.js-demo/index.html).
 * 
 * Further reading: http://www.glprogramming.com/red/chapter11.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="hxGeomAlgo._Tess2.TessVertex" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<next public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<prev public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</prev>
		<anEdge public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anEdge>
		<coords public="1" expr="[0, 0, 0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</coords>
		<s public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</s>
		<t public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</t>
		<pqHandle public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pqHandle>
		<n public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</n>
		<idx public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</idx>
		<new public="1" set="method" line="323"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.TessFace" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<next public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessFace"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<prev public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessFace"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</prev>
		<anEdge public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anEdge>
		<trail public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessFace"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</trail>
		<n public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</n>
		<marked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</marked>
		<inside public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inside>
		<new public="1" set="method" line="338"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.TessHalfEdge" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<next public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<Sym public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</Sym>
		<Onext public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</Onext>
		<Lnext public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</Lnext>
		<Org public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</Org>
		<Lface public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessFace"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</Lface>
		<activeRegion public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</activeRegion>
		<winding public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</winding>
		<side public="1"><x path="Int"/></side>
		<mark public="1"><x path="Bool"/></mark>
		<Rface public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessFace"/></Rface>
		<get_Rface set="method" line="363"><f a=""><c path="hxGeomAlgo._Tess2.TessFace"/></f></get_Rface>
		<set_Rface set="method" line="364"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<c path="hxGeomAlgo._Tess2.TessFace"/>
</f></set_Rface>
		<Dst public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessVertex"/></Dst>
		<get_Dst set="method" line="367"><f a=""><c path="hxGeomAlgo._Tess2.TessVertex"/></f></get_Dst>
		<set_Dst set="method" line="368"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
</f></set_Dst>
		<Oprev public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Oprev>
		<get_Oprev set="method" line="371"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Oprev>
		<set_Oprev set="method" line="372"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Oprev>
		<Lprev public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Lprev>
		<get_Lprev set="method" line="375"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Lprev>
		<set_Lprev set="method" line="376"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Lprev>
		<Dprev public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Dprev>
		<get_Dprev set="method" line="379"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Dprev>
		<set_Dprev set="method" line="380"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Dprev>
		<Rprev public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Rprev>
		<get_Rprev set="method" line="383"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Rprev>
		<set_Rprev set="method" line="384"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Rprev>
		<Dnext public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Dnext>
		<get_Dnext set="method" line="387"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Dnext>
		<set_Dnext set="method" line="388"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Dnext>
		<Rnext public="1" get="accessor" set="accessor"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></Rnext>
		<get_Rnext set="method" line="391"><f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f></get_Rnext>
		<set_Rnext set="method" line="392"><f a="v">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></set_Rnext>
		<new public="1" set="method" line="357"><f a="side">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.TessMesh" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<flipEdge public="1" set="method" line="779" static="1"><f a="mesh:edge">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></flipEdge>
		<v public="1" expr="new TessVertex()">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>new TessVertex()</e></m></meta>
		</v>
		<f public="1" expr="new TessFace()">
			<c path="hxGeomAlgo._Tess2.TessFace"/>
			<meta><m n=":value"><e>new TessFace()</e></m></meta>
		</f>
		<e public="1" expr="new TessHalfEdge(0)">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>new TessHalfEdge(0)</e></m></meta>
		</e>
		<eSym public="1" expr="new TessHalfEdge(1)">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>new TessHalfEdge(1)</e></m></meta>
		</eSym>
		<vHead public="1"><c path="hxGeomAlgo._Tess2.TessVertex"/></vHead>
		<fHead public="1"><c path="hxGeomAlgo._Tess2.TessFace"/></fHead>
		<eHead public="1"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></eHead>
		<eHeadSym public="1"><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></eHeadSym>
		<makeEdge_ set="method" line="526"><f a="eNext">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></makeEdge_>
		<splice_ set="method" line="568"><f a="a:b">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></splice_>
		<makeVertex_ set="method" line="584"><f a="newVertex:eOrig:vNext">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></makeVertex_>
		<makeFace_ set="method" line="613"><f a="newFace:eOrig:fNext">
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<x path="Void"/>
</f></makeFace_>
		<killEdge_ set="method" line="645"><f a="eDel">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></killEdge_>
		<killVertex_ set="method" line="660"><f a="vDel:newOrg">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></killVertex_>
		<killFace_ set="method" line="680"><f a="fDel:newLface">
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<x path="Void"/>
</f></killFace_>
		<makeEdge public="1" set="method" line="703">
			<f a=""><c path="hxGeomAlgo._Tess2.TessHalfEdge"/></f>
			<haxe_doc>**************** Basic Edge Operations ********************</haxe_doc>
		</makeEdge>
		<splice public="1" set="method" line="738"><f a="eOrg:eDst">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></splice>
		<delete public="1" set="method" line="868"><f a="eDel">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></delete>
		<addEdgeVertex public="1" set="method" line="926">
			<f a="eOrg">
				<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
				<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			</f>
			<haxe_doc>****************** Other Edge Operations ********************</haxe_doc>
		</addEdgeVertex>
		<splitEdge public="1" set="method" line="950"><f a="eOrg">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></splitEdge>
		<connect public="1" set="method" line="979"><f a="eOrg:eDst">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></connect>
		<zapFace public="1" set="method" line="1017"><f a="fZap">
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<x path="Void"/>
</f></zapFace>
		<countFaceVerts_ set="method" line="1059"><f a="f">
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<x path="Int"/>
</f></countFaceVerts_>
		<mergeConvexFaces public="1" set="method" line="1072"><f a="maxVertsPerFace">
	<x path="Int"/>
	<x path="Bool"/>
</f></mergeConvexFaces>
		<check public="1" set="method" line="1130"><f a=""><x path="Void"/></f></check>
		<new public="1" set="method" line="407"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.Geom" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<vertEq public="1" set="method" line="1189" static="1"><f a="u:v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Bool"/>
</f></vertEq>
		<vertLeq public="1" set="method" line="1194" static="1"><f a="u:v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Bool"/>
</f></vertLeq>
		<transLeq public="1" set="method" line="1199" static="1"><f a="u:v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Bool"/>
</f></transLeq>
		<edgeGoesLeft public="1" set="method" line="1203" static="1"><f a="e">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Bool"/>
</f></edgeGoesLeft>
		<edgeGoesRight public="1" set="method" line="1207" static="1"><f a="e">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Bool"/>
</f></edgeGoesRight>
		<edgeIsInternal public="1" set="method" line="1211" static="1"><f a="e">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Bool"/>
</f></edgeIsInternal>
		<vertL1dist public="1" set="method" line="1215" static="1"><f a="u:v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Float"/>
</f></vertL1dist>
		<edgeEval public="1" set="method" line="1220" static="1"><f a="u:v:w">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Float"/>
</f></edgeEval>
		<edgeSign public="1" set="method" line="1248" static="1"><f a="u:v:w">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Float"/>
</f></edgeSign>
		<transEval public="1" set="method" line="1271" static="1">
			<f a="u:v:w">
				<c path="hxGeomAlgo._Tess2.TessVertex"/>
				<c path="hxGeomAlgo._Tess2.TessVertex"/>
				<c path="hxGeomAlgo._Tess2.TessVertex"/>
				<x path="Float"/>
			</f>
			<haxe_doc>*********************************************************************
  * Define versions of EdgeSign, EdgeEval with s and t transposed.</haxe_doc>
		</transEval>
		<transSign public="1" set="method" line="1299" static="1"><f a="u:v:w">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Float"/>
</f></transSign>
		<vertCCW public="1" set="method" line="1317" static="1"><f a="u:v:w">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Bool"/>
</f></vertCCW>
		<interpolate public="1" set="method" line="1335" static="1"><f a="a:x:b:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></interpolate>
		<intersect public="1" set="method" line="1367" static="1"><f a="o1:d1:o2:d2:v">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></intersect>
		<calcAngle public="1" set="method" line="1432" static="1"><f a="v0:v1:v2">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Float"/>
</f></calcAngle>
		<edgeIsLocallyDelaunay public="1" set="method" line="1449" static="1"><f a="e">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Bool"/>
</f></edgeIsLocallyDelaunay>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.DictNode" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<key public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</key>
		<next public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.DictNode"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<prev public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.DictNode"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</prev>
		<new public="1" set="method" line="1462"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.Dict" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<head public="1"><c path="hxGeomAlgo._Tess2.DictNode"/></head>
		<frame public="1"><c path="hxGeomAlgo.Tesselator"/></frame>
		<leq public="1"><f a="::">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Bool"/>
</f></leq>
		<min public="1" set="method" line="1480"><f a=""><c path="hxGeomAlgo._Tess2.DictNode"/></f></min>
		<max public="1" set="method" line="1484"><f a=""><c path="hxGeomAlgo._Tess2.DictNode"/></f></max>
		<insert public="1" set="method" line="1488"><f a="k">
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.DictNode"/>
</f></insert>
		<search public="1" set="method" line="1492"><f a="key">
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.DictNode"/>
</f></search>
		<insertBefore public="1" set="method" line="1505"><f a="node:key">
	<c path="hxGeomAlgo._Tess2.DictNode"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.DictNode"/>
</f></insertBefore>
		<delete public="1" set="method" line="1520"><f a="node">
	<c path="hxGeomAlgo._Tess2.DictNode"/>
	<x path="Void"/>
</f></delete>
		<new public="1" set="method" line="1471"><f a="frame:leq">
	<c path="hxGeomAlgo.Tesselator"/>
	<f a="::">
		<c path="hxGeomAlgo.Tesselator"/>
		<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
		<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.PQNode" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<handle public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</handle>
		<new public="1" set="method" line="1530"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.PQHandleElem" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<key public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</key>
		<node public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</node>
		<new public="1" set="method" line="1538"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.PriorityQ" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<size public="1"><x path="Int"/></size>
		<max public="1"><x path="Int"/></max>
		<nodes public="1"><c path="Array"><c path="hxGeomAlgo._Tess2.PQNode"/></c></nodes>
		<handles public="1"><c path="Array"><c path="hxGeomAlgo._Tess2.PQHandleElem"/></c></handles>
		<initialized public="1"><x path="Bool"/></initialized>
		<freeList public="1"><x path="Int"/></freeList>
		<leq public="1"><f a=":">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Bool"/>
</f></leq>
		<floatDown_ set="method" line="1572"><f a="curr">
	<x path="Int"/>
	<x path="Void"/>
</f></floatDown_>
		<floatUp_ set="method" line="1600"><f a="curr">
	<x path="Int"/>
	<x path="Void"/>
</f></floatUp_>
		<init public="1" set="method" line="1622"><f a=""><x path="Void"/></f></init>
		<min public="1" set="method" line="1632"><f a=""><c path="hxGeomAlgo._Tess2.TessVertex"/></f></min>
		<isEmpty public="1" set="method" line="1636"><f a=""><x path="Bool"/></f></isEmpty>
		<insert public="1" set="method" line="1643"><f a="keyNew">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Int"/>
</f></insert>
		<extractMin public="1" set="method" line="1678"><f a=""><c path="hxGeomAlgo._Tess2.TessVertex"/></f></extractMin>
		<delete public="1" set="method" line="1700"><f a="hCurr">
	<x path="Int"/>
	<x path="Void"/>
</f></delete>
		<new public="1" set="method" line="1551"><f a="size:leq">
	<x path="Int"/>
	<f a=":">
		<c path="hxGeomAlgo._Tess2.TessVertex"/>
		<c path="hxGeomAlgo._Tess2.TessVertex"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.ActiveRegion" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<eUp public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</eUp>
		<nodeUp public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.DictNode"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nodeUp>
		<windingNumber public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</windingNumber>
		<inside public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inside>
		<sentinel public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sentinel>
		<dirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dirty>
		<fixUpperEdge public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</fixUpperEdge>
		<new public="1" set="method" line="1746"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo._Tess2.Sweep" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" private="1" module="hxGeomAlgo.Tess2">
		<regionBelow public="1" set="method" line="1751" static="1"><f a="r">
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
</f></regionBelow>
		<regionAbove public="1" set="method" line="1755" static="1"><f a="r">
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
</f></regionAbove>
		<debugEvent public="1" set="method" line="1759" static="1"><f a="tess">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Void"/>
</f></debugEvent>
		<addWinding public="1" set="method" line="1796" static="1"><f a="eDst:eSrc">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></addWinding>
		<edgeLeq public="1" set="method" line="1802" static="1"><f a="tess:reg1:reg2">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Bool"/>
</f></edgeLeq>
		<deleteRegion public="1" set="method" line="1843" static="1"><f a="tess:reg">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Void"/>
</f></deleteRegion>
		<fixUpperEdge public="1" set="method" line="1856" static="1"><f a="tess:reg:newEdge">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></fixUpperEdge>
		<topLeftRegion public="1" set="method" line="1868" static="1"><f a="tess:reg">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
</f></topLeftRegion>
		<topRightRegion public="1" set="method" line="1890" static="1"><f a="reg">
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
</f></topRightRegion>
		<addRegionBelow public="1" set="method" line="1902" static="1"><f a="tess:regAbove:eNewUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
</f></addRegionBelow>
		<isWindingInside public="1" set="method" line="1922" static="1"><f a="tess:n">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isWindingInside>
		<computeWinding public="1" set="method" line="1940" static="1"><f a="tess:reg">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Void"/>
</f></computeWinding>
		<finishRegion public="1" set="method" line="1946" static="1"><f a="tess:reg">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Void"/>
</f></finishRegion>
		<finishLeftRegions public="1" set="method" line="1964" static="1"><f a="tess:regFirst:regLast">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
</f></finishLeftRegions>
		<addRightEdges public="1" set="method" line="2017" static="1"><f a="tess:regUp:eFirst:eLast:eTopLeft:cleanUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addRightEdges>
		<spliceMergeVertices public="1" set="method" line="2086" static="1"><f a="tess:e1:e2">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></spliceMergeVertices>
		<vertexWeights public="1" set="method" line="2095" static="1"><f a="isect:org:dst">
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></vertexWeights>
		<getIntersectData public="1" set="method" line="2113" static="1"><f a="tess:isect:orgUp:dstUp:orgLo:dstLo">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></getIntersectData>
		<checkForRightSplice public="1" set="method" line="2126" static="1"><f a="tess:regUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Bool"/>
</f></checkForRightSplice>
		<checkForLeftSplice public="1" set="method" line="2183" static="1"><f a="tess:regUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Bool"/>
</f></checkForLeftSplice>
		<checkForIntersect public="1" set="method" line="2231" static="1"><f a="tess:regUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Bool"/>
</f></checkForIntersect>
		<walkDirtyRegions public="1" set="method" line="2380" static="1"><f a="tess:regUp">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<x path="Void"/>
</f></walkDirtyRegions>
		<connectRightVertex public="1" set="method" line="2466" static="1"><f a="tess:regUp:eBottomLeft">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></connectRightVertex>
		<connectLeftDegenerate public="1" set="method" line="2557" static="1"><f a="tess:regUp:vEvent">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.ActiveRegion"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></connectLeftDegenerate>
		<connectLeftVertex public="1" set="method" line="2616" static="1"><f a="tess:vEvent">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></connectLeftVertex>
		<sweepEvent public="1" set="method" line="2683" static="1"><f a="tess:vEvent">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.TessVertex"/>
	<x path="Void"/>
</f></sweepEvent>
		<addSentinel public="1" set="method" line="2738" static="1"><f a="tess:smin:smax:t">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addSentinel>
		<initEdgeDict public="1" set="method" line="2764" static="1"><f a="tess">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Void"/>
</f></initEdgeDict>
		<doneEdgeDict public="1" set="method" line="2784" static="1"><f a="tess">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Void"/>
</f></doneEdgeDict>
		<removeDegenerateEdges public="1" set="method" line="2806" static="1"><f a="tess">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Void"/>
</f></removeDegenerateEdges>
		<initPriorityQ public="1" set="method" line="2839" static="1"><f a="tess">
	<a>
		<pq><c path="hxGeomAlgo._Tess2.PriorityQ"/></pq>
		<mesh set="null"><a><vHead set="null"><c path="hxGeomAlgo._Tess2.TessVertex"/></vHead></a></mesh>
	</a>
	<x path="Bool"/>
</f></initPriorityQ>
		<donePriorityQ public="1" set="method" line="2878" static="1"><f a="tess">
	<a><pq><c path="hxGeomAlgo._Tess2.PriorityQ"/></pq></a>
	<x path="Void"/>
</f></donePriorityQ>
		<removeDegenerateFaces public="1" set="method" line="2882" static="1"><f a="tess:mesh">
	<c path="hxGeomAlgo.Tesselator"/>
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Bool"/>
</f></removeDegenerateFaces>
		<computeInterior public="1" set="method" line="2917" static="1"><f a="tess">
	<c path="hxGeomAlgo.Tesselator"/>
	<x path="Bool"/>
</f></computeInterior>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxGeomAlgo.Tesselator" params="" file="/usr/local/lib/haxeLibrary/hxGeomAlgo/git/hxGeomAlgo/Tess2.hx" module="hxGeomAlgo.Tess2">
		<mesh public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessMesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* state needed for collecting the input data *</haxe_doc>
		</mesh>
		<normal public="1" expr="[0.0, 0.0, 0.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.0, 0.0, 0.0]</e></m></meta>
			<haxe_doc>* state needed for projecting onto the sweep plane *</haxe_doc>
		</normal>
		<sUnit public="1" expr="[0.0, 0.0, 0.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.0, 0.0, 0.0]</e></m></meta>
		</sUnit>
		<tUnit public="1" expr="[0.0, 0.0, 0.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.0, 0.0, 0.0]</e></m></meta>
		</tUnit>
		<bmin public="1" expr="[0.0, 0.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.0, 0.0]</e></m></meta>
		</bmin>
		<bmax public="1" expr="[0.0, 0.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.0, 0.0]</e></m></meta>
		</bmax>
		<windingRule public="1">
			<e path="hxGeomAlgo.WindingRule"/>
			<haxe_doc>* state needed for the line sweep *</haxe_doc>
		</windingRule>
		<dict public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.Dict"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</dict>
		<pq public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.PriorityQ"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</pq>
		<event public="1" expr="null">
			<c path="hxGeomAlgo._Tess2.TessVertex"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</event>
		<vertexIndexCounter public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vertexIndexCounter>
		<vertices public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</vertices>
		<vertexIndices public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</vertexIndices>
		<vertexCount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vertexCount>
		<elements public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</elements>
		<elementCount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</elementCount>
		<dot_ set="method" line="3025"><f a="u:v">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></dot_>
		<normalize_ set="method" line="3029"><f a="v">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></normalize_>
		<longAxis_ set="method" line="3038"><f a="v">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
</f></longAxis_>
		<computeNormal_ set="method" line="3045"><f a="norm">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></computeNormal_>
		<checkOrientation_ set="method" line="3119"><f a=""><x path="Void"/></f></checkOrientation_>
		<projectPolygon_ set="method" line="3182"><f a=""><x path="Void"/></f></projectPolygon_>
		<addWinding_ set="method" line="3261"><f a="eDst:eSrc">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Void"/>
</f></addWinding_>
		<tessellateMonoRegion_ set="method" line="3294"><f a="mesh:face">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<c path="hxGeomAlgo._Tess2.TessFace"/>
	<x path="Bool"/>
</f></tessellateMonoRegion_>
		<tessellateInterior_ set="method" line="3355"><f a="mesh">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Bool"/>
</f></tessellateInterior_>
		<refineDelaunay_ set="method" line="3378"><f a="mesh">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Void"/>
</f></refineDelaunay_>
		<discardExterior_ set="method" line="3439"><f a="mesh">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Void"/>
</f></discardExterior_>
		<setWindingNumber_ set="method" line="3463"><f a="mesh:value:keepOnlyBoundary">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setWindingNumber_>
		<getNeighbourFace_ set="method" line="3486"><f a="edge">
	<c path="hxGeomAlgo._Tess2.TessHalfEdge"/>
	<x path="Int"/>
</f></getNeighbourFace_>
		<outputPolymesh_ set="method" line="3495"><f a="mesh:resultsType:polySize:vertexDim">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<e path="hxGeomAlgo.ResultType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></outputPolymesh_>
		<outputContours_ set="method" line="3648"><f a="mesh:vertexDim">
	<c path="hxGeomAlgo._Tess2.TessMesh"/>
	<x path="Int"/>
	<x path="Void"/>
</f></outputContours_>
		<addContour public="1" set="method" line="3744"><f a="vertexDim:vertices">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></addContour>
		<tesselate public="1" set="method" line="3803">
			<f a="windingRule:resultType:polySize:vertexDim:?normal" v="::::null">
				<e path="hxGeomAlgo.WindingRule"/>
				<e path="hxGeomAlgo.ResultType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ normal : null }</e></m></meta>
		</tesselate>
		<new public="1" set="method" line="3020"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The actual tesselator class.
 * 
 * For more info about how to use this class see the demo by Mikko Mononen on (https://github.com/memononen/tess2.js).
 * Live version rehosted here (https://dl.dropboxusercontent.com/u/32864004/dev/FPDemo/tess2.js-demo/index.html)
 * 
 * Further reading: http://www.glprogramming.com/red/chapter11.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<typedef path="hxPolyK.Rectangle" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<width><x path="Float"/></width>
	<height><x path="Float"/></height>
</a></typedef>
	<typedef path="hxPolyK.PointK" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<flag><x path="Bool"/></flag>
</a></typedef>
	<typedef path="hxPolyK.Ray" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK"><a>
	<refl><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></refl>
	<norm><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></norm>
	<edge><x path="Float"/></edge>
	<dist><x path="Float"/></dist>
</a></typedef>
	<typedef path="hxPolyK.Edge" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK"><a>
	<point><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></point>
	<norm><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></norm>
	<edge><x path="Float"/></edge>
	<dist><x path="Float"/></dist>
</a></typedef>
	<abstract path="hxPolyK.ArrayPairs" params="T" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK">
		<this><c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c></this>
		<impl><class path="hxPolyK._PolyK.ArrayPairs_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" private="1" module="hxPolyK.PolyK" final="1">
	<_new public="1" set="method" line="68" static="1">
		<f a="arr">
			<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
			<x path="hxPolyK.ArrayPairs"><c path="hxPolyK.ArrayPairs.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="70" static="1">
		<f a="this">
			<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<access get="inline" set="null" line="71" static="1">
		<f a="this:key">
			<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
			<x path="Int"/>
			<a>
				<y><c path="hxPolyK.ArrayPairs.T"/></y>
				<x><c path="hxPolyK.ArrayPairs.T"/></x>
			</a>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</access>
	<reverse public="1" get="inline" set="null" line="75" static="1">
		<f a="this">
			<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
			<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxPolyK._PolyK.ArrayPairs_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" private="1" module="hxPolyK.PolyK" final="1">
		<_new public="1" set="method" line="68" static="1">
			<f a="arr">
				<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
				<x path="hxPolyK.ArrayPairs"><c path="hxPolyK.ArrayPairs.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="70" static="1">
			<f a="this">
				<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<access get="inline" set="null" line="71" static="1">
			<f a="this:key">
				<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
				<x path="Int"/>
				<a>
					<y><c path="hxPolyK.ArrayPairs.T"/></y>
					<x><c path="hxPolyK.ArrayPairs.T"/></x>
				</a>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</access>
		<reverse public="1" get="inline" set="null" line="75" static="1">
			<f a="this">
				<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
				<c path="Array"><c path="hxPolyK.ArrayPairs.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxPolyK.ArrayTriple" params="T" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" module="hxPolyK.PolyK">
		<this><c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c></this>
		<impl><class path="hxPolyK._PolyK.ArrayTriple_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" private="1" module="hxPolyK.PolyK" final="1">
	<_new public="1" set="method" line="86" static="1">
		<f a="arr">
			<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
			<x path="hxPolyK.ArrayTriple"><c path="hxPolyK.ArrayTriple.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="88" static="1">
		<f a="this">
			<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<access get="inline" set="null" line="89" static="1">
		<f a="this:key">
			<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
			<x path="Int"/>
			<a>
				<c><c path="hxPolyK.ArrayTriple.T"/></c>
				<b><c path="hxPolyK.ArrayTriple.T"/></b>
				<a><c path="hxPolyK.ArrayTriple.T"/></a>
			</a>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</access>
	<reverse public="1" get="inline" set="null" line="93" static="1">
		<f a="this">
			<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
			<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
</class></impl>
	</abstract>
	<class path="hxPolyK._PolyK.ArrayTriple_Impl_" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx" private="1" module="hxPolyK.PolyK" final="1">
		<_new public="1" set="method" line="86" static="1">
			<f a="arr">
				<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
				<x path="hxPolyK.ArrayTriple"><c path="hxPolyK.ArrayTriple.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="88" static="1">
			<f a="this">
				<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<access get="inline" set="null" line="89" static="1">
			<f a="this:key">
				<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
				<x path="Int"/>
				<a>
					<c><c path="hxPolyK.ArrayTriple.T"/></c>
					<b><c path="hxPolyK.ArrayTriple.T"/></b>
					<a><c path="hxPolyK.ArrayTriple.T"/></a>
				</a>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</access>
		<reverse public="1" get="inline" set="null" line="93" static="1">
			<f a="this">
				<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
				<c path="Array"><c path="hxPolyK.ArrayTriple.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
	</class>
	<class path="hxPolyK.PolyK" params="" file="/usr/local/lib/haxeLibrary/hxPolyK/git/hxPolyK/PolyK.hx">
		<small public="1" get="inline" set="null" expr="0.0000000001" line="105" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0000000001</e></m></meta>
		</small>
		<isSimple public="1" get="inline" set="null" line="109" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
</f></isSimple>
		<isConvex public="1" get="inline" set="null" line="151" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
</f></isConvex>
		<getArea public="1" get="inline" set="null" line="166" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></getArea>
		<getAABB public="1" get="inline" set="null" line="181" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<t path="hxPolyK.Rectangle"/>
</f></getAABB>
		<reverse public="1" get="inline" set="null" line="195" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></reverse>
		<triangulate public="1" get="inline" set="null" line="201" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></triangulate>
		<containsPoint public="1" set="method" line="262" static="1"><f a="p:px:py">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></containsPoint>
		<slice public="1" set="method" line="305" static="1"><f a="p:ax:ay:bx:by">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><c path="Array"><x path="Float"/></c></c>
</f></slice>
		<raycast public="1" get="inline" set="null" line="396" static="1"><f a="p:x:y:dx:dy:isc">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="hxPolyK.Ray"/>
	<t path="hxPolyK.Ray"/>
</f></raycast>
		<closestEdge public="1" get="inline" set="null" line="432" static="1"><f a="p:x:y:isc">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<t path="hxPolyK.Edge"/>
	<t path="hxPolyK.Edge"/>
</f></closestEdge>
		<pointLineDist get="inline" set="null" line="465" static="1"><f a="p:a:b:edge:isc">
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<x path="Float"/>
	<t path="hxPolyK.Edge"/>
	<x path="Void"/>
</f></pointLineDist>
		<updateISC get="inline" set="null" line="502" static="1"><f a="dx:dy:a1:b1:b2:c:edge:isc">
	<x path="Float"/>
	<x path="Float"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<x path="Float"/>
	<t path="hxPolyK.Ray"/>
	<x path="Void"/>
</f></updateISC>
		<getPoints get="inline" set="null" line="518" static="1"><f a="ps:ind0:ind1">
	<c path="Array"><t path="hxPolyK.PointK"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><t path="hxPolyK.PointK"/></c>
</f></getPoints>
		<firstWithFlag set="method" line="528" static="1"><f a="ps:ind">
	<c path="Array"><t path="hxPolyK.PointK"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></firstWithFlag>
		<pointInTriangle get="inline" set="null" line="536" static="1"><f a="px:py:ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></pointInTriangle>
		<rayLineIntersection get="inline" set="null" line="555" static="1"><f a="a1:a2:b1:b2:c">
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
</f></rayLineIntersection>
		<getLineIntersection get="inline" set="null" line="574" static="1"><f a="a1:a2:b1:b2">
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
</f></getLineIntersection>
		<inRect get="inline" set="null" line="586" static="1"><f a="a:b:c">
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<x path="Bool"/>
</f></inRect>
		<convex get="inline" set="null" line="597" static="1"><f a="ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></convex>
		<dist get="inline" set="null" line="602" static="1"><f a="a:b">
	<t path="hxPolyK.PointK"/>
	<t path="hxPolyK.PointK"/>
	<x path="Float"/>
</f></dist>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.App" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/App.hx">
		<implements path="h3d.IDrawable"/>
		<staticHandler set="method" line="207" static="1"><f a=""><x path="Void"/></f></staticHandler>
		<engine public="1" set="null">
			<c path="h3d.Engine"/>
			<haxe_doc>Rendering engine.</haxe_doc>
		</engine>
		<s3d public="1" set="null">
			<c path="h3d.scene.Scene"/>
			<haxe_doc>Default 3D scene.</haxe_doc>
		</s3d>
		<s2d public="1" set="null">
			<c path="h2d.Scene"/>
			<haxe_doc>Default 2D scene.</haxe_doc>
		</s2d>
		<sevents public="1" set="null">
			<c path="hxd.SceneEvents"/>
			<haxe_doc>Input event listener collection.
		Both 2D and 3D scenes are added to it by default.</haxe_doc>
		</sevents>
		<isDisposed><x path="Bool"/></isDisposed>
		<onResize set="method" line="59">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Screen resize callback.

		By default does nothing. Override this method to provide custom on-resize logic.</haxe_doc>
		</onResize>
		<setScene public="1" set="method" line="66">
			<f a="scene:?disposePrevious" v=":true">
				<c path="hxd.InteractiveScene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ disposePrevious : true }</e></m></meta>
			<haxe_doc>Switch either the 2d or 3d scene with another instance, both in terms of rendering and event handling.
		If you call disposePrevious, it will call dispose() on the previous scene.</haxe_doc>
		</setScene>
		<setCurrent public="1" set="method" line="94">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* When using multiple hxd.App, this will set the current App (the one on which update etc. will be called)</haxe_doc>
		</setCurrent>
		<setScene2D set="method" line="106">
			<f a="s2d:?disposePrevious" v=":true">
				<c path="h2d.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ disposePrevious : true }</e></m></meta>
		</setScene2D>
		<setScene3D set="method" line="114">
			<f a="s3d:?disposePrevious" v=":true">
				<c path="h3d.scene.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ disposePrevious : true }</e></m></meta>
		</setScene3D>
		<render public="1" set="method" line="122"><f a="e">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<setup set="method" line="127"><f a=""><x path="Void"/></f></setup>
		<dispose set="method" line="150"><f a=""><x path="Void"/></f></dispose>
		<loadAssets set="method" line="169">
			<f a="onLoaded">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Load assets asynchronously.

		Called during application setup. By default immediately calls `onLoaded`.
		Override this method to provide asynchronous asset loading logic.

		@param onLoaded a callback that should be called by the overriden
		                method when loading is complete</haxe_doc>
		</loadAssets>
		<init set="method" line="180">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Initialize application.

		Called during application setup after `loadAssets` completed.
		By default does nothing. Override this method to provide application initialization logic.</haxe_doc>
		</init>
		<mainLoop set="method" line="183"><f a=""><x path="Void"/></f></mainLoop>
		<update set="method" line="204">
			<f a="dt">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Update application.

		Called each frame right before rendering.
		First call is done after the application is set up (so `loadAssets` and `init` are called).

		@param dt Time elapsed since last frame, normalized.</haxe_doc>
		</update>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Base class for a Heaps application.

	This class contains code to set up a typical Heaps app,
	including 3D and 2D scene, input, update and loops.

	It's designed to be a base class for an application entry point,
	and provides several methods for overriding, in which we can plug
	custom code. See API documentation for more information.</haxe_doc>
	</class>
	<typedef path="hxd.BitmapInnerData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData"><c path="hxd.BitmapInnerDataImpl"/></typedef>
	<class path="hxd.BitmapInnerDataImpl" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData">
		<pixels public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></pixels>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.BitmapData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/BitmapData.hx">
		<notImplemented get="inline" set="null" line="78" static="1"><f a=""><x path="Void"/></f></notImplemented>
		<fromNative public="1" set="method" line="663" static="1"><f a="data">
	<t path="hxd.BitmapInnerData"/>
	<c path="hxd.BitmapData"/>
</f></fromNative>
		<data><t path="hxd.BitmapInnerData"/></data>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<clear public="1" set="method" line="70"><f a="color">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<fill public="1" set="method" line="82"><f a="x:y:width:height:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<draw public="1" set="method" line="114"><f a="x:y:src:srcX:srcY:width:height:?blendMode">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="h2d.BlendMode"/>
	<x path="Void"/>
</f></draw>
		<drawScaled public="1" set="method" line="169">
			<f a="x:y:width:height:src:srcX:srcY:srcWidth:srcHeight:?blendMode:?smooth" v="::::::::::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="h2d.BlendMode"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</drawScaled>
		<line public="1" set="method" line="227"><f a="x0:y0:x1:y1:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></line>
		<dispose public="1" get="inline" set="null" line="461"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="472"><f a=""><c path="hxd.BitmapData"/></f></clone>
		<sub public="1" set="method" line="476"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
</f></sub>
		<lock public="1" set="method" line="509">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we will perform several pixel operations on the BitmapData.</haxe_doc>
		</lock>
		<unlock public="1" set="method" line="521">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we have finished performing pixel operations on the BitmapData.</haxe_doc>
		</unlock>
		<getPixel public="1" set="method" line="535">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Access the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</getPixel>
		<setPixel public="1" set="method" line="556">
			<f a="x:y:c">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Modify the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</setPixel>
		<get_width get="inline" set="null" line="584"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="594"><f a=""><x path="Int"/></f></get_height>
		<getPixels public="1" set="method" line="604"><f a=""><c path="hxd.Pixels"/></f></getPixels>
		<setPixels public="1" set="method" line="623"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></setPixels>
		<toNative public="1" get="inline" set="null" line="653"><f a=""><t path="hxd.BitmapInnerData"/></f></toNative>
		<toPNG public="1" set="method" line="675"><f a=""><c path="haxe.io.Bytes"/></f></toPNG>
		<new public="1" set="method" line="45"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Charset" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Charset.hx">
		<ASCII public="1" expr="&quot; !\&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA[" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"]]></e></m></meta>
			<haxe_doc>Contains the whole ASCII charset.</haxe_doc>
		</ASCII>
		<LATIN1 public="1" expr="&quot;¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€"</e></m></meta>
			<haxe_doc>The Latin1 (ISO 8859-1) charset (only the extra chars, no the ASCII part) + euro symbol</haxe_doc>
		</LATIN1>
		<CYRILLIC public="1" expr="&quot;АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—"</e></m></meta>
			<haxe_doc>Russian support</haxe_doc>
		</CYRILLIC>
		<POLISH public="1" expr="&quot;ĄĆĘŁŃÓŚŹŻąćęłńóśźż&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ĄĆĘŁŃÓŚŹŻąćęłńóśźż"</e></m></meta>
			<haxe_doc>Polish support</haxe_doc>
		</POLISH>
		<TURKISH public="1" expr="&quot;ÂÇĞIİÎÖŞÜÛâçğıİîöşüû&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ÂÇĞIİÎÖŞÜÛâçğıİîöşüû"</e></m></meta>
			<haxe_doc>Turkish support</haxe_doc>
		</TURKISH>
		<JP_KANA public="1" expr="&quot;　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９"</e></m></meta>
			<haxe_doc><![CDATA[Contains Hiragana, Katanaga, japanese punctuaction and full width space (0x3000) full width numbers (0-9) and some full width ascii punctuation (!:?%&()-). Does not include full width A-Za-z.]]></haxe_doc>
		</JP_KANA>
		<UNICODE_SPECIALS public="1" expr="&quot;�□&quot;" line="38" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"�□"</e></m></meta>
			<haxe_doc>Special unicode chars (fallback chars)</haxe_doc>
		</UNICODE_SPECIALS>
		<DEFAULT_CHARS public="1" expr="ASCII + LATIN1" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>ASCII + LATIN1</e></m></meta>
		</DEFAULT_CHARS>
		<inst static="1"><c path="hxd.Charset"/></inst>
		<getDefault public="1" set="method" line="142" static="1"><f a=""><c path="hxd.Charset"/></f></getDefault>
		<map><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></map>
		<resolveChar public="1" params="T" set="method" line="101"><f a="code:glyphs">
	<x path="Int"/>
	<t path="Map">
		<x path="Int"/>
		<c path="resolveChar.T"/>
	</t>
	<x path="Null"><c path="resolveChar.T"/></x>
</f></resolveChar>
		<isCJK public="1" set="method" line="111"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isCJK>
		<isSpace public="1" set="method" line="133"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSpace>
		<isBreakChar public="1" set="method" line="137"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBreakChar>
		<new set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Cursor" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Cursor.hx">
		<Default/>
		<Button/>
		<Move/>
		<TextInput/>
		<Hide/>
		<Custom a="custom"><c path="hxd.CustomCursor"/></Custom>
		<Callback a="f">
			<f a=""><x path="Void"/></f>
			<haxe_doc>When this cursor is selected, call the function itself, which can handle complex logic and is responsible to call hxd.System.setCursor</haxe_doc>
		</Callback>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.CustomCursor" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Cursor.hx" module="hxd.Cursor">
		<frames><c path="Array"><c path="hxd.BitmapData"/></c></frames>
		<speed><x path="Float"/></speed>
		<offsetX><x path="Int"/></offsetX>
		<offsetY><x path="Int"/></offsetY>
		<alloc><d/></alloc>
		<dispose public="1" set="method" line="86"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="46"><f a="frames:speed:offsetX:offsetY">
	<c path="Array"><c path="hxd.BitmapData"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.System</e></m></meta>
	</class>
	<enum path="hxd.EventKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Event.hx" module="hxd.Event">
		<EPush/>
		<ERelease/>
		<EMove/>
		<EOver/>
		<EOut/>
		<EWheel/>
		<EFocus/>
		<EFocusLost/>
		<EKeyDown/>
		<EKeyUp/>
		<EReleaseOutside/>
		<ETextInput/>
		<ECheck><haxe_doc>Used to check if we are still on the interactive if no EMove was triggered this frame.</haxe_doc></ECheck>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.Event" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Event.hx">
		<kind public="1"><e path="hxd.EventKind"/></kind>
		<relX public="1"><x path="Float"/></relX>
		<relY public="1"><x path="Float"/></relY>
		<relZ public="1"><x path="Float"/></relZ>
		<propagate public="1">
			<x path="Bool"/>
			<haxe_doc>Will propagate the event to other interactives that are below the current one.</haxe_doc>
		</propagate>
		<cancel public="1">
			<x path="Bool"/>
			<haxe_doc>Will cancel the default behavior for this event as if it had happen outside of the interactive zone.</haxe_doc>
		</cancel>
		<button public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</button>
		<touchId public="1"><x path="Int"/></touchId>
		<keyCode public="1"><x path="Int"/></keyCode>
		<charCode public="1"><x path="Int"/></charCode>
		<wheelDelta public="1"><x path="Float"/></wheelDelta>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="42">
			<f a="k:?x:?y" v=":0.:0.">
				<e path="hxd.EventKind"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.BrowseOptions" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/File.hx" module="hxd.File"><a>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<saveFileName>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</saveFileName>
	<relativePath>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</relativePath>
	<fileTypes>
		<x path="Null"><c path="Array"><a>
	<name><c path="String"/></name>
	<extensions><c path="Array"><c path="String"/></c></extensions>
</a></c></x>
		<meta><m n=":optional"/></meta>
	</fileTypes>
	<defaultPath>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</defaultPath>
</a></typedef>
	<typedef path="hxd.BrowseSelect" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/File.hx" module="hxd.File"><a>
	<load set="method">
		<f a="onReady">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<x path="Void"/>
		</f>
		<haxe_doc>allow to load the selected file content</haxe_doc>
	</load>
	<fileName>
		<c path="String"/>
		<haxe_doc>might contain only the file name without the full path depending on sandbox restrictions</haxe_doc>
	</fileName>
</a></typedef>
	<class path="hxd.File" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/File.hx">
		<browse public="1" set="method" line="75" static="1"><f a="onSelect:?options">
	<f a="">
		<t path="hxd.BrowseSelect"/>
		<x path="Void"/>
	</f>
	<x path="Null"><t path="hxd.BrowseOptions"/></x>
	<x path="Void"/>
</f></browse>
		<saveAs public="1" set="method" line="205" static="1"><f a="dataContent:?options">
	<c path="haxe.io.Bytes"/>
	<x path="Null"><t path="hxd.BrowseOptions"/></x>
	<x path="Void"/>
</f></saveAs>
		<exists public="1" set="method" line="243" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<delete public="1" set="method" line="254" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></delete>
		<listDirectory public="1" set="method" line="267" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></listDirectory>
		<getBytes public="1" set="method" line="281" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveBytes public="1" set="method" line="310" static="1"><f a="path:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<load public="1" set="method" line="326" static="1"><f a="path:onLoad:?onError">
	<c path="String"/>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<createDirectory public="1" set="method" line="349" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<applicationPath public="1" set="method" line="359" static="1"><f a=""><c path="String"/></f></applicationPath>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd._FloatBuffer.InnerData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer"><c path="Array"><t path="hxd.impl.Float32"/></c></typedef>
	<class path="hxd._FloatBuffer.InnerIterator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
		<b><t path="hxd._FloatBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="55"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="58"><f a=""><t path="hxd.impl.Float32"/></f></next>
		<new public="1" get="inline" set="null" line="50"><f a="b">
	<t path="hxd._FloatBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.FloatBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/FloatBuffer.hx">
		<this><t path="hxd._FloatBuffer.InnerData"/></this>
		<impl><class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="67" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.FloatBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="76" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd.impl.Float32"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="84" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<resize public="1" get="inline" set="null" line="95" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</resize>
	<arrayRead get="inline" set="null" line="104" static="1">
		<f a="this:key">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="108" static="1">
		<f a="this:key:value">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="112" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd._FloatBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="116" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<c path="hxd._FloatBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="120" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="67" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="76" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="84" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<resize public="1" get="inline" set="null" line="95" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</resize>
		<arrayRead get="inline" set="null" line="104" static="1">
			<f a="this:key">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="108" static="1">
			<f a="this:key:value">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="112" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd._FloatBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="116" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<c path="hxd._FloatBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="120" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<typedef path="hxd._IndexBuffer.InnerData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer"><c path="Array"><t path="hxd.impl.UInt16"/></c></typedef>
	<class path="hxd._IndexBuffer.InnerIterator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
		<b><t path="hxd._IndexBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="14"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="17"><f a=""><x path="Int"/></f></next>
		<new public="1" get="inline" set="null" line="9"><f a="b">
	<t path="hxd._IndexBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.IndexBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/IndexBuffer.hx">
		<this><t path="hxd._IndexBuffer.InnerData"/></this>
		<impl><class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.IndexBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="37" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="45" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<arrayRead get="inline" set="null" line="55" static="1">
		<f a="this:key">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="59" static="1">
		<f a="this:key:value">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="63" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<t path="hxd._IndexBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<c path="hxd._IndexBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="71" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.IndexBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="37" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="45" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<arrayRead get="inline" set="null" line="55" static="1">
			<f a="this:key">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="59" static="1">
			<f a="this:key:value">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="63" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<t path="hxd._IndexBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<c path="hxd._IndexBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="71" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<class path="hxd.Key" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Key.hx">
		<BACKSPACE public="1" get="inline" set="null" expr="8" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="9" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TAB>
		<ENTER public="1" get="inline" set="null" expr="13" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</ENTER>
		<SHIFT public="1" get="inline" set="null" expr="16" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHIFT>
		<CTRL public="1" get="inline" set="null" expr="17" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CTRL>
		<ALT public="1" get="inline" set="null" expr="18" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ALT>
		<ESCAPE public="1" get="inline" set="null" expr="27" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="32" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SPACE>
		<PGUP public="1" get="inline" set="null" expr="33" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33</e></m></meta>
		</PGUP>
		<PGDOWN public="1" get="inline" set="null" expr="34" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
		</PGDOWN>
		<END public="1" get="inline" set="null" expr="35" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35</e></m></meta>
		</END>
		<HOME public="1" get="inline" set="null" expr="36" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36</e></m></meta>
		</HOME>
		<LEFT public="1" get="inline" set="null" expr="37" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37</e></m></meta>
		</LEFT>
		<UP public="1" get="inline" set="null" expr="38" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>38</e></m></meta>
		</UP>
		<RIGHT public="1" get="inline" set="null" expr="39" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>39</e></m></meta>
		</RIGHT>
		<DOWN public="1" get="inline" set="null" expr="40" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>40</e></m></meta>
		</DOWN>
		<INSERT public="1" get="inline" set="null" expr="45" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>45</e></m></meta>
		</INSERT>
		<DELETE public="1" get="inline" set="null" expr="46" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>46</e></m></meta>
		</DELETE>
		<QWERTY_EQUALS public="1" get="inline" set="null" expr="187" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>187</e></m></meta>
		</QWERTY_EQUALS>
		<QWERTY_MINUS public="1" get="inline" set="null" expr="189" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>189</e></m></meta>
		</QWERTY_MINUS>
		<QWERTY_TILDE public="1" get="inline" set="null" expr="192" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>192</e></m></meta>
		</QWERTY_TILDE>
		<QWERTY_BRACKET_LEFT public="1" get="inline" set="null" expr="219" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>219</e></m></meta>
		</QWERTY_BRACKET_LEFT>
		<QWERTY_BRACKET_RIGHT public="1" get="inline" set="null" expr="221" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>221</e></m></meta>
		</QWERTY_BRACKET_RIGHT>
		<QWERTY_SEMICOLON public="1" get="inline" set="null" expr="186" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>186</e></m></meta>
		</QWERTY_SEMICOLON>
		<QWERTY_QUOTE public="1" get="inline" set="null" expr="222" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>222</e></m></meta>
		</QWERTY_QUOTE>
		<QWERTY_BACKSLASH public="1" get="inline" set="null" expr="220" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>220</e></m></meta>
		</QWERTY_BACKSLASH>
		<QWERTY_COMMA public="1" get="inline" set="null" expr="188" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>188</e></m></meta>
		</QWERTY_COMMA>
		<QWERTY_PERIOD public="1" get="inline" set="null" expr="190" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>190</e></m></meta>
		</QWERTY_PERIOD>
		<QWERTY_SLASH public="1" get="inline" set="null" expr="191" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>191</e></m></meta>
		</QWERTY_SLASH>
		<INTL_BACKSLASH public="1" get="inline" set="null" expr="226" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>226</e></m></meta>
		</INTL_BACKSLASH>
		<LEFT_WINDOW_KEY public="1" get="inline" set="null" expr="91" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>91</e></m></meta>
		</LEFT_WINDOW_KEY>
		<RIGHT_WINDOW_KEY public="1" get="inline" set="null" expr="92" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>92</e></m></meta>
		</RIGHT_WINDOW_KEY>
		<CONTEXT_MENU public="1" get="inline" set="null" expr="93" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>93</e></m></meta>
		</CONTEXT_MENU>
		<PAUSE_BREAK public="1" get="inline" set="null" expr="19" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</PAUSE_BREAK>
		<CAPS_LOCK public="1" get="inline" set="null" expr="20" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</CAPS_LOCK>
		<NUM_LOCK public="1" get="inline" set="null" expr="144" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>144</e></m></meta>
		</NUM_LOCK>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="145" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>145</e></m></meta>
		</SCROLL_LOCK>
		<NUMBER_0 public="1" get="inline" set="null" expr="48" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>48</e></m></meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="49" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>49</e></m></meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="50" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>50</e></m></meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="51" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>51</e></m></meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="52" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>52</e></m></meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="53" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>53</e></m></meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="54" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>54</e></m></meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="55" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>55</e></m></meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="56" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="57" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>57</e></m></meta>
		</NUMBER_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="96" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>96</e></m></meta>
		</NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" expr="97" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>97</e></m></meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="98" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>98</e></m></meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="99" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>99</e></m></meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="100" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="101" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>101</e></m></meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="102" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>102</e></m></meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="103" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>103</e></m></meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="104" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="105" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>105</e></m></meta>
		</NUMPAD_9>
		<A public="1" get="inline" set="null" expr="65" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="66" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>66</e></m></meta>
		</B>
		<C public="1" get="inline" set="null" expr="67" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>67</e></m></meta>
		</C>
		<D public="1" get="inline" set="null" expr="68" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>68</e></m></meta>
		</D>
		<E public="1" get="inline" set="null" expr="69" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>69</e></m></meta>
		</E>
		<F public="1" get="inline" set="null" expr="70" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>70</e></m></meta>
		</F>
		<G public="1" get="inline" set="null" expr="71" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>71</e></m></meta>
		</G>
		<H public="1" get="inline" set="null" expr="72" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>72</e></m></meta>
		</H>
		<I public="1" get="inline" set="null" expr="73" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>73</e></m></meta>
		</I>
		<J public="1" get="inline" set="null" expr="74" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>74</e></m></meta>
		</J>
		<K public="1" get="inline" set="null" expr="75" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>75</e></m></meta>
		</K>
		<L public="1" get="inline" set="null" expr="76" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>76</e></m></meta>
		</L>
		<M public="1" get="inline" set="null" expr="77" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>77</e></m></meta>
		</M>
		<N public="1" get="inline" set="null" expr="78" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>78</e></m></meta>
		</N>
		<O public="1" get="inline" set="null" expr="79" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>79</e></m></meta>
		</O>
		<P public="1" get="inline" set="null" expr="80" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
		</P>
		<Q public="1" get="inline" set="null" expr="81" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>81</e></m></meta>
		</Q>
		<R public="1" get="inline" set="null" expr="82" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>82</e></m></meta>
		</R>
		<S public="1" get="inline" set="null" expr="83" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>83</e></m></meta>
		</S>
		<T public="1" get="inline" set="null" expr="84" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>84</e></m></meta>
		</T>
		<U public="1" get="inline" set="null" expr="85" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>85</e></m></meta>
		</U>
		<V public="1" get="inline" set="null" expr="86" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>86</e></m></meta>
		</V>
		<W public="1" get="inline" set="null" expr="87" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>87</e></m></meta>
		</W>
		<X public="1" get="inline" set="null" expr="88" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>88</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="89" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>89</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="90" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>90</e></m></meta>
		</Z>
		<F1 public="1" get="inline" set="null" expr="112" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>112</e></m></meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="113" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>113</e></m></meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="114" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>114</e></m></meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="115" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>115</e></m></meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="116" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>116</e></m></meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="117" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>117</e></m></meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="118" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>118</e></m></meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="119" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>119</e></m></meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="120" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="121" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>121</e></m></meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="122" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>122</e></m></meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="123" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>123</e></m></meta>
		</F12>
		<F13 public="1" get="inline" set="null" expr="124" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>124</e></m></meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="125" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>125</e></m></meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="126" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>126</e></m></meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="127" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>127</e></m></meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="128" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="129" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>129</e></m></meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="130" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>130</e></m></meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="131" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>131</e></m></meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="132" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>132</e></m></meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="133" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>133</e></m></meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="134" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>134</e></m></meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="135" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>135</e></m></meta>
		</F24>
		<NUMPAD_MULT public="1" get="inline" set="null" expr="106" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>106</e></m></meta>
		</NUMPAD_MULT>
		<NUMPAD_ADD public="1" get="inline" set="null" expr="107" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>107</e></m></meta>
		</NUMPAD_ADD>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="108" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>108</e></m></meta>
		</NUMPAD_ENTER>
		<NUMPAD_SUB public="1" get="inline" set="null" expr="109" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</NUMPAD_SUB>
		<NUMPAD_DOT public="1" get="inline" set="null" expr="110" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>110</e></m></meta>
		</NUMPAD_DOT>
		<NUMPAD_DIV public="1" get="inline" set="null" expr="111" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</NUMPAD_DIV>
		<MOUSE_LEFT public="1" get="inline" set="null" expr="0" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</MOUSE_LEFT>
		<MOUSE_RIGHT public="1" get="inline" set="null" expr="1" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MOUSE_RIGHT>
		<MOUSE_MIDDLE public="1" get="inline" set="null" expr="2" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</MOUSE_MIDDLE>
		<MOUSE_BACK public="1" get="inline" set="null" expr="3" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MOUSE_BACK>
		<MOUSE_FORWARD public="1" get="inline" set="null" expr="4" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MOUSE_FORWARD>
		<MOUSE_WHEEL_UP public="1" get="inline" set="null" expr="5" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
			<haxe_doc>* Mouse wheel does not have an off signal, and should be checked only trough `isPressed` method.
	 * Note that there may be multiple wheel scrolls between 2 frames, and to receive more accurate
	 * results, it is recommended to directly listen to wheel events which also provide OS-generated wheel delta value.
	 * See `Interactive.onWheel` for per-interactive events. For scene-based see `Scene.addEventListener`
	 * when event is `EWheel`. For global hook use `Window.addEventTarget` method.</haxe_doc>
		</MOUSE_WHEEL_UP>
		<MOUSE_WHEEL_DOWN public="1" get="inline" set="null" expr="6" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
			<haxe_doc>* Mouse wheel does not have an off signal, and should be checked only trough `isPressed` method.
	 * Note that there may be multiple wheel scrolls between 2 frames, and to receive more accurate
	 * results, it is recommended to directly listen to wheel events which also provide OS-generated wheel delta value.
	 * See `Interactive.onWheel` for per-interactive events. For scene-based see `Scene.addEventListener`
	 * when event is `EWheel`. For global hook use `Window.addEventTarget` method.</haxe_doc>
		</MOUSE_WHEEL_DOWN>
		<LOC_LEFT public="1" get="inline" set="null" expr="256" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
			<haxe_doc>a bit that is set for left keys</haxe_doc>
		</LOC_LEFT>
		<LOC_RIGHT public="1" get="inline" set="null" expr="512" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
			<haxe_doc>a bit that is set for right keys</haxe_doc>
		</LOC_RIGHT>
		<LSHIFT public="1" get="inline" set="null" expr="SHIFT | LOC_LEFT" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>SHIFT | LOC_LEFT</e></m></meta>
		</LSHIFT>
		<RSHIFT public="1" get="inline" set="null" expr="SHIFT | LOC_RIGHT" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>SHIFT | LOC_RIGHT</e></m></meta>
		</RSHIFT>
		<LCTRL public="1" get="inline" set="null" expr="CTRL | LOC_LEFT" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>CTRL | LOC_LEFT</e></m></meta>
		</LCTRL>
		<RCTRL public="1" get="inline" set="null" expr="CTRL | LOC_RIGHT" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>CTRL | LOC_RIGHT</e></m></meta>
		</RCTRL>
		<LALT public="1" get="inline" set="null" expr="ALT | LOC_LEFT" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>ALT | LOC_LEFT</e></m></meta>
		</LALT>
		<RALT public="1" get="inline" set="null" expr="ALT | LOC_RIGHT" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>ALT | LOC_RIGHT</e></m></meta>
		</RALT>
		<initDone expr="false" line="168" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initDone>
		<keyPressed expr="[]" line="169" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</keyPressed>
		<ALLOW_KEY_REPEAT public="1" expr="false" line="177" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>This enable the native key repeat behavior, and will
		report several times isPressed() in case a key is kept
		pressed for a long time if this is allowed by the target
		platform.</haxe_doc>
		</ALLOW_KEY_REPEAT>
		<isDown public="1" set="method" line="179" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isDown>
		<getFrame public="1" get="inline" set="null" line="183" static="1"><f a=""><x path="Int"/></f></getFrame>
		<isPressed public="1" set="method" line="187" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isPressed>
		<isReleased public="1" set="method" line="191" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isReleased>
		<initialize public="1" set="method" line="195" static="1"><f a=""><x path="Void"/></f></initialize>
		<dispose public="1" set="method" line="206" static="1"><f a=""><x path="Void"/></f></dispose>
		<onEvent set="method" line="223" static="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onEvent>
		<getKeyName public="1" set="method" line="240" static="1"><f a="keyCode">
	<x path="Int"/>
	<x path="Null"><c path="String"/></x>
</f></getKeyName>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Math" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Math.hx">
		<PI public="1" get="inline" set="null" expr="3.14159265358979323" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3.14159265358979323</e></m></meta>
		</PI>
		<EPSILON public="1" get="inline" set="null" expr="1e-10" line="6" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-10</e></m></meta>
		</EPSILON>
		<POSITIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></NEGATIVE_INFINITY>
		<NaN public="1" get="accessor" set="null" static="1"><x path="Float"/></NaN>
		<get_POSITIVE_INFINITY get="inline" set="null" line="12" static="1"><f a=""><x path="Float"/></f></get_POSITIVE_INFINITY>
		<get_NEGATIVE_INFINITY get="inline" set="null" line="16" static="1"><f a=""><x path="Float"/></f></get_NEGATIVE_INFINITY>
		<get_NaN get="inline" set="null" line="20" static="1"><f a=""><x path="Float"/></f></get_NaN>
		<isNaN public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<fmt public="1" set="method" line="29" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fmt>
		<floor public="1" get="inline" set="null" line="47" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<ceil public="1" get="inline" set="null" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<round public="1" get="inline" set="null" line="55" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<clamp public="1" get="inline" set="null" line="59" static="1">
			<f a="f:?min:?max" v=":0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1., min : 0. }</e></m></meta>
		</clamp>
		<pow public="1" get="inline" set="null" line="63" static="1"><f a="v:p">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<scaleTime public="1" get="inline" set="null" line="67" static="1"><f a="v:et">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></scaleTime>
		<cos public="1" get="inline" set="null" line="71" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<sin public="1" get="inline" set="null" line="75" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<tan public="1" get="inline" set="null" line="79" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<acos public="1" get="inline" set="null" line="83" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" get="inline" set="null" line="87" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" get="inline" set="null" line="91" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<sqrt public="1" get="inline" set="null" line="95" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invSqrt public="1" get="inline" set="null" line="99" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></invSqrt>
		<atan2 public="1" get="inline" set="null" line="103" static="1"><f a="dy:dx">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<abs public="1" get="inline" set="null" line="107" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<max public="1" get="inline" set="null" line="111" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" get="inline" set="null" line="115" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<iabs public="1" get="inline" set="null" line="119" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></iabs>
		<imax public="1" get="inline" set="null" line="123" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imax>
		<imin public="1" get="inline" set="null" line="127" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imin>
		<iclamp public="1" get="inline" set="null" line="131" static="1"><f a="v:min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></iclamp>
		<lerp public="1" get="inline" set="null" line="138" static="1">
			<f a="a:b:k">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Linear interpolation between two values. When k is 0 a is returned, when it's 1, b is returned.</haxe_doc>
		</lerp>
		<bitCount public="1" get="inline" set="null" line="142" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></bitCount>
		<isPOT public="1" get="inline" set="null" line="148" static="1"><f a="v">
	<x path="Int"/>
	<x path="Bool"/>
</f></isPOT>
		<nextPOT public="1" get="inline" set="null" line="152" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></nextPOT>
		<distanceSq public="1" get="inline" set="null" line="162" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distanceSq>
		<distance public="1" get="inline" set="null" line="166" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distance>
		<colorLerp public="1" set="method" line="173" static="1">
			<f a="c1:c2:k">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Linear interpolation between two colors (ARGB).</haxe_doc>
		</colorLerp>
		<angle public="1" get="inline" set="null" line="192" static="1"><f a="da">
	<x path="Float"/>
	<x path="Float"/>
</f></angle>
		<angleLerp public="1" get="inline" set="null" line="198" static="1"><f a="a:b:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></angleLerp>
		<angleMove public="1" get="inline" set="null" line="205" static="1">
			<f a="a:b:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Move angle a towards angle b with a max increment. Return the new angle.</haxe_doc>
		</angleMove>
		<shuffle public="1" params="T" get="inline" set="null" line="210" static="1"><f a="a">
	<c path="Array"><c path="shuffle.T"/></c>
	<x path="Void"/>
</f></shuffle>
		<random public="1" get="inline" set="null" line="221" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
		</random>
		<srand public="1" set="method" line="228" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
			<haxe_doc>Returns a signed random between -max and max (both included).</haxe_doc>
		</srand>
		<b2f public="1" get="inline" set="null" line="238" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* takes an int , masks it and devide so that it safely maps 0...255 to 0...1.0
	 * @paramv an int between 0 and 255 will be masked
	 * @return a float between( 0 and 1)</haxe_doc>
		</b2f>
		<f2b public="1" get="inline" set="null" line="247" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* takes a float , clamps it and multipy so that it safely maps 0...1 to 0...255.0
	 * @param	f a float
	 * @return an int [0...255]</haxe_doc>
		</f2b>
		<umod public="1" get="inline" set="null" line="254" static="1">
			<f a="value:modulo">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</umod>
		<ufmod public="1" get="inline" set="null" line="262" static="1">
			<f a="value:modulo">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</ufmod>
		<degToRad public="1" get="inline" set="null" line="270" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert degrees to radians</haxe_doc>
		</degToRad>
		<radToDeg public="1" get="inline" set="null" line="277" static="1">
			<f a="rad">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert radians to degrees</haxe_doc>
		</radToDeg>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Flags" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<ReadOnly/>
		<AlphaPremultiplied/>
		<FlipY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="hxd.PixelsARGB" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta><m n=":forward">
	<e>bytes</e>
	<e>width</e>
	<e>height</e>
	<e>offset</e>
	<e>flags</e>
	<e>clear</e>
	<e>dispose</e>
	<e>toPNG</e>
	<e>clone</e>
	<e>toVector</e>
	<e>sub</e>
	<e>blit</e>
</m></meta>
		<impl><class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
	<getPixel public="1" get="inline" set="null" line="13" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixel>
	<setPixel public="1" get="inline" set="null" line="17" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixel>
	<fromPixels public="1" set="method" line="21" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
		<getPixel public="1" get="inline" set="null" line="13" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixel>
		<setPixel public="1" get="inline" set="null" line="17" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixel>
		<fromPixels public="1" set="method" line="21" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.PixelsFloat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta>
			<m n=":forward">
				<e>bytes</e>
				<e>format</e>
				<e>width</e>
				<e>height</e>
				<e>offset</e>
				<e>flags</e>
				<e>clear</e>
				<e>dispose</e>
				<e>toPNG</e>
				<e>clone</e>
				<e>toVector</e>
				<e>sub</e>
				<e>blit</e>
				<e>invalidFormat</e>
				<e>willChange</e>
			</m>
			<m n=":access"><e>hxd.Pixels</e></m>
		</meta>
		<impl><class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
	<getPixelF public="1" get="inline" set="null" line="32" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixelF>
	<setPixelF public="1" get="inline" set="null" line="46" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixelF>
	<fromPixels public="1" set="method" line="62" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsFloat"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
	<convert public="1" set="method" line="67" static="1">
		<f a="this:target">
			<c path="hxd.Pixels"/>
			<e path="hxd.PixelFormat"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</convert>
	<meta><m n=":access"><e>hxd.Pixels</e></m></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
		<getPixelF public="1" get="inline" set="null" line="32" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixelF>
		<setPixelF public="1" get="inline" set="null" line="46" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixelF>
		<fromPixels public="1" set="method" line="62" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsFloat"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
		<convert public="1" set="method" line="67" static="1">
			<f a="this:target">
				<c path="hxd.Pixels"/>
				<e path="hxd.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</convert>
		<meta><m n=":access"><e>hxd.Pixels</e></m></meta>
	</class>
	<abstract path="hxd.Channel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd._Pixels.Channel_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
	<R public="1" get="inline" set="null" expr="cast 0" line="90" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<G public="1" get="inline" set="null" expr="cast 1" line="91" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<B public="1" get="inline" set="null" expr="cast 2" line="92" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<A public="1" get="inline" set="null" expr="cast 3" line="93" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<toInt public="1" get="inline" set="null" line="94" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<fromInt public="1" get="inline" set="null" line="95" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.Channel_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels" final="1">
		<R public="1" get="inline" set="null" expr="cast 0" line="90" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<G public="1" get="inline" set="null" expr="cast 1" line="91" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<B public="1" get="inline" set="null" expr="cast 2" line="92" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<A public="1" get="inline" set="null" expr="cast 3" line="93" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<toInt public="1" get="inline" set="null" line="94" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<fromInt public="1" get="inline" set="null" line="95" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.Pixels" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Pixels.hx">
		<switchEndian public="1" get="inline" set="null" line="119" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchEndian>
		<switchBR public="1" get="inline" set="null" line="123" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchBR>
		<calcStride public="1" set="method" line="466" static="1"><f a="width:format">
	<x path="Int"/>
	<e path="hxd.PixelFormat"/>
	<x path="Int"/>
</f></calcStride>
		<S3TC_SIZES expr="[0, -1, 1, 1, -1, 1, 1, 1]" line="489" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, -1, 1, 1, -1, 1, 1, 1]</e></m></meta>
		</S3TC_SIZES>
		<getChannelOffset public="1" set="method" line="495" static="1">
			<f a="format:channel">
				<e path="hxd.PixelFormat"/>
				<x path="hxd.Channel"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte offset for the requested channel (0=R,1=G,2=B,3=A)
		Returns -1 if the channel is not found</haxe_doc>
		</getChannelOffset>
		<alloc public="1" set="method" line="522" static="1"><f a="width:height:format">
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.PixelFormat"/>
	<c path="hxd.Pixels"/>
</f></alloc>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<format public="1" get="accessor" set="null"><e path="hxd.PixelFormat"/></format>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<stride public="1" set="null"><x path="Int"/></stride>
		<offset public="1"><x path="Int"/></offset>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.Flags"/></x></flags>
		<bytesPerPixel><x path="Int"/></bytesPerPixel>
		<innerFormat set="accessor"><e path="hxd.PixelFormat"/></innerFormat>
		<get_format get="inline" set="null" line="127"><f a=""><e path="hxd.PixelFormat"/></f></get_format>
		<set_innerFormat set="method" line="129"><f a="fmt">
	<e path="hxd.PixelFormat"/>
	<e path="hxd.PixelFormat"/>
</f></set_innerFormat>
		<invalidFormat set="method" line="136"><f a=""><x path="Void"/></f></invalidFormat>
		<sub public="1" set="method" line="140"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
</f></sub>
		<yflip get="inline" set="null" line="154"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></yflip>
		<blit public="1" set="method" line="158"><f a="x:y:src:srcX:srcY:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<clear public="1" set="method" line="176">
			<f a="color:?preserveMask" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preserveMask : 0 }</e></m></meta>
		</clear>
		<toVector public="1" set="method" line="224"><f a=""><x path="haxe.ds.Vector"><x path="Int"/></x></f></toVector>
		<makeSquare public="1" set="method" line="266"><f a="?copy">
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></makeSquare>
		<copyInner set="method" line="296"><f a=""><x path="Void"/></f></copyInner>
		<willChange get="inline" set="null" line="304"><f a=""><x path="Void"/></f></willChange>
		<setFlip public="1" set="method" line="308"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlip>
		<convert public="1" set="method" line="328"><f a="target">
	<e path="hxd.PixelFormat"/>
	<x path="Void"/>
</f></convert>
		<getPixel public="1" set="method" line="405"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<setPixel public="1" set="method" line="420"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<dispose public="1" set="method" line="435"><f a=""><x path="Void"/></f></dispose>
		<toPNG public="1" set="method" line="439">
			<f a="?level" v="9">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</toPNG>
		<clone public="1" set="method" line="454"><f a=""><c path="hxd.Pixels"/></f></clone>
		<new public="1" set="method" line="110">
			<f a="width:height:bytes:format:?offset" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<e path="hxd.PixelFormat"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="hxd.SceneEvents" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/SceneEvents.hx">
		<window><c path="hxd.Window"/></window>
		<scenes><c path="Array"><c path="hxd.InteractiveScene"/></c></scenes>
		<overList><c path="Array"><c path="hxd.Interactive"/></c></overList>
		<overCandidates><c path="Array"><a>
	<z><x path="Float"/></z>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<s><c path="hxd.InteractiveScene"/></s>
	<i><c path="hxd.Interactive"/></i>
</a></c></overCandidates>
		<overIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</overIndex>
		<currentFocus><c path="hxd.Interactive"/></currentFocus>
		<pendingEvents><c path="Array"><c path="hxd.Event"/></c></pendingEvents>
		<pushList><c path="Array"><c path="hxd.Interactive"/></c></pushList>
		<currentDrag><a>
	<ref><x path="Null"><x path="Int"/></x></ref>
	<onCancel><f a=""><x path="Void"/></f></onCancel>
	<f><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></f>
</a></currentDrag>
		<mouseX expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseX>
		<mouseY expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseY>
		<lastTouch expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastTouch>
		<focusLost expr="new hxd.Event(EFocusLost)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EFocusLost)</e></m></meta>
		</focusLost>
		<checkPos expr="new hxd.Event(ECheck)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(ECheck)</e></m></meta>
		</checkPos>
		<onOut expr="new hxd.Event(EOut)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EOut)</e></m></meta>
		</onOut>
		<onOver expr="new hxd.Event(EOver)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EOver)</e></m></meta>
		</onOver>
		<isOut expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isOut>
		<enablePhysicalMouse public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enablePhysicalMouse : enable mouse movements of system mouse, set it to false anse use setMousePos instead to manually set mouse position</haxe_doc>
		</enablePhysicalMouse>
		<mouseCheckMove public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enable/disable per frame check of elements under mouse (default:true)</haxe_doc>
		</mouseCheckMove>
		<defaultCursor public="1" set="accessor" expr="Default">
			<e path="hxd.Cursor"/>
			<meta><m n=":value"><e>Default</e></m></meta>
			<haxe_doc>* Default cursor when there is no Interactive present under cursor.</haxe_doc>
		</defaultCursor>
		<setMousePos public="1" set="method" line="69"><f a="xPos:yPos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMousePos>
		<onRemove set="method" line="74"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></onRemove>
		<addScene public="1" set="method" line="92"><f a="s:?index">
	<c path="hxd.InteractiveScene"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addScene>
		<removeScene public="1" set="method" line="97"><f a="s">
	<c path="hxd.InteractiveScene"/>
	<x path="Void"/>
</f></removeScene>
		<dispose public="1" set="method" line="101"><f a=""><x path="Void"/></f></dispose>
		<focus public="1" set="method" line="105"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></focus>
		<blur public="1" set="method" line="122"><f a=""><x path="Void"/></f></blur>
		<checkFocus set="method" line="131"><f a=""><x path="Void"/></f></checkFocus>
		<emitEvent set="method" line="142"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></emitEvent>
		<checkEvents public="1" set="method" line="309"><f a=""><x path="Void"/></f></checkEvents>
		<startDrag public="1" set="method" line="382"><f a="f:?onCancel:?refEvent">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="388"><f a=""><x path="Void"/></f></stopDrag>
		<getFocus public="1" set="method" line="394"><f a=""><c path="hxd.Interactive"/></f></getFocus>
		<updateCursor public="1" set="method" line="398"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></updateCursor>
		<set_defaultCursor set="method" line="402"><f a="c">
	<e path="hxd.Cursor"/>
	<e path="hxd.Cursor"/>
</f></set_defaultCursor>
		<selectCursor set="method" line="410"><f a=""><x path="Void"/></f></selectCursor>
		<onEvent set="method" line="424"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onEvent>
		<dispatchListeners set="method" line="429"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<new public="1" set="method" line="58"><f a="?window">
	<c path="hxd.Window"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Platform" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/System.hx" module="hxd.System">
		<IOS/>
		<Android/>
		<WebGL/>
		<PC/>
		<Console/>
		<FlashPlayer/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxd.SystemValue" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/System.hx" module="hxd.System">
		<IsTouch/>
		<IsWindowed/>
		<IsMobile/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.System" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/System.hx">
		<width public="1" get="accessor" set="null" static="1"><x path="Int"/></width>
		<height public="1" get="accessor" set="null" static="1"><x path="Int"/></height>
		<lang public="1" get="accessor" set="null" static="1"><c path="String"/></lang>
		<platform public="1" get="accessor" set="null" static="1"><e path="hxd.Platform"/></platform>
		<screenDPI public="1" get="accessor" set="null" static="1"><x path="Float"/></screenDPI>
		<setCursor public="1" expr="setNativeCursor" line="29" static="1">
			<f a="">
				<e path="hxd.Cursor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>setNativeCursor</e></m></meta>
			<haxe_doc>Sets current cursor and can be replaced by custom function to manually operate displayed cursor.
		When called, it should call `hxd.System.setNativeCursor` and pass desired `hxd.Cursor` to it.</haxe_doc>
		</setCursor>
		<allowTimeout public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<haxe_doc>Can be used to temporarly disable infinite loop check</haxe_doc>
		</allowTimeout>
		<timeoutTick public="1" set="method" line="39" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you have a time consuming calculus that might trigger a timeout, you can either disable timeouts with [allowTimeout] or call timeoutTick() frequently.</haxe_doc>
		</timeoutTick>
		<loopFunc static="1"><f a=""><x path="Void"/></f></loopFunc>
		<getCurrentLoop public="1" set="method" line="44" static="1"><f a=""><f a=""><x path="Void"/></f></f></getCurrentLoop>
		<setLoop public="1" set="method" line="48" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></setLoop>
		<start public="1" set="method" line="52" static="1"><f a="callb">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></start>
		<setNativeCursor public="1" set="method" line="60" static="1">
			<f a="c">
				<e path="hxd.Cursor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets currently shown cursor.
		This method is designated to be used by custom `hxd.System.setCursor`.
		Calling it outside of automated Interactive cursor update system leads to undefined behavior, and not advised.</haxe_doc>
		</setNativeCursor>
		<getDeviceName public="1" set="method" line="63" static="1"><f a=""><c path="String"/></f></getDeviceName>
		<getDefaultFrameRate public="1" set="method" line="67" static="1"><f a=""><x path="Float"/></f></getDefaultFrameRate>
		<getValue public="1" set="method" line="71" static="1"><f a="s">
	<e path="hxd.SystemValue"/>
	<x path="Bool"/>
</f></getValue>
		<exit public="1" set="method" line="75" static="1"><f a=""><x path="Void"/></f></exit>
		<openURL public="1" set="method" line="78" static="1"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></openURL>
		<get_width set="method" line="82" static="1"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="83" static="1"><f a=""><x path="Int"/></f></get_height>
		<get_lang set="method" line="84" static="1"><f a=""><c path="String"/></f></get_lang>
		<get_platform set="method" line="85" static="1"><f a=""><e path="hxd.Platform"/></f></get_platform>
		<get_screenDPI set="method" line="86" static="1"><f a=""><x path="Int"/></f></get_screenDPI>
		<get_allowTimeout set="method" line="87" static="1"><f a=""><x path="Bool"/></f></get_allowTimeout>
		<set_allowTimeout set="method" line="88" static="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowTimeout>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Timer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Timer.hx">
		<wantedFPS public="1" expr="60." line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>60.</e></m></meta>
			<haxe_doc>The FPS on which "tmod" have values are based on.
		Can be freely configured if your gameplay runs at a different speed.
		Default : 60</haxe_doc>
		</wantedFPS>
		<maxDeltaTime public="1" expr="0.5" line="21" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>The maximum amount of time between two frames (in seconds).
		If the time exceed this amount, Timer will consider these lags are to be ignored.
		Default : 0.5</haxe_doc>
		</maxDeltaTime>
		<smoothFactor public="1" expr="0.95" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.95</e></m></meta>
			<haxe_doc>The smoothing done between frames. A smoothing of 0 gives "real time" values, higher values will smooth
		the results for tmod/dt/fps over frames using the formula   dt = lerp(dt, elapsedTime, smoothFactor)
		Default : 0 on HashLink, 0.95 on other platforms</haxe_doc>
		</smoothFactor>
		<lastTimeStamp public="1" set="null" expr="haxe.Timer.stamp()" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>haxe.Timer.stamp()</e></m></meta>
			<haxe_doc>The last timestamp in which update() function was called.</haxe_doc>
		</lastTimeStamp>
		<elapsedTime public="1" set="null" expr="0." line="38" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The amount of time (unsmoothed) that was spent since the last frame.</haxe_doc>
		</elapsedTime>
		<frameCount public="1" expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>A frame counter, increases on each call to update()</haxe_doc>
		</frameCount>
		<dt public="1" expr="1 / wantedFPS" line="49" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
			<haxe_doc>The smoothed elapsed time (in seconds).</haxe_doc>
		</dt>
		<tmod public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The smoothed frame modifier, based on wantedFPS. Its value is the same as dt/wantedFPS
		Allows to express movements in terms of pixels-per-frame-at-wantedFPS instead of per second.</haxe_doc>
		</tmod>
		<currentDT expr="1 / wantedFPS" line="57" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
		</currentDT>
		<update public="1" set="method" line="62" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Update the timer calculus on each frame. This is automatically called by hxd.App</haxe_doc>
		</update>
		<get_tmod get="inline" set="null" line="74" static="1"><f a=""><x path="Float"/></f></get_tmod>
		<set_tmod get="inline" set="null" line="78" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tmod>
		<fps public="1" set="method" line="86" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>The current smoothed FPS.</haxe_doc>
		</fps>
		<skip public="1" set="method" line="95" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>After some loading / long processing, call skip() in order to prevent
		it from impacting your smoothed values.</haxe_doc>
		</skip>
		<reset public="1" set="method" line="103" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Similar as skip() but also reset dt to default value.
		Can be used when starting a new game if you want to discard any previous measurement.</haxe_doc>
		</reset>
		<haxe_doc>The Timer class acts as a global time measurement that can be accessed from various parts of the engine.
	These three values are representation of the same underlying calculus: tmod, dt, fps</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.DisplayMode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Window.hx" module="hxd.Window">
		<Windowed/>
		<Borderless/>
		<Fullscreen/>
		<FullscreenResize/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.Window" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/Window.hx">
		<inst expr="null" line="76" static="1">
			<c path="hxd.Window"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<getInstance public="1" set="method" line="77" static="1"><f a=""><c path="hxd.Window"/></f></getInstance>
		<resizeEvents><t path="List"><f a=""><x path="Void"/></f></t></resizeEvents>
		<eventTargets><t path="List"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></t></eventTargets>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<mouseX public="1" get="accessor" set="null"><x path="Int"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Int"/></mouseY>
		<mouseLock public="1" get="accessor" set="accessor"><x path="Bool"/></mouseLock>
		<vsync public="1" get="accessor" set="accessor"><x path="Bool"/></vsync>
		<isFocused public="1" get="accessor" set="null"><x path="Bool"/></isFocused>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<displayMode public="1" get="accessor" set="accessor"><e path="hxd.DisplayMode"/></displayMode>
		<onClose public="1" set="dynamic" line="31"><f a=""><x path="Bool"/></f></onClose>
		<event public="1" set="method" line="35"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></event>
		<addEventTarget public="1" set="method" line="40"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addEventTarget>
		<removeEventTarget public="1" set="method" line="44"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeEventTarget>
		<addResizeEvent public="1" set="method" line="52"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></addResizeEvent>
		<removeResizeEvent public="1" set="method" line="56"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></removeResizeEvent>
		<onResize set="method" line="64"><f a="e">
	<d/>
	<x path="Void"/>
</f></onResize>
		<resize public="1" set="method" line="69"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setFullScreen public="1" set="method" line="73">
			<f a="v">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use the displayMode property instead"</e></m></meta>
		</setFullScreen>
		<get_mouseX set="method" line="82"><f a=""><x path="Int"/></f></get_mouseX>
		<get_mouseY set="method" line="86"><f a=""><x path="Int"/></f></get_mouseY>
		<get_width set="method" line="90"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="94"><f a=""><x path="Int"/></f></get_height>
		<get_mouseLock set="method" line="98"><f a=""><x path="Bool"/></f></get_mouseLock>
		<set_mouseLock set="method" line="102"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseLock>
		<get_vsync set="method" line="107"><f a=""><x path="Bool"/></f></get_vsync>
		<set_vsync set="method" line="109"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_vsync>
		<get_isFocused set="method" line="114"><f a=""><x path="Bool"/></f></get_isFocused>
		<get_displayMode set="method" line="116"><f a=""><e path="hxd.DisplayMode"/></f></get_displayMode>
		<set_displayMode set="method" line="119"><f a="m">
	<e path="hxd.DisplayMode"/>
	<e path="hxd.DisplayMode"/>
</f></set_displayMode>
		<get_title set="method" line="123"><f a=""><c path="String"/></f></get_title>
		<set_title set="method" line="126"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<new set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.EarNode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/earcut/Earcut.hx" module="hxd.earcut.Earcut">
		<next public="1"><c path="hxd.earcut.EarNode"/></next>
		<prev public="1"><c path="hxd.earcut.EarNode"/></prev>
		<nextZ public="1"><c path="hxd.earcut.EarNode"/></nextZ>
		<prevZ public="1"><c path="hxd.earcut.EarNode"/></prevZ>
		<allocNext public="1"><c path="hxd.earcut.EarNode"/></allocNext>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<i public="1"><x path="Int"/></i>
		<z public="1"><x path="Int"/></z>
		<steiner public="1"><x path="Bool"/></steiner>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.Earcut" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/earcut/Earcut.hx">
		<triangles><c path="Array"><x path="Int"/></c></triangles>
		<cache><c path="hxd.earcut.EarNode"/></cache>
		<allocated><c path="hxd.earcut.EarNode"/></allocated>
		<minX><x path="Float"/></minX>
		<minY><x path="Float"/></minY>
		<size><x path="Float"/></size>
		<hasSize><x path="Bool"/></hasSize>
		<triangulate public="1" params="T" set="method" line="34">
			<f a="points:?holes">
				<c path="Array"><c path="triangulate.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":generic"/></meta>
		</triangulate>
		<triangulateNode public="1" set="method" line="48"><f a="root:useZOrder">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
	<c path="Array"><x path="Int"/></c>
</f></triangulateNode>
		<setLinkedList params="T" set="method" line="90">
			<f a="points:start:end:clockwise">
				<c path="Array"><c path="setLinkedList.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</setLinkedList>
		<eliminateHoles params="T" set="method" line="124">
			<f a="points:holes:root">
				<c path="Array"><c path="eliminateHoles.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</eliminateHoles>
		<eliminateHole set="method" line="147"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></eliminateHole>
		<findHoleBridge set="method" line="156"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></findHoleBridge>
		<getLeftmost set="method" line="201"><f a="node">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></getLeftmost>
		<compareX get="inline" set="null" line="212"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Int"/>
</f></compareX>
		<equals get="inline" set="null" line="216"><f a="p1:p2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></equals>
		<area get="inline" set="null" line="220"><f a="p:q:r">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Float"/>
</f></area>
		<intersects get="inline" set="null" line="224"><f a="p1:q1:p2:q2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersects>
		<locallyInside get="inline" set="null" line="229"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></locallyInside>
		<filterPoints set="method" line="235">
			<f a="start:?end" v=":null">
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ end : null }</e></m></meta>
		</filterPoints>
		<removeNode get="inline" set="null" line="253"><f a="p">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></removeNode>
		<allocNode get="inline" set="null" line="260">
			<f a="i:x:y:?last" v=":::null">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ last : null }</e></m></meta>
		</allocNode>
		<earcutLinked set="method" line="282">
			<f a="ear:?pass" v=":0">
				<c path="hxd.earcut.EarNode"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pass : 0 }</e></m></meta>
		</earcutLinked>
		<isEar set="method" line="333"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEar>
		<isEarHashed set="method" line="352"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEarHashed>
		<cureLocalIntersections set="method" line="393"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></cureLocalIntersections>
		<splitEarcut set="method" line="419"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></splitEarcut>
		<splitPolygon set="method" line="446"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></splitPolygon>
		<pointInTriangle get="inline" set="null" line="467"><f a="ax:ay:bx:by:cx:cy:px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></pointInTriangle>
		<isValidDiagonal set="method" line="474"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isValidDiagonal>
		<middleInside set="method" line="480"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></middleInside>
		<intersectsPolygon set="method" line="495"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersectsPolygon>
		<zOrder get="inline" set="null" line="505"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></zOrder>
		<indexCurve set="method" line="523"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></indexCurve>
		<sortLinked set="method" line="538"><f a="list">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></sortLinked>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Ported from https://github.com/mapbox/earcut by @ncannasse</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.FontParser" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/bfnt/FontParser.hx">
		<parse public="1" set="method" line="12" static="1">
			<f a="bytes:path:resolveTile">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<c path="h2d.Tile"/>
				</f>
				<c path="h2d.Font"/>
			</f>
			<meta><m n=":access"><e>h2d.Font</e></m></meta>
		</parse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.Reader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/bfnt/Reader.hx">
		<parse public="1" get="inline" set="null" line="47" static="1"><f a="bytes:resolveTile">
	<c path="haxe.io.Bytes"/>
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></parse>
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="14"><f a="resolveTile">
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></read>
		<new public="1" set="method" line="10"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.bfnt.Writer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/bfnt/Writer.hx">
		<VERSION get="inline" set="null" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</VERSION>
		<out><c path="haxe.io.Output"/></out>
		<write public="1" set="method" line="26"><f a="font">
	<c path="h2d.Font"/>
	<x path="Void"/>
</f></write>
		<writeString get="inline" set="null" line="76"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<new public="1" set="method" line="22"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.fbx.TmpObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<index public="1"><x path="Int"/></index>
		<model public="1"><t path="hxd.fmt.fbx.FbxNode"/></model>
		<parent public="1"><c path="hxd.fmt.fbx.TmpObject"/></parent>
		<isJoint public="1"><x path="Bool"/></isJoint>
		<isMesh public="1"><x path="Bool"/></isMesh>
		<childs public="1"><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></childs>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<joint public="1"><c path="h3d.anim.Joint"/></joint>
		<skin public="1"><c path="hxd.fmt.fbx.TmpObject"/></skin>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx._BaseLibrary.AnimCurve" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/BaseLibrary.hx" private="1" module="hxd.fmt.fbx.BaseLibrary">
		<def public="1"><c path="hxd.fmt.fbx.DefaultMatrixes"/></def>
		<object public="1"><c path="String"/></object>
		<t public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></t>
		<r public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></r>
		<s public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></s>
		<a public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></a>
		<fov public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></fov>
		<roll public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></roll>
		<uv public="1"><c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c></uv>
		<new public="1" set="method" line="39"><f a="def:object">
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.DefaultMatrixes" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<rightHandToLeft public="1" get="inline" set="null" line="57" static="1"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></rightHandToLeft>
		<trans public="1"><x path="Null"><c path="h3d.col.Point"/></x></trans>
		<scale public="1"><x path="Null"><c path="h3d.col.Point"/></x></scale>
		<rotate public="1"><x path="Null"><c path="h3d.col.Point"/></x></rotate>
		<preRot public="1"><x path="Null"><c path="h3d.col.Point"/></x></preRot>
		<wasRemoved public="1"><x path="Null"><x path="Int"/></x></wasRemoved>
		<transPos public="1"><c path="h3d.Matrix"/></transPos>
		<toMatrix public="1" set="method" line="69"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Matrix"/>
</f></toMatrix>
		<toQuaternion public="1" set="method" line="80"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Quat"/>
</f></toQuaternion>
		<new public="1" set="method" line="54"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.BaseLibrary" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/BaseLibrary.hx">
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<ids><t path="Map">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</t></ids>
		<connect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></connect>
		<namedConnect><t path="Map">
	<x path="Int"/>
	<t path="Map">
		<c path="String"/>
		<x path="Int"/>
	</t>
</t></namedConnect>
		<invConnect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></invConnect>
		<leftHand><x path="Bool"/></leftHand>
		<defaultModelMatrixes><t path="Map">
	<c path="String"/>
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
</t></defaultModelMatrixes>
		<uvAnims><t path="Map">
	<c path="String"/>
	<c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c>
</t></uvAnims>
		<animationEvents><c path="Array"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></c></animationEvents>
		<isMaya><x path="Bool"/></isMaya>
		<fileName public="1"><c path="String"/></fileName>
		<version public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The FBX version that was decoded</haxe_doc>
		</version>
		<keepJoints public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to prevent some terminal unskinned joints to be removed, for instance if we want to track their position</haxe_doc>
		</keepJoints>
		<skipObjects public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to skip some objects from being processed as if they were not part of the FBX</haxe_doc>
		</skipObjects>
		<bonesPerVertex public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>Set how many bones per vertex should be created in skin data in makeObject(). Default is 3</haxe_doc>
		</bonesPerVertex>
		<maxBonesPerSkin public="1" expr="34">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
			<haxe_doc>If there are too many bones, the model will be split in separate render passes.</haxe_doc>
		</maxBonesPerSkin>
		<unskinnedJointsAsObjects public="1">
			<x path="Bool"/>
			<haxe_doc>Consider unskinned joints to be simple objects</haxe_doc>
		</unskinnedJointsAsObjects>
		<allowVertexColor public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowVertexColor>
		<normalizeScaleOrient public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Convert centimeters to meters and axis to Z-up (Maya FBX export)</haxe_doc>
		</normalizeScaleOrient>
		<reset set="method" line="153"><f a=""><x path="Void"/></f></reset>
		<loadFile public="1" set="method" line="161"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></loadFile>
		<load public="1" set="method" line="165"><f a="root">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></load>
		<updateModelScale set="method" line="212"><f a=""><x path="Void"/></f></updateModelScale>
		<convertPoints set="method" line="319"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></convertPoints>
		<leftHandConvert public="1" set="method" line="327"><f a=""><x path="Void"/></f></leftHandConvert>
		<init set="method" line="342"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></init>
		<getGeometry public="1" set="method" line="392">
			<f a="?name" v="&quot;&quot;">
				<c path="String"/>
				<c path="hxd.fmt.fbx.Geometry"/>
			</f>
			<meta><m n=":value"><e>{ name : "" }</e></m></meta>
		</getGeometry>
		<getParent public="1" set="method" line="404"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getParent>
		<getChild public="1" set="method" line="413"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getChild>
		<getSpecChild public="1" set="method" line="422"><f a="node:name">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getSpecChild>
		<getChilds public="1" set="method" line="432"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getChilds>
		<getParents public="1" set="method" line="445"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getParents>
		<getRoot public="1" set="method" line="458"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<ignoreMissingObject public="1" set="method" line="462"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></ignoreMissingObject>
		<buildHierarchy set="method" line="471"><f a=""><a>
	<root><c path="hxd.fmt.fbx.TmpObject"/></root>
	<objects><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></objects>
</a></f></buildHierarchy>
		<getObjectCurve set="method" line="581"><f a="curves:model:curveName:animName">
	<t path="Map">
		<x path="Int"/>
		<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
	</t>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="String"/>
	<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
</f></getObjectCurve>
		<mergeModels public="1" set="method" line="613"><f a="modelNames">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></mergeModels>
		<addLink set="method" line="691"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></addLink>
		<removeLink set="method" line="698"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></removeLink>
		<checkData set="method" line="705"><f a="t">
	<a>
		<z><c path="Array"><x path="Float"/></c></z>
		<y><c path="Array"><x path="Float"/></c></y>
		<x><c path="Array"><x path="Float"/></c></x>
	</a>
	<x path="Bool"/>
</f></checkData>
		<roundValues set="method" line="729">
			<f a="data:def:?mult" v="::1.">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ mult : 1. }</e></m></meta>
		</roundValues>
		<getAnimationNames public="1" set="method" line="745">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns an array of names with all animations present in FBX file.</haxe_doc>
		</getAnimationNames>
		<loadAnimation public="1" set="method" line="754"><f a="?animName:?root:?lib">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<sortDistinctFloats set="method" line="1172"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></sortDistinctFloats>
		<isNullJoint set="method" line="1176"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Bool"/>
</f></isNullJoint>
		<getModelPath set="method" line="1188"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getModelPath>
		<autoMerge set="method" line="1196"><f a=""><x path="Void"/></f></autoMerge>
		<keepJoint set="method" line="1246"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<createSkin set="method" line="1250"><f a="hskins:hgeom:rootJoints:bonesPerVertex">
	<t path="Map">
		<x path="Int"/>
		<c path="h3d.anim.Skin"/>
	</t>
	<t path="Map">
		<x path="Int"/>
		<a>
			<vertexCount set="method"><f a=""><x path="Int"/></f></vertexCount>
			<setSkin set="method"><f a="s">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></setSkin>
		</a>
	</t>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Int"/>
	<x path="Null"><c path="h3d.anim.Skin"/></x>
</f></createSkin>
		<round set="method" line="1319"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></round>
		<updateDefaultMatrix set="method" line="1324"><f a="model:d">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
	<x path="Void"/>
</f></updateDefaultMatrix>
		<getDefaultMatrixes set="method" line="1401"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="hxd.fmt.fbx.DefaultMatrixes"/></x>
</f></getDefaultMatrixes>
		<new public="1" set="method" line="145"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="hxd.fmt.fbx.FbxProp" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<PInt a="v"><x path="Int"/></PInt>
		<PFloat a="v"><x path="Float"/></PFloat>
		<PString a="v"><c path="String"/></PString>
		<PIdent a="i"><c path="String"/></PIdent>
		<PInts a="v"><c path="Array"><x path="Int"/></c></PInts>
		<PFloats a="v"><c path="Array"><x path="Float"/></c></PFloats>
		<PBinary a="v"><c path="haxe.io.Bytes"/></PBinary>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.fbx.FbxNode" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data"><a>
	<props><c path="Array"><e path="hxd.fmt.fbx.FbxProp"/></c></props>
	<name><c path="String"/></name>
	<childs><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></childs>
</a></typedef>
	<class path="hxd.fmt.fbx.FbxTools" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<get public="1" set="method" line="21" static="1">
			<f a="n:path:?opt" v="::false">
				<t path="hxd.fmt.fbx.FbxNode"/>
				<c path="String"/>
				<x path="Bool"/>
				<t path="hxd.fmt.fbx.FbxNode"/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</get>
		<getAll public="1" set="method" line="41" static="1"><f a="n:path">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
</f></getAll>
		<getInts public="1" set="method" line="57" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Int"/></c>
</f></getInts>
		<getFloats public="1" set="method" line="68" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Float"/></c>
</f></getFloats>
		<hasProp public="1" set="method" line="87" static="1"><f a="n:p">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Bool"/>
</f></hasProp>
		<idToInt set="method" line="94" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></idToInt>
		<toInt public="1" set="method" line="104" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Int"/>
</f></toInt>
		<toFloat public="1" set="method" line="113" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Float"/>
</f></toFloat>
		<toString public="1" set="method" line="122" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="String"/>
</f></toString>
		<toBinary public="1" set="method" line="130" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="haxe.io.Bytes"/>
</f></toBinary>
		<getId public="1" set="method" line="138" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Int"/>
</f></getId>
		<getName public="1" set="method" line="148" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getName>
		<getType public="1" set="method" line="157" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></getType>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.Geometry" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Geometry.hx">
		<lib><c path="hxd.fmt.fbx.BaseLibrary"/></lib>
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<getRoot public="1" set="method" line="14"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<getVertices public="1" set="method" line="18"><f a=""><c path="Array"><x path="Float"/></c></f></getVertices>
		<getPolygons public="1" set="method" line="22"><f a=""><c path="Array"><x path="Int"/></c></f></getPolygons>
		<getMaterials public="1" set="method" line="26"><f a=""><x path="Null"><c path="Array"><x path="Int"/></c></x></f></getMaterials>
		<getMaterialByTriangle public="1" set="method" line="31"><f a=""><c path="Array"><x path="Int"/></c></f></getMaterialByTriangle>
		<merge public="1" set="method" line="48"><f a="g:materials">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></merge>
		<getIndexes public="1" set="method" line="148">
			<f a=""><a>
	<vidx><c path="Array"><x path="Int"/></c></vidx>
	<idx><c path="Array"><x path="Int"/></c></idx>
</a></f>
			<haxe_doc>Decode polygon informations into triangle indexes and vertices indexes.
		Returns vidx, which is the list of vertices indexes and iout which is the index buffer for the full vertex model</haxe_doc>
		</getIndexes>
		<getNormals public="1" set="method" line="172"><f a=""><c path="Array"><x path="Float"/></c></f></getNormals>
		<getTangents public="1" set="method" line="176">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getTangents>
		<getBinormals public="1" set="method" line="180">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getBinormals>
		<processVectors set="method" line="184">
			<f a="layer:name:?opt" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</processVectors>
		<getColors public="1" set="method" line="204"><f a=""><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></f></getColors>
		<getUVs public="1" set="method" line="212"><f a=""><c path="Array"><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></c></f></getUVs>
		<getGeomMatrix public="1" set="method" line="227">
			<f a=""><c path="h3d.Matrix"/></f>
			<meta><m n=":access"><e>hxd.fmt.fbx.BaseLibrary.leftHand</e></m></meta>
		</getGeomMatrix>
		<new public="1" set="method" line="9"><f a="l:root">
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.HMDOut" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/HMDOut.hx">
		<extends path="hxd.fmt.fbx.BaseLibrary"/>
		<d><c path="hxd.fmt.hmd.Data"/></d>
		<dataOut><c path="haxe.io.BytesOutput"/></dataOut>
		<filePath><c path="String"/></filePath>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<absoluteTexturePath public="1"><x path="Bool"/></absoluteTexturePath>
		<optimizeSkin public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</optimizeSkin>
		<floatSkinIndexes public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</floatSkinIndexes>
		<int32tof set="method" line="20"><f a="v">
	<x path="Int"/>
	<x path="Float"/>
</f></int32tof>
		<keepJoint set="method" line="28" override="1"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<buildTangents set="method" line="37"><f a="geom">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Float"/></c>
</f></buildTangents>
		<buildGeom set="method" line="131"><f a="geom:skin:dataOut:genTangents">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="h3d.anim.Skin"/>
	<c path="haxe.io.BytesOutput"/>
	<x path="Bool"/>
	<a>
		<materials><c path="Array"><x path="Int"/></c></materials>
		<g><c path="hxd.fmt.hmd.Geometry"/></g>
	</a>
</f></buildGeom>
		<addModels set="method" line="362"><f a="includeGeometry">
	<x path="Bool"/>
	<x path="Void"/>
</f></addModels>
		<makeTexturePath set="method" line="632"><f a="tex">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></makeTexturePath>
		<makeSkin set="method" line="654"><f a="skin:obj">
	<c path="h3d.anim.Skin"/>
	<c path="hxd.fmt.fbx.TmpObject"/>
	<c path="hxd.fmt.hmd.Skin"/>
</f></makeSkin>
		<makePosition set="method" line="693"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="hxd.fmt.hmd.Position"/>
</f></makePosition>
		<writeFloat get="inline" set="null" line="712"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeFrame set="method" line="716"><f a="o:fid">
	<c path="h3d.anim.LinearObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFrame>
		<makeAnimation set="method" line="748"><f a="anim">
	<c path="h3d.anim.Animation"/>
	<c path="hxd.fmt.hmd.Animation"/>
</f></makeAnimation>
		<toHMD public="1" set="method" line="838"><f a="filePath:includeGeometry">
	<c path="String"/>
	<x path="Bool"/>
	<c path="hxd.fmt.hmd.Data"/>
</f></toHMD>
		<new public="1" set="method" line="6"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.fbx._Parser.Token" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Parser.hx" private="1" module="hxd.fmt.fbx.Parser">
		<TIdent a="s"><c path="String"/></TIdent>
		<TNode a="s"><c path="String"/></TNode>
		<TInt a="s"><c path="String"/></TInt>
		<TFloat a="s"><c path="String"/></TFloat>
		<TString a="s"><c path="String"/></TString>
		<TLength a="v"><x path="Int"/></TLength>
		<TBraceOpen/>
		<TBraceClose/>
		<TColon/>
		<TEof/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.fmt.fbx.Parser" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/fbx/Parser.hx">
		<parse public="1" set="method" line="501" static="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parse>
		<line><x path="Int"/></line>
		<buf><c path="String"/></buf>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<token><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></token>
		<binary><x path="Bool"/></binary>
		<fbxVersion><x path="Int"/></fbxVersion>
		<parseText set="method" line="31"><f a="str">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseText>
		<parseBytes set="method" line="44"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBytes>
		<parseNodes set="method" line="87"><f a=""><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></f></parseNodes>
		<parseNode set="method" line="100"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></parseNode>
		<parseBinaryNodes set="method" line="176"><f a="output">
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
	<x path="Void"/>
</f></parseBinaryNodes>
		<parseBinaryNode set="method" line="185"><f a="nextRecord">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBinaryNode>
		<readBinaryProperty set="method" line="212"><f a=""><e path="hxd.fmt.fbx.FbxProp"/></f></readBinaryProperty>
		<except set="method" line="319"><f a="except">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<x path="Void"/>
</f></except>
		<peek set="method" line="325"><f a=""><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></f></peek>
		<next set="method" line="331"><f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f></next>
		<error set="method" line="339"><f a="msg">
	<c path="String"/>
	<d/>
</f></error>
		<unexpected set="method" line="344"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<d/>
</f></unexpected>
		<tokenStr set="method" line="348"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<c path="String"/>
</f></tokenStr>
		<nextChar get="inline" set="null" line="363"><f a=""><x path="Int"/></f></nextChar>
		<getVersionedInt32 get="inline" set="null" line="367"><f a=""><x path="Int"/></f></getVersionedInt32>
		<getInt32 get="inline" set="null" line="374"><f a=""><x path="Int"/></f></getInt32>
		<getInt16 get="inline" set="null" line="380"><f a=""><x path="Int"/></f></getInt16>
		<getFloat get="inline" set="null" line="386"><f a=""><x path="Float"/></f></getFloat>
		<getDouble get="inline" set="null" line="392"><f a=""><x path="Float"/></f></getDouble>
		<i64ToFloat get="inline" set="null" line="398"><f a="i64">
	<x path="haxe.Int64"/>
	<x path="Float"/>
</f></i64ToFloat>
		<getByte get="inline" set="null" line="403"><f a=""><x path="Int"/></f></getByte>
		<getBuf get="inline" set="null" line="407"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getBuf>
		<isIdentChar get="inline" set="null" line="411"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isIdentChar>
		<nextToken set="method" line="416">
			<f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f>
			<meta><m n=":noDebug"/></meta>
		</nextToken>
		<new set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.fmt.hmd.GeometryDataFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data" final="1">
	<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DFloat>
	<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec2>
	<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec3>
	<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec4>
	<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DBytes4>
	<_new get="inline" set="null" line="11" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getSize public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getSize>
	<toInt public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<toString public="1" set="method" line="23" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data" final="1">
		<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DFloat>
		<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec2>
		<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec3>
		<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec4>
		<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DBytes4>
		<_new get="inline" set="null" line="11" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getSize public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getSize>
		<toInt public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<toString public="1" set="method" line="23" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="hxd.fmt.hmd.DataPosition" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<typedef path="hxd.fmt.hmd.Index" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<enum path="hxd.fmt.hmd.Property" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<CameraFOVY a="v"><x path="Float"/></CameraFOVY>
		<Unused_HasMaterialFlags/>
		<HasExtraTextures/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.hmd.Properties" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Null"><c path="Array"><e path="hxd.fmt.hmd.Property"><d/></e></c></x></typedef>
	<class path="hxd.fmt.hmd.Position" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<QTMP expr="new h3d.Quat()" line="91" static="1">
			<c path="h3d.Quat"/>
			<meta><m n=":value"><e>new h3d.Quat()</e></m></meta>
		</QTMP>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1" get="accessor" set="null"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<loadQuaternion public="1" get="inline" set="null" line="63"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></loadQuaternion>
		<get_qw set="method" line="70"><f a=""><x path="Float"/></f></get_qw>
		<toMatrix public="1" set="method" line="75">
			<f a="?postScale" v="false">
				<x path="Bool"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ postScale : false }</e></m></meta>
		</toMatrix>
		<new public="1" set="method" line="60"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<format public="1"><x path="hxd.fmt.hmd.GeometryDataFormat"/></format>
		<new public="1" set="method" line="97"><f a="name:format">
	<c path="String"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Geometry" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<vertexCount public="1"><x path="Int"/></vertexCount>
		<vertexStride public="1"><x path="Int"/></vertexStride>
		<vertexFormat public="1"><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></vertexFormat>
		<vertexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></vertexPosition>
		<indexCount public="1" get="accessor" set="null"><x path="Int"/></indexCount>
		<indexCounts public="1"><c path="Array"><x path="Int"/></c></indexCounts>
		<indexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></indexPosition>
		<bounds public="1"><c path="h3d.col.Bounds"/></bounds>
		<get_indexCount set="method" line="115"><f a=""><x path="Int"/></f></get_indexCount>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Material" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<diffuseTexture public="1"><x path="Null"><c path="String"/></x></diffuseTexture>
		<specularTexture public="1"><x path="Null"><c path="String"/></x></specularTexture>
		<normalMap public="1"><x path="Null"><c path="String"/></x></normalMap>
		<blendMode public="1"><t path="h3d.mat.BlendMode"/></blendMode>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinJoint" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></parent>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<bind public="1"><x path="Int"/></bind>
		<transpos public="1"><x path="Null"><c path="hxd.fmt.hmd.Position"/></x></transpos>
		<new public="1" set="method" line="142"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinSplit" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<materialIndex public="1"><x path="Int"/></materialIndex>
		<joints public="1"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></c></joints>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Skin" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<joints public="1"><c path="Array"><c path="hxd.fmt.hmd.SkinJoint"/></c></joints>
		<split public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.SkinSplit"/></c></x></split>
		<new public="1" set="method" line="158"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Model" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Model"/></t></parent>
		<follow public="1"><x path="Null"><c path="String"/></x></follow>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<geometry public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Geometry"/></t></geometry>
		<materials public="1"><x path="Null"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Material"/></t></c></x></materials>
		<skin public="1"><x path="Null"><c path="hxd.fmt.hmd.Skin"/></x></skin>
		<new public="1" set="method" line="171"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.hmd.AnimationFlag" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<HasPosition/>
		<HasRotation/>
		<HasScale/>
		<HasUV/>
		<HasAlpha/>
		<SingleFrame/>
		<HasProps/>
		<Reserved/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.fmt.hmd.AnimationObject" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.fmt.hmd.AnimationFlag"/></x></flags>
		<props public="1"><c path="Array"><c path="String"/></c></props>
		<getStride public="1" set="method" line="192"><f a=""><x path="Int"/></f></getStride>
		<new public="1" set="method" line="190"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.AnimationEvent" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<frame public="1"><x path="Int"/></frame>
		<data public="1"><c path="String"/></data>
		<new public="1" set="method" line="207"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Animation" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<frames public="1"><x path="Int"/></frames>
		<sampling public="1"><x path="Float"/></sampling>
		<speed public="1"><x path="Float"/></speed>
		<loop public="1"><x path="Bool"/></loop>
		<objects public="1"><c path="Array"><c path="hxd.fmt.hmd.AnimationObject"/></c></objects>
		<events public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.AnimationEvent"/></c></x></events>
		<dataPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></dataPosition>
		<new public="1" set="method" line="221"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Data" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Data.hx">
		<CURRENT_VERSION public="1" get="inline" set="null" expr="3" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CURRENT_VERSION>
		<version public="1"><x path="Int"/></version>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<geometries public="1"><c path="Array"><c path="hxd.fmt.hmd.Geometry"/></c></geometries>
		<materials public="1"><c path="Array"><c path="hxd.fmt.hmd.Material"/></c></materials>
		<models public="1"><c path="Array"><c path="hxd.fmt.hmd.Model"/></c></models>
		<animations public="1"><c path="Array"><c path="hxd.fmt.hmd.Animation"/></c></animations>
		<dataPosition public="1"><x path="Int"/></dataPosition>
		<data public="1"><c path="haxe.io.Bytes"/></data>
		<new public="1" set="method" line="238"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd._Library.FormatMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Library.hx" private="1" module="hxd.fmt.hmd.Library">
		<size public="1"><x path="Int"/></size>
		<offset public="1"><x path="Int"/></offset>
		<def public="1"><c path="h3d.Vector"/></def>
		<next public="1"><c path="hxd.fmt.hmd._Library.FormatMap"/></next>
		<new public="1" set="method" line="9"><f a="size:offset:def:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Vector"/>
	<c path="hxd.fmt.hmd._Library.FormatMap"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryBuffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Library.hx" module="hxd.fmt.hmd.Library">
		<vertexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></vertexes>
		<indexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Library" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Library.hx">
		<resource public="1" set="null"><c path="hxd.res.Resource"/></resource>
		<header public="1" set="null"><c path="hxd.fmt.hmd.Data"/></header>
		<cachedPrimitives><c path="Array"><c path="h3d.prim.HMDModel"/></c></cachedPrimitives>
		<cachedAnimations><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</t></cachedAnimations>
		<cachedSkin><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Skin"/>
</t></cachedSkin>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<getData public="1" set="method" line="41"><f a=""><c path="haxe.io.Bytes"/></f></getData>
		<getDefaultFormat public="1" set="method" line="51"><f a="stride">
	<x path="Int"/>
	<a>
		<format><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></format>
		<defs><c path="Array"><c path="h3d.Vector"/></c></defs>
	</a>
</f></getDefaultFormat>
		<load public="1" set="method" line="73">
			<f a="format:?defaults:?modelIndex" v="::-1">
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<a>
					<vertex><x path="hxd.FloatBuffer"/></vertex>
					<index><x path="hxd.IndexBuffer"/></index>
				</a>
			</f>
			<meta><m n=":value"><e>{ modelIndex : -1 }</e></m></meta>
		</load>
		<getBuffers public="1" set="method" line="111">
			<f a="geom:format:?defaults:?material">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<c path="hxd.fmt.hmd.GeometryBuffer"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</getBuffers>
		<makePrimitive set="method" line="253"><f a="id">
	<x path="Int"/>
	<c path="h3d.prim.HMDModel"/>
</f></makePrimitive>
		<makeMaterial set="method" line="262"><f a="model:mid:loadTexture">
	<c path="hxd.fmt.hmd.Model"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.mat.Material"/>
</f></makeMaterial>
		<makeSkin set="method" line="283">
			<f a="skin">
				<c path="hxd.fmt.hmd.Skin"/>
				<x path="Null"><c path="h3d.anim.Skin"/></x>
			</f>
			<meta><m n=":access"><e>h3d.anim.Skin</e></m></meta>
		</makeSkin>
		<getModelProperty public="1" params="T" set="method" line="320"><f a="objName:p:?def">
	<c path="String"/>
	<e path="hxd.fmt.hmd.Property"><c path="getModelProperty.T"/></e>
	<c path="getModelProperty.T"/>
	<x path="Null"><c path="getModelProperty.T"/></x>
</f></getModelProperty>
		<makeObject public="1" set="method" line="335"><f a="?loadTexture">
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.scene.Object"/>
</f></makeObject>
		<loadAnimation public="1" set="method" line="366"><f a="?name">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<makeAnimation set="method" line="397"><f a="a">
	<c path="hxd.fmt.hmd.Animation"/>
	<c path="h3d.anim.BufferAnimation"/>
</f></makeAnimation>
		<makeLinearAnimation set="method" line="480"><f a="a">
	<c path="hxd.fmt.hmd.Animation"/>
	<c path="h3d.anim.LinearAnimation"/>
</f></makeLinearAnimation>
		<loadSkin public="1" set="method" line="570">
			<f a="geom:skin">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="h3d.anim.Skin"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.anim.Skin</e></m></meta>
		</loadSkin>
		<ftoint32 set="method" line="589"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Int"/>
</f></ftoint32>
		<new public="1" set="method" line="33"><f a="res:header">
	<c path="hxd.res.Resource"/>
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Reader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Reader.hx">
		<BLEND expr="Type.allEnums(h2d.BlendMode)" line="6" static="1">
			<c path="Array"><e path="h2d.BlendMode"/></c>
			<meta><m n=":value"><e>Type.allEnums(h2d.BlendMode)</e></m></meta>
		</BLEND>
		<CULLING expr="Type.allEnums(h3d.mat.Data.Face)" line="7" static="1">
			<c path="Array"><e path="h3d.mat.Face"/></c>
			<meta><m n=":value"><e>Type.allEnums(h3d.mat.Data.Face)</e></m></meta>
		</CULLING>
		<HMD_STRINGS static="1"><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></HMD_STRINGS>
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readProperty set="method" line="16"><f a=""><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></f></readProperty>
		<readProps set="method" line="29"><f a=""><c path="Array"><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></c></f></readProps>
		<readName set="method" line="38"><f a=""><c path="String"/></f></readName>
		<readCachedName set="method" line="49"><f a=""><x path="Null"><c path="String"/></x></f></readCachedName>
		<readPosition set="method" line="60">
			<f a="?hasScale" v="true">
				<x path="Bool"/>
				<c path="hxd.fmt.hmd.Position"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</readPosition>
		<readBounds set="method" line="80"><f a=""><c path="h3d.col.Bounds"/></f></readBounds>
		<readSkin set="method" line="91"><f a=""><c path="hxd.fmt.hmd.Skin"/></f></readSkin>
		<readHeader public="1" set="method" line="126"><f a=""><c path="hxd.fmt.hmd.Data"/></f></readHeader>
		<read public="1" set="method" line="222"><f a=""><c path="hxd.fmt.hmd.Data"/></f></read>
		<new public="1" set="method" line="12"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Writer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fmt/hmd/Writer.hx">
		<out><c path="haxe.io.Output"/></out>
		<version><x path="Int"/></version>
		<writeProperty set="method" line="13"><f a="p">
	<e path="hxd.fmt.hmd.Property"><d/></e>
	<x path="Void"/>
</f></writeProperty>
		<writeProps set="method" line="23"><f a="props">
	<t path="hxd.fmt.hmd.Properties"/>
	<x path="Void"/>
</f></writeProps>
		<writeName set="method" line="37"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></writeName>
		<writeFloat get="inline" set="null" line="50"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writePosition set="method" line="54">
			<f a="p:?hasScale" v=":true">
				<c path="hxd.fmt.hmd.Position"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</writePosition>
		<writeBounds set="method" line="68"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></writeBounds>
		<writeSkin set="method" line="77"><f a="s">
	<c path="hxd.fmt.hmd.Skin"/>
	<x path="Void"/>
</f></writeSkin>
		<write public="1" set="method" line="102"><f a="d">
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></write>
		<new public="1" set="method" line="9"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileEntry" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileEntry.hx">
		<name public="1" set="null"><c path="String"/></name>
		<path public="1" get="accessor" set="null"><c path="String"/></path>
		<directory public="1" get="accessor" set="null"><c path="String"/></directory>
		<extension public="1" get="accessor" set="null"><c path="String"/></extension>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<isDirectory public="1" get="accessor" set="null"><x path="Bool"/></isDirectory>
		<isAvailable public="1" get="accessor" set="null"><x path="Bool"/></isAvailable>
		<getSign public="1" set="method" line="14"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="16"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<getText public="1" set="method" line="18"><f a=""><c path="String"/></f></getText>
		<open public="1" set="method" line="20"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="21"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="22"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="23"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="24"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="26"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="27"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<watch public="1" set="method" line="28"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<exists public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="32"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_isAvailable set="method" line="34"><f a=""><x path="Bool"/></f></get_isAvailable>
		<get_isDirectory set="method" line="35"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_size set="method" line="36"><f a=""><x path="Int"/></f></get_size>
		<get_path set="method" line="37"><f a=""><c path="String"/></f></get_path>
		<get_directory set="method" line="39"><f a=""><c path="String"/></f></get_directory>
		<get_extension set="method" line="45"><f a=""><c path="String"/></f></get_extension>
	</class>
	<class path="hxd.fs.BytesFileEntry" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/BytesFileSystem.hx" module="hxd.fs.BytesFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<fullPath><c path="String"/></fullPath>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<get_path set="method" line="17" override="1"><f a=""><c path="String"/></f></get_path>
		<getSign public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="25" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="33" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="36" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="40" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="48" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="52" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<exists public="1" set="method" line="79" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="80" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="82" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_size set="method" line="84" override="1"><f a=""><x path="Int"/></f></get_size>
		<new public="1" set="method" line="11"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileSystem.hx" interface="1">
		<getRoot public="1" set="method"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<get public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<exists public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
	</class>
	<class path="hxd.fs.BytesFileSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/BytesFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<getRoot public="1" set="method" line="93"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<getBytes set="method" line="98"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<exists public="1" set="method" line="103"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="107"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.BytesFileEntry"/>
</f></get>
		<dispose public="1" set="method" line="113"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="116"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new set="method" line="90"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.Convert" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx">
		<converts expr="new Map&lt;String,Array&lt;Convert&gt;&gt;()" line="58" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="Array"><c path="hxd.fs.Convert"/></c>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Array<Convert>>()]]></e></m></meta>
		</converts>
		<register public="1" set="method" line="59" static="1"><f a="c">
	<c path="hxd.fs.Convert"/>
	<x path="Int"/>
</f></register>
		<sourceExts public="1" set="null"><c path="Array"><c path="String"/></c></sourceExts>
		<destExt public="1" set="null"><c path="String"/></destExt>
		<version public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Major version of the Convert.
		When incremented, all files processed by this Convert would be rebuilt.</haxe_doc>
		</version>
		<params public="1"><d/></params>
		<srcPath public="1"><c path="String"/></srcPath>
		<dstPath public="1"><c path="String"/></dstPath>
		<originalFilename public="1"><c path="String"/></originalFilename>
		<srcBytes public="1"><c path="haxe.io.Bytes"/></srcBytes>
		<convert public="1" set="method" line="27"><f a=""><x path="Void"/></f></convert>
		<hasParam set="method" line="31"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasParam>
		<getParam set="method" line="36"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getParam>
		<save set="method" line="42"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></save>
		<command set="method" line="46"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></command>
		<new public="1" set="method" line="21"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="hxd.fs.ConvertFBX2HMD" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertFBX2HMD())" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertFBX2HMD())</e></m></meta>
		</_>
		<convert public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="74"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.Command" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<cmd><c path="String"/></cmd>
		<args><c path="Array"><c path="String"/></c></args>
		<convert public="1" set="method" line="104" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="98"><f a="fr:to:cmd:args">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2MP3" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertWAV2MP3())" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertWAV2MP3())</e></m></meta>
		</_>
		<convert public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2OGG" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertWAV2OGG())" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertWAV2OGG())</e></m></meta>
		</_>
		<convert public="1" set="method" line="131" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="127"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertTGA2PNG" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertTGA2PNG())" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertTGA2PNG())</e></m></meta>
		</_>
		<convert public="1" set="method" line="157" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="153"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertFNT2BFNT" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertFNT2BFNT())" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertFNT2BFNT())</e></m></meta>
		</_>
		<emptyTile><c path="h2d.Tile"/></emptyTile>
		<convert public="1" set="method" line="201" override="1"><f a=""><x path="Void"/></f></convert>
		<resolveTile set="method" line="209"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveTile>
		<new public="1" set="method" line="194"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.CompressIMG" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new CompressIMG(&quot;png,tga,jpg,jpeg&quot;, &quot;dds&quot;))" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new CompressIMG("png,tga,jpg,jpeg", "dds"))</e></m></meta>
		</_>
		<convert public="1" set="method" line="223" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="221"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.DummyConvert" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="[Convert.register(new DummyConvert(null, &quot;dummy&quot;)), Convert.register(new DummyConvert(null, &quot;remove&quot;))]" line="237" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[Convert.register(new DummyConvert(null, "dummy")), Convert.register(new DummyConvert(null, "remove"))]</e></m></meta>
		</_>
		<convert public="1" set="method" line="233" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="231"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="hxd.fs.ConvertConfig" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<rules><c path="Array"><t path="hxd.fs.ConvertRule"/></c></rules>
	<obj><d/></obj>
</a></typedef>
	<typedef path="hxd.fs.ConvertRule" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<pt><e path="hxd.fs.ConvertPattern"/></pt>
	<priority><x path="Int"/></priority>
	<cmd><t path="hxd.fs.ConvertCommand"/></cmd>
</a></typedef>
	<enum path="hxd.fs.ConvertPattern" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter">
		<Filename a="name"><c path="String"/></Filename>
		<Regexp a="r"><c path="EReg"/></Regexp>
		<Ext a="e"><c path="String"/></Ext>
		<Exts a="e"><c path="Array"><c path="String"/></c></Exts>
		<Wildcard/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fs.ConvertCommand" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<then>
		<x path="Null"><t path="hxd.fs.ConvertCommand"/></x>
		<meta><m n=":optional"/></meta>
	</then>
	<paramsStr>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</paramsStr>
	<params>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</params>
	<conv><c path="Array"><c path="hxd.fs.Convert"/></c></conv>
</a></typedef>
	<class path="hxd.fs.FileConverter" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileConverter.hx">
		<extraConfigs expr="[]" line="37" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extraConfigs>
		<addConfig public="1" set="method" line="57" static="1">
			<f a="conf">
				<d/>
				<unknown/>
			</f>
			<haxe_doc>Add extra convert configuration. Should be props.json-compatible structure.  
		Can be used to add or override converts that are enabled by default.  
		Sample code of Convert registration and enabling it by default:
		```haxe
		// Register Convert
		static var _ = hxd.fs.Convert.register(new MyFancyConvert());
		// Enable it
		static var __ = hxd.fs.FileConverter.addConfig({
			"fs.convert": {
				// Converts are identified by output extension of Convert.
				"origext": { convert: "fancyext", priority: 0 },
				// Shorter declaration with default priority 0:
				"otherext": "fancyext"
			}
		});
		```</haxe_doc>
		</addConfig>
		<sortByRulePiority set="method" line="107" static="1"><f a="r1:r2">
	<t path="hxd.fs.ConvertRule"/>
	<t path="hxd.fs.ConvertRule"/>
	<x path="Int"/>
</f></sortByRulePiority>
		<configuration public="1" set="null"><c path="String"/></configuration>
		<baseDir><c path="String"/></baseDir>
		<tmpDir><c path="String"/></tmpDir>
		<configs expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="hxd.fs.ConvertConfig"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</configs>
		<defaultConfig><t path="hxd.fs.ConvertConfig"/></defaultConfig>
		<cache><t path="Map">
	<c path="String"/>
	<c path="Array"><a>
	<ver><x path="Null"><x path="Int"/></x></ver>
	<time><x path="Int"/></time>
	<out><c path="String"/></out>
	<hash><c path="String"/></hash>
</a></c>
</t></cache>
		<onConvert public="1" set="dynamic" line="79"><f a="c">
	<c path="hxd.fs.Convert"/>
	<x path="Void"/>
</f></onConvert>
		<makeConfig set="method" line="82"><f a="obj">
	<d/>
	<t path="hxd.fs.ConvertConfig"/>
</f></makeConfig>
		<loadConvert set="method" line="113"><f a="name">
	<c path="String"/>
	<x path="Null"><c path="Array"><c path="hxd.fs.Convert"/></c></x>
</f></loadConvert>
		<makeCommmand set="method" line="120"><f a="obj">
	<d/>
	<a>
		<priority><x path="Int"/></priority>
		<cmd><t path="hxd.fs.ConvertCommand"/></cmd>
	</a>
</f></makeCommmand>
		<mergeRec set="method" line="147"><f a="a:b">
	<d/>
	<d/>
	<a/>
</f></mergeRec>
		<getFileTime set="method" line="167"><f a="filePath">
	<c path="String"/>
	<x path="Float"/>
</f></getFileTime>
		<loadConfig set="method" line="171"><f a="dir">
	<c path="String"/>
	<t path="hxd.fs.ConvertConfig"/>
</f></loadConfig>
		<getConvertRule set="method" line="189"><f a="path">
	<c path="String"/>
	<t path="hxd.fs.ConvertRule"/>
</f></getConvertRule>
		<run public="1" set="method" line="205"><f a="e">
	<c path="hxd.fs.LocalEntry"/>
	<x path="Void"/>
</f></run>
		<runConvert set="method" line="217">
			<f a="e:cmd:?replaceExt" v="::false">
				<c path="hxd.fs.LocalEntry"/>
				<t path="hxd.fs.ConvertCommand"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ replaceExt : false }</e></m></meta>
		</runConvert>
		<convertAndCache set="method" line="253"><f a="e:outFile:conv:params">
	<c path="hxd.fs.LocalEntry"/>
	<c path="String"/>
	<c path="hxd.fs.Convert"/>
	<d/>
	<x path="Void"/>
</f></convertAndCache>
		<new public="1" set="method" line="62"><f a="baseDir:configuration">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileInput" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<f><c path="hxd.fs.FileEntry"/></f>
		<skip public="1" set="method" line="12"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="16" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="20" override="1"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="7"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.fs.LoadedBitmapData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LoadedBitmap.hx" module="hxd.fs.LoadedBitmap"><c path="hxd.BitmapData"/></typedef>
	<abstract path="hxd.fs.LoadedBitmap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LoadedBitmap.hx">
		<this><t path="hxd.fs.LoadedBitmapData"/></this>
		<impl><class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap" final="1">
	<_new public="1" get="inline" set="null" line="13" static="1">
		<f a="data">
			<t path="hxd.fs.LoadedBitmapData"/>
			<x path="hxd.fs.LoadedBitmap"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toBitmap public="1" set="method" line="17" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<c path="hxd.BitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBitmap>
	<toNative public="1" get="inline" set="null" line="29" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<t path="hxd.fs.LoadedBitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toNative>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap" final="1">
		<_new public="1" get="inline" set="null" line="13" static="1">
			<f a="data">
				<t path="hxd.fs.LoadedBitmapData"/>
				<x path="hxd.fs.LoadedBitmap"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toBitmap public="1" set="method" line="17" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<c path="hxd.BitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBitmap>
		<toNative public="1" get="inline" set="null" line="29" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<t path="hxd.fs.LoadedBitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toNative>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.LocalEntry" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LocalFileSystem.hx" module="hxd.fs.LocalFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<WATCH_INDEX expr="0" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</WATCH_INDEX>
		<WATCH_LIST expr="null" line="125" static="1">
			<c path="Array"><c path="hxd.fs.LocalEntry"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</WATCH_LIST>
		<tmpDir expr="null" line="126" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tmpDir>
		<checkFiles set="method" line="136" static="1"><f a=""><x path="Void"/></f></checkFiles>
		<fs><c path="hxd.fs.LocalFileSystem"/></fs>
		<relPath><c path="String"/></relPath>
		<file><c path="String"/></file>
		<originalFile><c path="String"/></originalFile>
		<fread><c path="sys.io.FileInput"/></fread>
		<getSign public="1" set="method" line="23" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="31" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="42" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="46" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="50" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></close>
		<isDirCached><x path="Null"><x path="Bool"/></x></isDirCached>
		<get_isDirectory set="method" line="62" override="1"><f a=""><x path="Bool"/></f></get_isDirectory>
		<load public="1" set="method" line="67" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="75" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<get_path set="method" line="90" override="1"><f a=""><c path="String"/></f></get_path>
		<exists public="1" set="method" line="94" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="98" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.LocalEntry"/>
</f></get>
		<get_size set="method" line="102" override="1"><f a=""><x path="Int"/></f></get_size>
		<iterator public="1" set="method" line="106" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<watchCallback><f a=""><x path="Void"/></f></watchCallback>
		<watchTime><x path="Float"/></watchTime>
		<getModifTime get="inline" set="null" line="128"><f a=""><x path="Float"/></f></getModifTime>
		<watch public="1" set="method" line="170" override="1"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new set="method" line="16"><f a="fs:name:relPath:file">
	<c path="hxd.fs.LocalFileSystem"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.fs.LocalFileSystem</e></m>
			<m n=":allow"><e>hxd.fs.FileConverter</e></m>
			<m n=":access"><e>hxd.fs.LocalFileSystem</e></m>
		</meta>
	</class>
	<class path="hxd.fs.LocalFileSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/LocalFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<isWindows expr="Sys.systemName() == &quot;Windows&quot;" line="205" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>Sys.systemName() == "Windows"</e></m></meta>
		</isWindows>
		<root><c path="hxd.fs.FileEntry"/></root>
		<fileCache expr="new Map&lt;String,{ var r : LocalEntry}&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a><r><c path="hxd.fs.LocalEntry"/></r></a>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ var r : LocalEntry}>()]]></e></m></meta>
		</fileCache>
		<baseDir public="1" set="null"><c path="String"/></baseDir>
		<convert public="1" set="null"><c path="hxd.fs.FileConverter"/></convert>
		<getAbsolutePath public="1" set="method" line="234"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<c path="String"/>
</f></getAbsolutePath>
		<getRoot public="1" set="method" line="239"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<directoryCache expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<x path="Bool"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</directoryCache>
		<checkPath set="method" line="245"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></checkPath>
		<open set="method" line="268">
			<f a="path:?check" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="hxd.fs.LocalEntry"/>
			</f>
			<meta><m n=":value"><e>{ check : true }</e></m></meta>
		</open>
		<clearCache public="1" set="method" line="286"><f a=""><x path="Void"/></f></clearCache>
		<exists public="1" set="method" line="293"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="298"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.LocalEntry"/>
</f></get>
		<dispose public="1" set="method" line="305"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="309"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new public="1" set="method" line="207"><f a="dir:configuration">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.NotFound" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/fs/NotFound.hx">
		<path public="1"><c path="String"/></path>
		<toString set="method" line="8">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="5"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.impl.BufferFlags" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Allocator.hx" module="hxd.impl.Allocator">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.impl._Allocator.BufferFlags_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Allocator.hx" private="1" module="hxd.impl.Allocator" final="1">
	<Dynamic public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="hxd.impl.BufferFlags"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Dynamic>
	<UniformDynamic public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="hxd.impl.BufferFlags"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UniformDynamic>
	<toInt public="1" get="inline" set="null" line="6" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.impl._Allocator.BufferFlags_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Allocator.hx" private="1" module="hxd.impl.Allocator" final="1">
		<Dynamic public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="hxd.impl.BufferFlags"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Dynamic>
		<UniformDynamic public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="hxd.impl.BufferFlags"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UniformDynamic>
		<toInt public="1" get="inline" set="null" line="6" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.impl.Allocator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Allocator.hx">
		<inst static="1"><c path="hxd.impl.Allocator"/></inst>
		<set public="1" set="method" line="54" static="1"><f a="a">
	<c path="hxd.impl.Allocator"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="57" static="1"><f a=""><c path="hxd.impl.Allocator"/></f></get>
		<allocBuffer public="1" set="method" line="18"><f a="vertices:stride:flags">
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.impl.BufferFlags"/>
	<c path="h3d.Buffer"/>
</f></allocBuffer>
		<disposeBuffer public="1" set="method" line="22"><f a="b">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></disposeBuffer>
		<allocIndexBuffer public="1" set="method" line="26"><f a="count">
	<x path="Int"/>
	<c path="h3d.Indexes"/>
</f></allocIndexBuffer>
		<disposeIndexBuffer public="1" set="method" line="30"><f a="i">
	<c path="h3d.Indexes"/>
	<x path="Void"/>
</f></disposeIndexBuffer>
		<onContextLost public="1" set="method" line="34"><f a=""><x path="Void"/></f></onContextLost>
		<allocFloats public="1" set="method" line="39"><f a="count">
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
</f></allocFloats>
		<disposeFloats public="1" set="method" line="43"><f a="f">
	<x path="hxd.FloatBuffer"/>
	<x path="Void"/>
</f></disposeFloats>
		<allocIndexes public="1" set="method" line="46"><f a="count">
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
</f></allocIndexes>
		<disposeIndexes public="1" set="method" line="50"><f a="i">
	<x path="hxd.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl.Api" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Api.hx"><downcast public="1" params="T:S" get="inline" set="null" line="5" static="1"><f a="value:c">
	<c path="downcast.T"/>
	<x path="Class"><c path="downcast.S"/></x>
	<c path="downcast.S"/>
</f></downcast></class>
	<class path="hxd.impl.ArrayIterator" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/ArrayIterator.hx">
		<i><x path="Int"/></i>
		<l><x path="Int"/></l>
		<a><c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c></a>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="15"><f a=""><c path="hxd.impl.ArrayIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="7"><f a="a">
	<c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<typedef path="hxd.impl.Float32" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Float32.hx"><x path="Float"/></typedef>
	<typedef path="hxd.impl.Serializable" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Serializable.hx"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.StructSerializable" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/Serializable.hx" module="hxd.impl.Serializable"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.Float32Array" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/TypedArray.hx" module="hxd.impl.TypedArray"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></typedef>
	<typedef path="hxd.impl.UInt16" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/UInt16.hx"><x path="Int"/></typedef>
	<typedef path="hxd.impl._UncheckedBytes.InnerData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes"><t path="haxe.io.BytesData"/></typedef>
	<abstract path="hxd.impl.UncheckedBytes" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/UncheckedBytes.hx">
		<from><icast field="fromBytes"><c path="haxe.io.Bytes"/></icast></from>
		<this><t path="hxd.impl._UncheckedBytes.InnerData"/></this>
		<impl><class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes" final="1">
	<_new get="inline" set="null" line="7" static="1">
		<f a="v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="11" static="1">
		<f a="this:i">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="19" static="1">
		<f a="this:i:v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<fromBytes public="1" get="inline" set="null" line="28" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromBytes>
</class></impl>
	</abstract>
	<class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes" final="1">
		<_new get="inline" set="null" line="7" static="1">
			<f a="v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="11" static="1">
			<f a="this:i">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="19" static="1">
			<f a="this:i:v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<fromBytes public="1" get="inline" set="null" line="28" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromBytes>
	</class>
	<class path="hxd.poly2tri.Edge" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/poly2tri/Edge.hx">
		<p public="1"><c path="hxd.poly2tri.Point"/></p>
		<q public="1"><c path="hxd.poly2tri.Point"/></q>
		<toString public="1" set="method" line="42"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="p1:p2">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.poly2tri.Point" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/poly2tri/Point.hx">
		<sortPoints public="1" set="method" line="50" static="1"><f a="points">
	<c path="Array"><c path="hxd.poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" set="method" line="55" static="1"><f a="l:r">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="hxd.poly2tri.Edge"/></c></edge_list>
		<get_edge_list set="method" line="33"><f a=""><c path="Array"><c path="hxd.poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" get="inline" set="null" line="41"><f a="that">
	<c path="hxd.poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="64"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.res._Any.SingleFileSystem" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Any.hx" private="1" module="hxd.res.Any">
		<extends path="hxd.fs.BytesFileSystem"/>
		<path><c path="String"/></path>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<getBytes set="method" line="14" override="1"><f a="p">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></getBytes>
		<new public="1" set="method" line="8"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Resource" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Resource.hx">
		<LIVE_UPDATE public="1" expr="false" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</LIVE_UPDATE>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<entry public="1" set="null"><c path="hxd.fs.FileEntry"/></entry>
		<get_name get="inline" set="null" line="14"><f a=""><c path="String"/></f></get_name>
		<toString set="method" line="18"><f a=""><c path="String"/></f></toString>
		<watch public="1" set="method" line="22"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new public="1" set="method" line="10"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Any" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Any.hx">
		<extends path="hxd.res.Resource"/>
		<fromBytes public="1" set="method" line="66" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<c path="hxd.res.Any"/>
</f></fromBytes>
		<loader><c path="hxd.res.Loader"/></loader>
		<toModel public="1" set="method" line="30"><f a=""><c path="hxd.res.Model"/></f></toModel>
		<toTexture public="1" set="method" line="34"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="38"><f a=""><c path="h2d.Tile"/></f></toTile>
		<toText public="1" set="method" line="42"><f a=""><c path="String"/></f></toText>
		<toImage public="1" set="method" line="46"><f a=""><c path="hxd.res.Image"/></f></toImage>
		<toSound public="1" set="method" line="50"><f a=""><c path="hxd.res.Sound"/></f></toSound>
		<toPrefab public="1" set="method" line="54"><f a=""><c path="hxd.res.Resource"/></f></toPrefab>
		<to public="1" params="T" set="method" line="58"><f a="c">
	<x path="Class"><c path="to.T"/></x>
	<c path="to.T"/>
</f></to>
		<iterator public="1" get="inline" set="null" line="62"><f a=""><c path="hxd.impl.ArrayIterator_hxd_res_Any"/></f></iterator>
		<new public="1" set="method" line="25"><f a="loader:entry">
	<c path="hxd.res.Loader"/>
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.res.Loader</e></m>
		</meta>
	</class>
	<abstract path="hxd.res.ImageFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Image.hx" module="hxd.res.Image">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.res._Image.ImageFormat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image" final="1">
	<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Jpg>
	<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Png>
	<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Gif>
	<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tga>
	<Dds public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Dds>
	<useAsyncDecode public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</useAsyncDecode>
	<get_useAsyncDecode get="inline" set="null" line="17" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_useAsyncDecode>
	<toInt get="inline" set="null" line="25" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.res._Image.ImageFormat_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image" final="1">
		<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Jpg>
		<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Png>
		<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Gif>
		<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tga>
		<Dds public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Dds>
		<useAsyncDecode public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</useAsyncDecode>
		<get_useAsyncDecode get="inline" set="null" line="17" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_useAsyncDecode>
		<toInt get="inline" set="null" line="25" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.res.Image" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Image.hx">
		<extends path="hxd.res.Resource"/>
		<ALLOW_NPOT public="1" expr="true" line="34" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Specify if we will automatically convert non-power-of-two textures to power-of-two.</haxe_doc>
		</ALLOW_NPOT>
		<DEFAULT_FILTER public="1" expr="Linear" line="35" static="1">
			<e path="h3d.mat.Filter"/>
			<meta><m n=":value"><e>Linear</e></m></meta>
		</DEFAULT_FILTER>
		<DEFAULT_ASYNC public="1" expr="false" line="40" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Forces async decoding for images if available on the target platform.</haxe_doc>
		</DEFAULT_ASYNC>
		<ENABLE_AUTO_WATCH expr="true" line="42" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<tex><c path="h3d.mat.Texture"/></tex>
		<inf><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
	<format><x path="hxd.res.ImageFormat"/></format>
	<bc><x path="Int"/></bc>
</a></inf>
		<getFormat public="1" set="method" line="47"><f a=""><x path="hxd.res.ImageFormat"/></f></getFormat>
		<getSize public="1" set="method" line="52"><f a=""><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
</a></f></getSize>
		<getPixels public="1" set="method" line="146"><f a="?fmt:?flipY">
	<e path="hxd.PixelFormat"/>
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></getPixels>
		<toBitmap public="1" set="method" line="248"><f a=""><c path="hxd.BitmapData"/></f></toBitmap>
		<watchCallb set="method" line="257"><f a=""><x path="Void"/></f></watchCallb>
		<loadTexture set="method" line="267"><f a=""><x path="Void"/></f></loadTexture>
		<toTexture public="1" set="method" line="315"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="337"><f a=""><c path="h2d.Tile"/></f></toTile>
		<new public="1" set="method" line="29"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Loader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Loader.hx">
		<currentInstance public="1" static="1">
			<c path="hxd.res.Loader"/>
			<haxe_doc>Set when initializing hxd.Res, or manually.
		Allows code to resolve resources without compiling hxd.Res</haxe_doc>
		</currentInstance>
		<fs public="1" set="null"><c path="hxd.fs.FileSystem"/></fs>
		<cache><t path="Map">
	<c path="String"/>
	<d/>
</t></cache>
		<cleanCache public="1" set="method" line="19"><f a=""><x path="Void"/></f></cleanCache>
		<dir public="1" set="method" line="23"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.res.Any"/></c>
</f></dir>
		<exists public="1" set="method" line="31"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<load public="1" set="method" line="35"><f a="path">
	<c path="String"/>
	<c path="hxd.res.Any"/>
</f></load>
		<loadCache public="1" params="T" set="method" line="39"><f a="path:c">
	<c path="String"/>
	<x path="Class"><c path="loadCache.T"/></x>
	<c path="loadCache.T"/>
</f></loadCache>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="fs">
	<c path="hxd.fs.FileSystem"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Model" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Model.hx">
		<extends path="hxd.res.Resource"/>
		<toHmd public="1" set="method" line="5"><f a=""><c path="hxd.fmt.hmd.Library"/></f></toHmd>
		<new public="1" set="method" line="3"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.res.Filter" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx" module="hxd.res.NanoJpeg">
		<Fast/>
		<Chromatic/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="hxd.res._NanoJpeg.FastBytes" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<this><c path="haxe.io.Bytes"/></this>
		<impl><class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg" final="1">
	<_new public="1" get="inline" set="null" line="27" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.res._NanoJpeg.FastBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="30" static="1">
		<f a="this:i">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="33" static="1">
		<f a="this:i:v">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg" final="1">
		<_new public="1" get="inline" set="null" line="27" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.res._NanoJpeg.FastBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="30" static="1">
			<f a="this:i">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="33" static="1">
			<f a="this:i:v">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<class path="hxd.res._NanoJpeg.Component" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<cid public="1"><x path="Int"/></cid>
		<ssx public="1"><x path="Int"/></ssx>
		<ssy public="1"><x path="Int"/></ssy>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<stride public="1"><x path="Int"/></stride>
		<qtsel public="1"><x path="Int"/></qtsel>
		<actabsel public="1"><x path="Int"/></actabsel>
		<dctabsel public="1"><x path="Int"/></dctabsel>
		<dcpred public="1"><x path="Int"/></dcpred>
		<pixels public="1"><c path="haxe.io.Bytes"/></pixels>
		<new public="1" set="method" line="50"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.NanoJpeg" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NanoJpeg.hx">
		<BLOCKSIZE get="inline" set="null" expr="64" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</BLOCKSIZE>
		<W1 get="inline" set="null" expr="2841" line="355" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2841</e></m></meta>
		</W1>
		<W2 get="inline" set="null" expr="2676" line="356" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2676</e></m></meta>
		</W2>
		<W3 get="inline" set="null" expr="2408" line="357" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2408</e></m></meta>
		</W3>
		<W5 get="inline" set="null" expr="1609" line="358" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1609</e></m></meta>
		</W5>
		<W6 get="inline" set="null" expr="1108" line="359" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1108</e></m></meta>
		</W6>
		<W7 get="inline" set="null" expr="565" line="360" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>565</e></m></meta>
		</W7>
		<CF4A get="inline" set="null" expr="-9" line="527" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF4A>
		<CF4B get="inline" set="null" expr="111" line="528" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</CF4B>
		<CF4C get="inline" set="null" expr="29" line="529" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</CF4C>
		<CF4D get="inline" set="null" expr="-3" line="530" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF4D>
		<CF3A get="inline" set="null" expr="28" line="531" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</CF3A>
		<CF3B get="inline" set="null" expr="109" line="532" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</CF3B>
		<CF3C get="inline" set="null" expr="-9" line="533" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF3C>
		<CF3X get="inline" set="null" expr="104" line="534" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</CF3X>
		<CF3Y get="inline" set="null" expr="27" line="535" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</CF3Y>
		<CF3Z get="inline" set="null" expr="-3" line="536" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF3Z>
		<CF2A get="inline" set="null" expr="139" line="537" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>139</e></m></meta>
		</CF2A>
		<CF2B get="inline" set="null" expr="-11" line="538" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-11</e></m></meta>
		</CF2B>
		<CF get="inline" set="null" line="539" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></CF>
		<njClip get="inline" set="null" line="541" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></njClip>
		<inst expr="null" line="742" static="1">
			<c path="hxd.res.NanoJpeg"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<decode public="1" set="method" line="743" static="1">
			<f a="bytes:?filter:?position:?size" v="::0:-1">
				<c path="haxe.io.Bytes"/>
				<e path="hxd.res.Filter"/>
				<x path="Int"/>
				<x path="Int"/>
				<a>
					<width><x path="Int"/></width>
					<pixels><c path="haxe.io.Bytes"/></pixels>
					<height><x path="Int"/></height>
				</a>
			</f>
			<meta><m n=":value"><e>{ size : -1, position : 0 }</e></m></meta>
		</decode>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<size><x path="Int"/></size>
		<length><x path="Int"/></length>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
		<ncomp><x path="Int"/></ncomp>
		<comps><x path="haxe.ds.Vector"><c path="hxd.res._NanoJpeg.Component"/></x></comps>
		<counts><x path="haxe.ds.Vector"><x path="Int"/></x></counts>
		<qtab><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></qtab>
		<qtused><x path="Int"/></qtused>
		<qtavail><x path="Int"/></qtavail>
		<vlctab><x path="haxe.ds.Vector"><c path="haxe.io.Bytes"/></x></vlctab>
		<block><x path="haxe.ds.Vector"><x path="Int"/></x></block>
		<njZZ><x path="haxe.ds.Vector"><x path="Int"/></x></njZZ>
		<progressive><x path="Bool"/></progressive>
		<mbsizex><x path="Int"/></mbsizex>
		<mbsizey><x path="Int"/></mbsizey>
		<mbwidth><x path="Int"/></mbwidth>
		<mbheight><x path="Int"/></mbheight>
		<rstinterval><x path="Int"/></rstinterval>
		<buf><x path="Int"/></buf>
		<bufbits><x path="Int"/></bufbits>
		<pixels><c path="haxe.io.Bytes"/></pixels>
		<filter><e path="hxd.res.Filter"/></filter>
		<alloc get="inline" set="null" line="106"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<free get="inline" set="null" line="110"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></free>
		<njInit set="method" line="113"><f a="bytes:pos:size:filter">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.res.Filter"/>
	<x path="Void"/>
</f></njInit>
		<cleanup set="method" line="133"><f a=""><x path="Void"/></f></cleanup>
		<njSkip get="inline" set="null" line="147"><f a="count">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkip>
		<syntax get="inline" set="null" line="154"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></syntax>
		<get get="inline" set="null" line="160"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<njDecode16 get="inline" set="null" line="164"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></njDecode16>
		<njByteAlign get="inline" set="null" line="168"><f a=""><x path="Void"/></f></njByteAlign>
		<njShowBits set="method" line="172"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njShowBits>
		<njSkipBits get="inline" set="null" line="204"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkipBits>
		<njGetBits get="inline" set="null" line="210"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njGetBits>
		<njDecodeLength get="inline" set="null" line="216"><f a=""><x path="Void"/></f></njDecodeLength>
		<njSkipMarker get="inline" set="null" line="223"><f a=""><x path="Void"/></f></njSkipMarker>
		<njDecodeSOF set="method" line="228"><f a=""><x path="Void"/></f></njDecodeSOF>
		<njDecodeDQT set="method" line="280"><f a=""><x path="Void"/></f></njDecodeDQT>
		<njDecodeDHT set="method" line="294"><f a=""><x path="Void"/></f></njDecodeDHT>
		<njDecodeDRI set="method" line="330"><f a=""><x path="Void"/></f></njDecodeDRI>
		<vlcCode><x path="Int"/></vlcCode>
		<njGetVLC get="inline" set="null" line="340"><f a="vlc">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></njGetVLC>
		<njRowIDCT get="inline" set="null" line="362"><f a="bp">
	<x path="Int"/>
	<x path="Void"/>
</f></njRowIDCT>
		<njColIDCT get="inline" set="null" line="406"><f a="bp:out:po:stride">
	<x path="Int"/>
	<x path="hxd.res._NanoJpeg.FastBytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njColIDCT>
		<njDecodeBlock set="method" line="455"><f a="c:po">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njDecodeBlock>
		<notSupported set="method" line="478"><f a=""><x path="Void"/></f></notSupported>
		<njDecodeScan set="method" line="482"><f a=""><x path="Void"/></f></njDecodeScan>
		<njUpsampleH set="method" line="545"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleH>
		<njUpsampleV set="method" line="574"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleV>
		<njUpsample set="method" line="602"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsample>
		<njConvert set="method" line="632"><f a=""><c path="haxe.io.Bytes"/></f></njConvert>
		<njDecode set="method" line="702"><f a=""><a>
	<width><x path="Int"/></width>
	<pixels><c path="haxe.io.Bytes"/></pixels>
	<height><x path="Int"/></height>
</a></f></njDecode>
		<new set="method" line="88"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="hxd.res.NotFound" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/NotFound.hx"><c path="hxd.fs.NotFound"/></typedef>
	<typedef path="hxd.res.Prefab" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Prefab.hx"><c path="hxd.res.Resource"/></typedef>
	<enum path="hxd.res.SoundFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Sound.hx" module="hxd.res.Sound">
		<Wav/>
		<Mp3/>
		<OggVorbis/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.res.Sound" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/res/Sound.hx">
		<extends path="hxd.res.Resource"/>
		<ENABLE_AUTO_WATCH expr="true" line="11" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<supportedFormat public="1" set="method" line="17" static="1"><f a="fmt">
	<e path="hxd.res.SoundFormat"/>
	<x path="Bool"/>
</f></supportedFormat>
		<startWorker public="1" set="method" line="80" static="1"><f a=""><x path="Bool"/></f></startWorker>
		<data><c path="hxd.snd.Data"/></data>
		<channel><c path="hxd.snd.Channel"/></channel>
		<lastPlay public="1" set="null" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lastPlay>
		<getData public="1" set="method" line="30"><f a=""><c path="hxd.snd.Data"/></f></getData>
		<dispose public="1" set="method" line="60"><f a=""><x path="Void"/></f></dispose>
		<stop public="1" set="method" line="65"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="72">
			<f a="?loop:?volume:?channelGroup:?soundGroup" v="false:1.::">
				<x path="Bool"/>
				<x path="Float"/>
				<c path="hxd.snd.ChannelGroup"/>
				<c path="hxd.snd.SoundGroup"/>
				<c path="hxd.snd.Channel"/>
			</f>
			<meta><m n=":value"><e>{ volume : 1., loop : false }</e></m></meta>
		</play>
		<watchCallb set="method" line="85">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>hxd.snd.ChannelBase</e></m></meta>
		</watchCallb>
		<new public="1" set="method" line="9"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.ChannelBase" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/ChannelBase.hx">
		<priority public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</priority>
		<mute public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mute>
		<effects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<bindedEffects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bindedEffects>
		<volume public="1" set="accessor" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<currentFade><a>
	<targetVolume><x path="Float"/></targetVolume>
	<startVolume><x path="Float"/></startVolume>
	<start><x path="Float"/></start>
	<onEnd><f a=""><x path="Void"/></f></onEnd>
	<duration><x path="Float"/></duration>
</a></currentFade>
		<currentVolume><x path="Float"/></currentVolume>
		<getEffect public="1" params="T" set="method" line="18"><f a="etype">
	<x path="Class"><c path="getEffect.T"/></x>
	<c path="getEffect.T"/>
</f></getEffect>
		<set_volume set="method" line="27"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<fadeTo public="1" set="method" line="32">
			<f a="volume:?time:?onEnd" v=":1.:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ time : 1. }</e></m></meta>
		</fadeTo>
		<updateCurrentVolume set="method" line="36"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<addEffect public="1" params="T" set="method" line="52">
			<f a="e">
				<c path="addEffect.T"/>
				<c path="addEffect.T"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</addEffect>
		<removeEffect public="1" set="method" line="60">
			<f a="e">
				<c path="hxd.snd.Effect"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</removeEffect>
		<new set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Channel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Channel.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<ID expr="0" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<next public="1">
			<c path="hxd.snd.Channel"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<manager><c path="hxd.snd.Manager"/></manager>
		<source><c path="hxd.snd.Source"/></source>
		<id><x path="Int"/></id>
		<sound public="1" set="null"><c path="hxd.res.Sound"/></sound>
		<duration public="1" set="null"><x path="Float"/></duration>
		<soundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></soundGroup>
		<channelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></channelGroup>
		<position public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</position>
		<pause public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pause>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<allowVirtual public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowVirtual>
		<audibleVolume expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</audibleVolume>
		<lastStamp expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</lastStamp>
		<isVirtual expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isVirtual>
		<isLoading expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isLoading>
		<positionChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</positionChanged>
		<queue expr="[]">
			<c path="Array"><c path="hxd.res.Sound"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</queue>
		<onEnd public="1" set="dynamic" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onEnd() is called when a sound which does not loop has finished playing
		or when we switch buffer in a queue
		or when a sound which is streamed loops.</haxe_doc>
		</onEnd>
		<set_position set="method" line="42"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<set_pause set="method" line="50"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pause>
		<updateCurrentVolume set="method" line="55" override="1"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<calcAudibleVolume public="1" set="method" line="72"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></calcAudibleVolume>
		<queueSound public="1" set="method" line="86">
			<f a="sound">
				<c path="hxd.res.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a sound to the queue. When the current sound is finished playing, the next one will seamlessly continue.
		This will also trigger an onEnd() event.</haxe_doc>
		</queueSound>
		<stop public="1" set="method" line="90"><f a=""><x path="Void"/></f></stop>
		<isReleased public="1" set="method" line="94"><f a=""><x path="Bool"/></f></isReleased>
		<new set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.ChannelGroup" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/ChannelGroup.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method" line="7"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.SampleFormat" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Data.hx" module="hxd.snd.Data">
		<UI8/>
		<I16/>
		<F32/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Data" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Data.hx">
		<formatBytes public="1" get="inline" set="null" line="165" static="1"><f a="format">
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
</f></formatBytes>
		<samples public="1" set="null"><x path="Int"/></samples>
		<samplingRate public="1" set="null"><x path="Int"/></samplingRate>
		<sampleFormat public="1" set="null"><e path="hxd.snd.SampleFormat"/></sampleFormat>
		<channels public="1" set="null"><x path="Int"/></channels>
		<duration public="1" get="accessor" set="null"><x path="Float"/></duration>
		<isLoading public="1" set="method" line="18"><f a=""><x path="Bool"/></f></isLoading>
		<decode public="1" set="method" line="22"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decode>
		<resample public="1" set="method" line="45"><f a="rate:format:channels">
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<c path="hxd.snd.Data"/>
</f></resample>
		<resampleBuffer public="1" set="method" line="67">
			<f a="out:outPos:input:inPos:rate:format:channels:samples">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="hxd.snd.SampleFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</resampleBuffer>
		<decodeBuffer set="method" line="157"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<getBytesPerSample public="1" set="method" line="161"><f a=""><x path="Int"/></f></getBytesPerSample>
		<load public="1" set="method" line="178">
			<f a="onEnd">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some platforms might require some data to be loaded before we can start decoding.
		Use load() and wait for onEnd to make sure that the sound data and the correct number of samples is available.
		onEnd() might be called back immediately if the data is already available.</haxe_doc>
		</load>
		<get_duration set="method" line="182"><f a=""><x path="Float"/></f></get_duration>
	</class>
	<typedef path="hxd.snd.SourceHandle" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.SourceHandle"/></typedef>
	<typedef path="hxd.snd.BufferHandle" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.BufferHandle"/></typedef>
	<class path="hxd.snd.EffectDriver" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<acquire public="1" set="method" line="17"><f a=""><x path="Void"/></f></acquire>
		<release public="1" set="method" line="18"><f a=""><x path="Void"/></f></release>
		<update public="1" set="method" line="19"><f a="e">
	<c path="hxd.snd.EffectDriver.T"/>
	<x path="Void"/>
</f></update>
		<bind public="1" set="method" line="20"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></bind>
		<apply public="1" set="method" line="21"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></apply>
		<unbind public="1" set="method" line="22"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></unbind>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.DriverFeature" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<MasterVolume/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Driver" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Driver.hx" interface="1">
		<hasFeature public="1" set="method"><f a="d">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setMasterVolume public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method"><f a=""><t path="hxd.snd.SourceHandle"/></f></createSource>
		<playSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method"><f a="source:value">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<destroySource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<createBuffer public="1" set="method"><f a=""><t path="hxd.snd.BufferHandle"/></f></createBuffer>
		<setBufferData public="1" set="method"><f a="buffer:data:size:format:channelCount:samplingRate">
	<t path="hxd.snd.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<destroyBuffer public="1" set="method"><f a="buffer">
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<queueBuffer public="1" set="method"><f a="source:buffer:sampleStart:endOfStream">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method"><f a="source:buffer">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<getProcessedBuffers public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<getPlayedSampleCount public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
	</class>
	<class path="hxd.snd.Effect" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Effect.hx">
		<next public="1">
			<c path="hxd.snd.Effect"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<refs><x path="Int"/></refs>
		<retainTime><x path="Float"/></retainTime>
		<lastStamp><x path="Float"/></lastStamp>
		<driver><c path="hxd.snd.EffectDriver"><d/></c></driver>
		<priority><x path="Int"/></priority>
		<applyAudibleVolumeModifier public="1" set="method" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></applyAudibleVolumeModifier>
		<getVolumeModifier public="1" set="method" line="33"><f a=""><x path="Float"/></f></getVolumeModifier>
		<new public="1" set="method" line="14"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Listener" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Listener.hx">
		<position public="1"><c path="h3d.Vector"/></position>
		<direction public="1"><c path="h3d.Vector"/></direction>
		<velocity public="1"><c path="h3d.Vector"/></velocity>
		<up public="1"><c path="h3d.Vector"/></up>
		<syncCamera public="1" set="method" line="17"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></syncCamera>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Source" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<ID expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<id public="1" set="null"><x path="Int"/></id>
		<handle public="1"><t path="hxd.snd.SourceHandle"/></handle>
		<channel public="1"><c path="hxd.snd.Channel"/></channel>
		<buffers public="1"><c path="Array"><c path="hxd.snd.Buffer"/></c></buffers>
		<volume public="1" expr="-1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.0</e></m></meta>
		</volume>
		<playing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playing>
		<start public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</start>
		<streamSound public="1"><c path="hxd.res.Sound"/></streamSound>
		<streamBuffer public="1"><c path="haxe.io.Bytes"/></streamBuffer>
		<streamStart public="1"><x path="Int"/></streamStart>
		<streamPos public="1"><x path="Int"/></streamPos>
		<dispose public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="24"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Buffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<handle public="1"><t path="hxd.snd.BufferHandle"/></handle>
		<sound public="1"><c path="hxd.res.Sound"/></sound>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<isStream public="1"><x path="Bool"/></isStream>
		<refs public="1"><x path="Int"/></refs>
		<lastStop public="1"><x path="Float"/></lastStop>
		<start public="1"><x path="Int"/></start>
		<end public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</end>
		<samples public="1"><x path="Int"/></samples>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="49"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Manager" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Manager.hx">
		<STREAM_DURATION public="1" expr="5." line="62" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5.</e></m></meta>
		</STREAM_DURATION>
		<STREAM_BUFFER_SAMPLE_COUNT public="1" expr="44100" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>44100</e></m></meta>
		</STREAM_BUFFER_SAMPLE_COUNT>
		<BUFFER_QUEUE_LENGTH public="1" expr="2" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BUFFER_QUEUE_LENGTH>
		<MAX_SOURCES public="1" expr="16" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</MAX_SOURCES>
		<SOUND_BUFFER_CACHE_SIZE public="1" expr="256" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SOUND_BUFFER_CACHE_SIZE>
		<VIRTUAL_VOLUME_THRESHOLD public="1" expr="1e-5" line="67" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-5</e></m></meta>
		</VIRTUAL_VOLUME_THRESHOLD>
		<BUFFER_STREAM_SPLIT public="1" expr="16" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
			<haxe_doc>Allows to decode big streaming buffers over X split frames. 0 to disable</haxe_doc>
		</BUFFER_STREAM_SPLIT>
		<instance static="1"><c path="hxd.snd.Manager"/></instance>
		<get public="1" set="method" line="147" static="1"><f a=""><c path="hxd.snd.Manager"/></f></get>
		<regEffect set="method" line="627" static="1"><f a="list:e">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
</f></regEffect>
		<masterVolume public="1"><x path="Float"/></masterVolume>
		<masterSoundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></masterSoundGroup>
		<masterChannelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></masterChannelGroup>
		<listener public="1"><c path="hxd.snd.Listener"/></listener>
		<timeOffset public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</timeOffset>
		<updateEvent><c path="haxe.MainEvent"/></updateEvent>
		<cachedBytes><c path="haxe.io.Bytes"/></cachedBytes>
		<resampleBytes><c path="haxe.io.Bytes"/></resampleBytes>
		<driver><c path="hxd.snd.Driver"/></driver>
		<channels><c path="hxd.snd.Channel"/></channels>
		<sources><c path="Array"><c path="hxd.snd.Source"/></c></sources>
		<now><x path="Float"/></now>
		<soundBufferCount><x path="Int"/></soundBufferCount>
		<soundBufferMap><t path="Map">
	<c path="String"/>
	<c path="hxd.snd.Buffer"/>
</t></soundBufferMap>
		<soundBufferKeys><c path="Array"><c path="String"/></c></soundBufferKeys>
		<freeStreamBuffers><c path="Array"><c path="hxd.snd.Buffer"/></c></freeStreamBuffers>
		<effectGC><c path="Array"><c path="hxd.snd.Effect"/></c></effectGC>
		<hasMasterVolume><x path="Bool"/></hasMasterVolume>
		<suspended public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</suspended>
		<getTmpBytes set="method" line="135"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<getResampleBytes set="method" line="141"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getResampleBytes>
		<stopAll public="1" set="method" line="156"><f a=""><x path="Void"/></f></stopAll>
		<stopAllNotLooping public="1" set="method" line="161"><f a=""><x path="Void"/></f></stopAllNotLooping>
		<stopByName public="1" set="method" line="170"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></stopByName>
		<getAll public="1" set="method" line="182">
			<f a="sound">
				<c path="hxd.res.Sound"/>
				<t path="Iterator"><c path="hxd.snd.Channel"/></t>
			</f>
			<haxe_doc>Returns iterator with all active instances of a Sound at the call time.</haxe_doc>
		</getAll>
		<cleanCache public="1" set="method" line="193"><f a=""><x path="Void"/></f></cleanCache>
		<dispose public="1" set="method" line="208"><f a=""><x path="Void"/></f></dispose>
		<play public="1" set="method" line="229"><f a="sound:?channelGroup:?soundGroup">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.ChannelGroup"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Channel"/>
</f></play>
		<updateVirtualChannels set="method" line="250"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVirtualChannels>
		<update public="1" set="method" line="283"><f a=""><x path="Void"/></f></update>
		<progressiveDecodeBuffer set="method" line="571"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></progressiveDecodeBuffer>
		<queueBuffer set="method" line="595"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></queueBuffer>
		<unqueueBuffer set="method" line="618"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Null"><c path="hxd.snd.Buffer"/></x>
</f></unqueueBuffer>
		<bindEffect set="method" line="637"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></bindEffect>
		<unbindEffect set="method" line="644"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></unbindEffect>
		<releaseSource set="method" line="653"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Void"/>
</f></releaseSource>
		<targetRate><x path="Int"/></targetRate>
		<targetFormat><e path="hxd.snd.SampleFormat"/></targetFormat>
		<targetChannels><x path="Int"/></targetChannels>
		<checkTargetFormat set="method" line="674">
			<f a="dat:?forceMono" v=":false">
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</checkTargetFormat>
		<getSoundBuffer set="method" line="694"><f a="snd:grp">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Buffer"/>
</f></getSoundBuffer>
		<fillSoundBuffer set="method" line="716">
			<f a="buf:dat:?forceMono" v="::false">
				<c path="hxd.snd.Buffer"/>
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</fillSoundBuffer>
		<getStreamBuffer set="method" line="728"><f a="src:snd:grp:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<x path="Int"/>
	<c path="hxd.snd.Buffer"/>
</f></getStreamBuffer>
		<sortChannel set="method" line="772"><f a="a:b">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Channel"/>
	<x path="Int"/>
</f></sortChannel>
		<sortEffect set="method" line="788"><f a="a:b">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></sortEffect>
		<releaseChannel set="method" line="792"><f a="c">
	<c path="hxd.snd.Channel"/>
	<x path="Void"/>
</f></releaseChannel>
		<new set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Mp3Data" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/Mp3Data.hx">
		<extends path="hxd.snd.Data"/>
		<decodeBuffer set="method" line="143" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="28"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.NativeChannel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/NativeChannel.hx">
		<bufferSamples public="1" set="null"><x path="Int"/></bufferSamples>
		<onSample set="method" line="214"><f a="out">
	<x path="haxe.io.Float32Array"/>
	<x path="Void"/>
</f></onSample>
		<stop public="1" set="method" line="217"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="127"><f a="bufferSamples">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.snd.SoundGroup" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/SoundGroup.hx">
		<name public="1" set="null"><c path="String"/></name>
		<volume public="1"><x path="Float"/></volume>
		<maxAudible public="1"><x path="Int"/></maxAudible>
		<mono public="1"><x path="Bool"/></mono>
		<numAudible><x path="Int"/></numAudible>
		<lastUpdate><x path="Float"/></lastUpdate>
		<new public="1" set="method" line="13"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.WavData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/WavData.hx">
		<extends path="hxd.snd.Data"/>
		<rawData><c path="haxe.io.Bytes"/></rawData>
		<init set="method" line="13"><f a="d">
	<t path="format.wav.WAVE"/>
	<x path="Void"/>
</f></init>
		<decodeBuffer set="method" line="27" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="8"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal.AL" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes"><c path="hxd.snd.openal.Emulator"/></typedef>
	<class path="hxd.snd.openal.BufferHandle" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Buffer"/></inst>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.SourceHandle" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Source"/></inst>
		<sampleOffset public="1"><x path="Int"/></sampleOffset>
		<playing public="1"><x path="Bool"/></playing>
		<nextAuxiliarySend><x path="Int"/></nextAuxiliarySend>
		<freeAuxiliarySends><c path="Array"><x path="Int"/></c></freeAuxiliarySends>
		<effectToAuxiliarySend><t path="Map">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</t></effectToAuxiliarySend>
		<acquireAuxiliarySend public="1" set="method" line="34"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></acquireAuxiliarySend>
		<getAuxiliarySend public="1" set="method" line="42"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></getAuxiliarySend>
		<releaseAuxiliarySend public="1" set="method" line="46"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></releaseAuxiliarySend>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Driver" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Driver.hx">
		<implements path="hxd.snd.Driver"/>
		<device public="1" set="null"><c path="hxd.snd.openal.Device"/></device>
		<context public="1" set="null"><c path="hxd.snd.openal.Context"/></context>
		<maxAuxiliarySends public="1" set="null"><x path="Int"/></maxAuxiliarySends>
		<tmpBytes><c path="haxe.io.Bytes"/></tmpBytes>
		<hasFeature public="1" set="method" line="39"><f a="f">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getTmpBytes public="1" set="method" line="45"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<setMasterVolume public="1" set="method" line="50"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method" line="54"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method" line="73"><f a=""><c path="hxd.snd.openal.SourceHandle"/></f></createSource>
		<destroySource public="1" set="method" line="85"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<playSource public="1" set="method" line="93"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method" line="99"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method" line="104"><f a="source:value">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<createBuffer public="1" set="method" line="108"><f a=""><c path="hxd.snd.openal.BufferHandle"/></f></createBuffer>
		<destroyBuffer public="1" set="method" line="116"><f a="buffer">
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<setBufferData public="1" set="method" line="122"><f a="buffer:data:size:format:channelCount:samplingRate">
	<c path="hxd.snd.openal.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<getPlayedSampleCount public="1" set="method" line="135"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<getProcessedBuffers public="1" set="method" line="142"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<queueBuffer public="1" set="method" line="146"><f a="source:buffer:sampleStart:endOfStream">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method" line="167"><f a="source:buffer">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<update public="1" set="method" line="180"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method" line="183"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method" line="189"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal._Emulator.F32" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><x path="Float"/></typedef>
	<typedef path="hxd.snd.openal._Emulator.Bytes" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><c path="haxe.io.Bytes"/></typedef>
	<class path="hxd.snd.openal._Emulator.Channel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator">
		<extends path="hxd.snd.NativeChannel"/>
		<FADE_START get="inline" set="null" expr="10" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</FADE_START>
		<source><c path="hxd.snd.openal.Source"/></source>
		<startup expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</startup>
		<onSample set="method" line="21" override="1">
			<f a="out">
				<x path="haxe.io.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</onSample>
		<new public="1" set="method" line="12"><f a="source:samples">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Source" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<STOP_DELAY get="inline" set="null" expr="0" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</STOP_DELAY>
		<CHANNEL_BUFSIZE public="1" expr="4096" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4096</e></m></meta>
		</CHANNEL_BUFSIZE>
		<ID expr="0" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Source&gt;()" line="87" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Source"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Source>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="139" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Source"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<chan public="1"><c path="hxd.snd.NativeChannel"/></chan>
		<playedTime public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</playedTime>
		<currentSample public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</currentSample>
		<buffers public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.openal.Buffer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buffers>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<volume public="1" expr="1.">
			<t path="hxd.snd.openal._Emulator.F32"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<playing public="1" get="accessor" set="null"><x path="Bool"/></playing>
		<duration public="1"><x path="Float"/></duration>
		<frequency public="1"><x path="Int"/></frequency>
		<updateDuration public="1" set="method" line="106"><f a=""><x path="Void"/></f></updateDuration>
		<get_playing get="inline" set="null" line="113"><f a=""><x path="Bool"/></f></get_playing>
		<play public="1" set="method" line="115"><f a=""><x path="Void"/></f></play>
		<stop public="1" set="method" line="122">
			<f a="?immediate" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ immediate : false }</e></m></meta>
		</stop>
		<dispose public="1" set="method" line="132"><f a=""><x path="Void"/></f></dispose>
		<toInt public="1" get="inline" set="null" line="138"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Buffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ID expr="0" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Buffer&gt;()" line="145" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Buffer"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Buffer>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="170" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Buffer"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<data public="1"><x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x></data>
		<frequency public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</frequency>
		<samples public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</samples>
		<dispose public="1" set="method" line="157"><f a=""><x path="Void"/></f></dispose>
		<alloc public="1" set="method" line="163"><f a="size">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x>
</f></alloc>
		<toInt public="1" get="inline" set="null" line="169"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="152"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Emulator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx">
		<NATIVE_FREQ public="1" get="accessor" set="null" static="1"><x path="Int"/></NATIVE_FREQ>
		<CACHED_FREQ static="1"><x path="Null"><x path="Int"/></x></CACHED_FREQ>
		<get_NATIVE_FREQ set="method" line="182" static="1"><f a=""><x path="Null"><x path="Int"/></x></f></get_NATIVE_FREQ>
		<dopplerFactor public="1" set="method" line="190" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="191" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<speedOfSound public="1" set="method" line="192" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></speedOfSound>
		<distanceModel public="1" set="method" line="193" static="1"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<enable public="1" set="method" line="196" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<disable public="1" set="method" line="197" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<isEnabled public="1" set="method" line="198" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<getBooleanv public="1" set="method" line="201" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBooleanv>
		<getIntegerv public="1" set="method" line="204" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<getFloatv public="1" set="method" line="207" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getFloatv>
		<getDoublev public="1" set="method" line="210" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getDoublev>
		<getString public="1" set="method" line="214" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getBoolean public="1" set="method" line="218" static="1"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getInteger public="1" set="method" line="222" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getFloat public="1" set="method" line="226" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getFloat>
		<getDouble public="1" set="method" line="230" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getError public="1" set="method" line="235" static="1"><f a=""><x path="Int"/></f></getError>
		<loadExtensions public="1" set="method" line="240" static="1"><f a=""><x path="Void"/></f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="242" static="1"><f a="extname">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="246" static="1"><f a="ename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<listenerf public="1" set="method" line="252" static="1"><f a="param:value">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listenerf>
		<listener3f public="1" set="method" line="261" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listener3f>
		<listenerfv public="1" set="method" line="262" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="263" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listener3i public="1" set="method" line="264" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listeneriv public="1" set="method" line="265" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listeneriv>
		<getListenerf public="1" set="method" line="268" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getListenerf>
		<getListener3f public="1" set="method" line="271" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getListener3f>
		<getListenerfv public="1" set="method" line="275" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListenerfv>
		<getListeneri public="1" set="method" line="278" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListener3i public="1" set="method" line="281" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getListener3i>
		<getListeneriv public="1" set="method" line="284" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListeneriv>
		<genSources public="1" set="method" line="289" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genSources>
		<deleteSources public="1" set="method" line="294" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteSources>
		<isSource public="1" set="method" line="299" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Bool"/>
</f></isSource>
		<sourcef public="1" set="method" line="304" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></sourcef>
		<source3f public="1" set="method" line="325" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></source3f>
		<sourcefv public="1" set="method" line="333" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="339" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<source3i public="1" set="method" line="362" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourceiv public="1" set="method" line="368" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceiv>
		<getSourcef public="1" set="method" line="376" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getSourcef>
		<getSourcei public="1" set="method" line="396" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSource3f public="1" set="method" line="418" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getSource3f>
		<getSourcefv public="1" set="method" line="421" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourcefv>
		<getSource3i public="1" set="method" line="424" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getSource3i>
		<getSourceiv public="1" set="method" line="427" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourceiv>
		<sourcePlayv public="1" set="method" line="432" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStopv public="1" set="method" line="435" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewindv public="1" set="method" line="438" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePausev public="1" set="method" line="441" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePausev>
		<sourcePlay public="1" set="method" line="445" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourceStop public="1" set="method" line="449" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceRewind public="1" set="method" line="454" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourcePause public="1" set="method" line="457" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePause>
		<sourceQueueBuffers public="1" set="method" line="462" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffers public="1" set="method" line="471" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceUnqueueBuffers>
		<genBuffers public="1" set="method" line="487" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genBuffers>
		<deleteBuffers public="1" set="method" line="491" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteBuffers>
		<isBuffer public="1" set="method" line="495" static="1"><f a="buffer">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<bufferData public="1" set="method" line="500" static="1">
			<f a="buffer:format:data:size:freq">
				<c path="hxd.snd.openal.Buffer"/>
				<x path="Int"/>
				<t path="hxd.snd.openal._Emulator.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</bufferData>
		<bufferf public="1" set="method" line="555" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></bufferf>
		<buffer3f public="1" set="method" line="561" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></buffer3f>
		<bufferfv public="1" set="method" line="567" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="573" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<buffer3i public="1" set="method" line="579" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferiv public="1" set="method" line="585" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferiv>
		<getBufferf public="1" set="method" line="593" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getBufferf>
		<getBuffer3f public="1" set="method" line="596" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getBuffer3f>
		<getBufferfv public="1" set="method" line="599" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferfv>
		<getBufferi public="1" set="method" line="602" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBuffer3i public="1" set="method" line="611" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getBuffer3i>
		<getBufferiv public="1" set="method" line="614" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferiv>
		<FORMAT_MONOF32 public="1" get="inline" set="null" expr="0x1110" line="621" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1110</e></m></meta>
		</FORMAT_MONOF32>
		<FORMAT_STEREOF32 public="1" get="inline" set="null" expr="0x1111" line="622" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1111</e></m></meta>
		</FORMAT_STEREOF32>
		<NONE public="1" get="inline" set="null" expr="0" line="628" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FALSE public="1" get="inline" set="null" expr="0" line="629" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="630" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<SOURCE_RELATIVE public="1" get="inline" set="null" expr="0x202" line="632" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x202</e></m></meta>
		</SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" get="inline" set="null" expr="0x1001" line="633" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" get="inline" set="null" expr="0x1002" line="634" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</CONE_OUTER_ANGLE>
		<PITCH public="1" get="inline" set="null" expr="0x1003" line="635" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</PITCH>
		<POSITION public="1" get="inline" set="null" expr="0x1004" line="637" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</POSITION>
		<DIRECTION public="1" get="inline" set="null" expr="0x1005" line="638" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DIRECTION>
		<VELOCITY public="1" get="inline" set="null" expr="0x1006" line="640" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</VELOCITY>
		<LOOPING public="1" get="inline" set="null" expr="0x1007" line="641" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</LOOPING>
		<BUFFER public="1" get="inline" set="null" expr="0x1009" line="642" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</BUFFER>
		<GAIN public="1" get="inline" set="null" expr="0x100A" line="644" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100A</e></m></meta>
		</GAIN>
		<MIN_GAIN public="1" get="inline" set="null" expr="0x100D" line="645" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100D</e></m></meta>
		</MIN_GAIN>
		<MAX_GAIN public="1" get="inline" set="null" expr="0x100E" line="646" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100E</e></m></meta>
		</MAX_GAIN>
		<ORIENTATION public="1" get="inline" set="null" expr="0x100F" line="647" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100F</e></m></meta>
		</ORIENTATION>
		<SOURCE_STATE public="1" get="inline" set="null" expr="0x1010" line="648" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</SOURCE_STATE>
		<INITIAL public="1" get="inline" set="null" expr="0x1011" line="651" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</INITIAL>
		<PLAYING public="1" get="inline" set="null" expr="0x1012" line="652" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</PLAYING>
		<PAUSED public="1" get="inline" set="null" expr="0x1013" line="653" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</PAUSED>
		<STOPPED public="1" get="inline" set="null" expr="0x1014" line="654" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1014</e></m></meta>
		</STOPPED>
		<BUFFERS_QUEUED public="1" get="inline" set="null" expr="0x1015" line="656" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1015</e></m></meta>
		</BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" get="inline" set="null" expr="0x1016" line="657" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1016</e></m></meta>
		</BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" get="inline" set="null" expr="0x1020" line="659" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1020</e></m></meta>
		</REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" get="inline" set="null" expr="0x1021" line="660" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1021</e></m></meta>
		</ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" get="inline" set="null" expr="0x1022" line="661" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1022</e></m></meta>
		</CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" get="inline" set="null" expr="0x1023" line="662" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1023</e></m></meta>
		</MAX_DISTANCE>
		<SEC_OFFSET public="1" get="inline" set="null" expr="0x1024" line="664" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1024</e></m></meta>
		</SEC_OFFSET>
		<SAMPLE_OFFSET public="1" get="inline" set="null" expr="0x1025" line="665" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1025</e></m></meta>
		</SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" get="inline" set="null" expr="0x1026" line="666" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1026</e></m></meta>
		</BYTE_OFFSET>
		<SOURCE_TYPE public="1" get="inline" set="null" expr="0x1027" line="667" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1027</e></m></meta>
		</SOURCE_TYPE>
		<STATIC public="1" get="inline" set="null" expr="0x1028" line="670" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1028</e></m></meta>
		</STATIC>
		<STREAMING public="1" get="inline" set="null" expr="0x1029" line="671" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1029</e></m></meta>
		</STREAMING>
		<UNDETERMINED public="1" get="inline" set="null" expr="0x1030" line="672" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1030</e></m></meta>
		</UNDETERMINED>
		<FORMAT_MONO8 public="1" get="inline" set="null" expr="0x1100" line="675" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</FORMAT_MONO8>
		<FORMAT_MONO16 public="1" get="inline" set="null" expr="0x1101" line="676" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" get="inline" set="null" expr="0x1102" line="677" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" get="inline" set="null" expr="0x1103" line="678" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1103</e></m></meta>
		</FORMAT_STEREO16>
		<FREQUENCY public="1" get="inline" set="null" expr="0x2001" line="681" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2001</e></m></meta>
		</FREQUENCY>
		<BITS public="1" get="inline" set="null" expr="0x2002" line="682" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2002</e></m></meta>
		</BITS>
		<CHANNELS public="1" get="inline" set="null" expr="0x2003" line="683" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2003</e></m></meta>
		</CHANNELS>
		<SIZE public="1" get="inline" set="null" expr="0x2004" line="684" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2004</e></m></meta>
		</SIZE>
		<UNUSED public="1" get="inline" set="null" expr="0x2010" line="687" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2010</e></m></meta>
		</UNUSED>
		<PENDING public="1" get="inline" set="null" expr="0x2011" line="688" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2011</e></m></meta>
		</PENDING>
		<PROCESSED public="1" get="inline" set="null" expr="0x2012" line="689" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2012</e></m></meta>
		</PROCESSED>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="692" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_NAME public="1" get="inline" set="null" expr="0xA001" line="693" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_NAME>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA002" line="694" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA003" line="695" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="0xA004" line="696" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="697" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<VENDOR public="1" get="inline" set="null" expr="0xB001" line="700" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB001</e></m></meta>
		</VENDOR>
		<VERSION public="1" get="inline" set="null" expr="0xB002" line="701" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB002</e></m></meta>
		</VERSION>
		<RENDERER public="1" get="inline" set="null" expr="0xB003" line="702" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB003</e></m></meta>
		</RENDERER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0xB004" line="703" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB004</e></m></meta>
		</EXTENSIONS>
		<DOPPLER_FACTOR public="1" get="inline" set="null" expr="0xC000" line="706" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC000</e></m></meta>
		</DOPPLER_FACTOR>
		<DOPPLER_VELOCITY public="1" get="inline" set="null" expr="0xC001" line="707" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC001</e></m></meta>
		</DOPPLER_VELOCITY>
		<SPEED_OF_SOUND public="1" get="inline" set="null" expr="0xC003" line="708" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC003</e></m></meta>
		</SPEED_OF_SOUND>
		<DISTANCE_MODEL public="1" get="inline" set="null" expr="0xD000" line="709" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD000</e></m></meta>
		</DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" get="inline" set="null" expr="0xD001" line="712" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD001</e></m></meta>
		</INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD002" line="713" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD002</e></m></meta>
		</INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" get="inline" set="null" expr="0xD003" line="714" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD003</e></m></meta>
		</LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD004" line="715" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD004</e></m></meta>
		</LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" get="inline" set="null" expr="0xD005" line="716" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD005</e></m></meta>
		</EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD006" line="717" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD006</e></m></meta>
		</EXPONENT_DISTANCE_CLAMPED>
		<haxe_doc>On platforms that don't have native support for OpenAL, the Driver uses this
	emulator that only requires a NativeChannel implementation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Device" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<new public="1" set="method" line="725"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Context" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<device public="1"><c path="hxd.snd.openal.Device"/></device>
		<new public="1" set="method" line="731"><f a="d">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.ALC" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ctx expr="null" line="738" static="1">
			<c path="hxd.snd.openal.Context"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</ctx>
		<getError public="1" set="method" line="740" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
</f></getError>
		<createContext public="1" set="method" line="745" static="1"><f a="device:attrlist">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Context"/>
</f></createContext>
		<makeContextCurrent public="1" set="method" line="749" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<processContext public="1" set="method" line="754" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="757" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></suspendContext>
		<destroyContext public="1" set="method" line="760" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></destroyContext>
		<getCurrentContext public="1" set="method" line="763" static="1"><f a=""><c path="hxd.snd.openal.Context"/></f></getCurrentContext>
		<getContextsDevice public="1" set="method" line="767" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<c path="hxd.snd.openal.Device"/>
</f></getContextsDevice>
		<openDevice public="1" set="method" line="772" static="1"><f a="devicename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Device"/>
</f></openDevice>
		<closeDevice public="1" set="method" line="776" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Bool"/>
</f></closeDevice>
		<loadExtensions public="1" set="method" line="781" static="1"><f a="alDevice">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="783" static="1"><f a="device:extname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="786" static="1"><f a="device:enumname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<getString public="1" set="method" line="792" static="1"><f a="device:param">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getIntegerv public="1" set="method" line="795" static="1"><f a="device:param:size:values">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<FALSE public="1" get="inline" set="null" expr="0" line="813" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="814" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<FREQUENCY public="1" get="inline" set="null" expr="0x1007" line="817" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</FREQUENCY>
		<REFRESH public="1" get="inline" set="null" expr="0x1008" line="818" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1008</e></m></meta>
		</REFRESH>
		<SYNC public="1" get="inline" set="null" expr="0x1009" line="819" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</SYNC>
		<MONO_SOURCES public="1" get="inline" set="null" expr="0x1010" line="820" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</MONO_SOURCES>
		<STEREO_SOURCES public="1" get="inline" set="null" expr="0x1011" line="821" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</STEREO_SOURCES>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="824" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_DEVICE public="1" get="inline" set="null" expr="0xA001" line="825" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_DEVICE>
		<INVALID_CONTEXT public="1" get="inline" set="null" expr="0xA002" line="826" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_CONTEXT>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA003" line="827" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA004" line="828" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_VALUE>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="829" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<MAJOR_VERSION public="1" get="inline" set="null" expr="0x1000" line="832" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</MAJOR_VERSION>
		<MINOR_VERSION public="1" get="inline" set="null" expr="0x1001" line="833" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</MINOR_VERSION>
		<ATTRIBUTES_SIZE public="1" get="inline" set="null" expr="0x1002" line="836" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" get="inline" set="null" expr="0x1003" line="837" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1004" line="840" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1005" line="841" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DEVICE_SPECIFIER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0x1006" line="842" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</EXTENSIONS>
		<EXT_CAPTURE public="1" get="inline" set="null" expr="1" line="845" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EXT_CAPTURE>
		<CAPTURE_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x310" line="846" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x310</e></m></meta>
		</CAPTURE_DEVICE_SPECIFIER>
		<CAPTURE_DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x311" line="847" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x311</e></m></meta>
		</CAPTURE_DEFAULT_DEVICE_SPECIFIER>
		<CAPTURE_SAMPLES public="1" get="inline" set="null" expr="0x312" line="848" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x312</e></m></meta>
		</CAPTURE_SAMPLES>
		<ENUMERATE_ALL_EXT public="1" get="inline" set="null" expr="1" line="851" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1012" line="852" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1013" line="853" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</ALL_DEVICES_SPECIFIER>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.EFX" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<EFX_MAJOR_VERSION public="1" get="inline" set="null" expr="0x20001" line="860" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20001</e></m></meta>
		</EFX_MAJOR_VERSION>
		<EFX_MINOR_VERSION public="1" get="inline" set="null" expr="0x20002" line="861" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20002</e></m></meta>
		</EFX_MINOR_VERSION>
		<MAX_AUXILIARY_SENDS public="1" get="inline" set="null" expr="0x20003" line="862" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20003</e></m></meta>
		</MAX_AUXILIARY_SENDS>
		<METERS_PER_UNIT public="1" get="inline" set="null" expr="0x20004" line="865" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20004</e></m></meta>
		</METERS_PER_UNIT>
		<DIRECT_FILTER public="1" get="inline" set="null" expr="0x20005" line="868" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20005</e></m></meta>
		</DIRECT_FILTER>
		<FILTER_NULL public="1" get="inline" set="null" expr="0x0000" line="869" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</FILTER_NULL>
	</class>
	<enum path="hxsl.Type" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TVoid/>
		<TInt/>
		<TBool/>
		<TFloat/>
		<TString/>
		<TVec a="size:t">
			<x path="Int"/>
			<e path="hxsl.VecType"/>
		</TVec>
		<TMat3/>
		<TMat4/>
		<TMat3x4/>
		<TBytes a="size"><x path="Int"/></TBytes>
		<TSampler2D/>
		<TSampler2DArray/>
		<TSamplerCube/>
		<TStruct a="vl"><c path="Array"><t path="hxsl.TVar"/></c></TStruct>
		<TFun a="variants"><c path="Array"><t path="hxsl.FunType"/></c></TFun>
		<TArray a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TArray>
		<TBuffer a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TBuffer>
		<TChannel a="size"><x path="Int"/></TChannel>
		<TMat2/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.VecType" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<VInt/>
		<VFloat/>
		<VBool/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.SizeDecl" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<SConst a="v"><x path="Int"/></SConst>
		<SVar a="v"><t path="hxsl.TVar"/></SVar>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.FunType" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<args><c path="Array"><a>
	<type><e path="hxsl.Type"/></type>
	<name><c path="String"/></name>
</a></c></args>
</a></typedef>
	<class path="hxsl.Error" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<t public="1" set="method" line="52" static="1"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></t>
		<msg public="1"><c path="String"/></msg>
		<pos public="1"><t path="hxsl.Position"/></pos>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Position" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><t path="haxe.macro.Position"/></typedef>
	<typedef path="hxsl.Expr" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<pos><t path="hxsl.Position"/></pos>
	<expr><e path="hxsl.ExprDef"/></expr>
</a></typedef>
	<typedef path="hxsl.Binop" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Binop"/></typedef>
	<typedef path="hxsl.Unop" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Unop"/></typedef>
	<enum path="hxsl.VarKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Global/>
		<Input/>
		<Param/>
		<Var/>
		<Local/>
		<Output/>
		<Function/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.VarQualifier" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Const a="?max"><x path="Int"/></Const>
		<Private/>
		<Nullable/>
		<PerObject/>
		<Name a="n"><c path="String"/></Name>
		<Shared/>
		<Precision a="p"><e path="hxsl.Prec"/></Precision>
		<Range a="min:max">
			<x path="Float"/>
			<x path="Float"/>
		</Range>
		<Ignore/>
		<PerInstance a="v"><x path="Int"/></PerInstance>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.Prec" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Low/>
		<Medium/>
		<High/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="hxsl.VarDecl" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><x path="Null"><e path="hxsl.Type"/></x></type>
	<qualifiers><c path="Array"><e path="hxsl.VarQualifier"/></c></qualifiers>
	<name><c path="String"/></name>
	<kind><x path="Null"><e path="hxsl.VarKind"/></x></kind>
	<expr><x path="Null"><t path="hxsl.Expr"/></x></expr>
</a></typedef>
	<typedef path="hxsl.FunDecl" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><x path="Null"><e path="hxsl.Type"/></x></ret>
	<name><c path="String"/></name>
	<expr><t path="hxsl.Expr"/></expr>
	<args><c path="Array"><t path="hxsl.VarDecl"/></c></args>
</a></typedef>
	<enum path="hxsl.Const" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<CNull/>
		<CBool a="b"><x path="Bool"/></CBool>
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="v"><x path="Float"/></CFloat>
		<CString a="v"><c path="String"/></CString>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.ExprDef" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<EConst a="c"><e path="hxsl.Const"/></EConst>
		<EIdent a="i"><c path="String"/></EIdent>
		<EParenthesis a="e"><t path="hxsl.Expr"/></EParenthesis>
		<EField a="e:f">
			<t path="hxsl.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EBinop>
		<EUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.Expr"/>
		</EUnop>
		<ECall a="e:args">
			<t path="hxsl.Expr"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
		</ECall>
		<EBlock a="el"><c path="Array"><t path="hxsl.Expr"/></c></EBlock>
		<EVars a="v"><c path="Array"><t path="hxsl.VarDecl"/></c></EVars>
		<EFunction a="f"><t path="hxsl.FunDecl"/></EFunction>
		<EIf a="econd:eif:eelse">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</EIf>
		<EDiscard/>
		<EFor a="v:loop:block">
			<c path="String"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EFor>
		<EReturn a="?e"><x path="Null"><t path="hxsl.Expr"/></x></EReturn>
		<EBreak/>
		<EContinue/>
		<EArray a="e:eindex">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EArray>
		<EArrayDecl a="el"><c path="Array"><t path="hxsl.Expr"/></c></EArrayDecl>
		<ESwitch a="e:cases:def">
			<t path="hxsl.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.Expr"/></c></values>
	<expr><t path="hxsl.Expr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</ESwitch>
		<EWhile a="cond:loop:normalWhile">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
			<t path="hxsl.Expr"/>
		</EMeta>
	</enum>
	<typedef path="hxsl.TVar" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><e path="hxsl.Type"/></type>
	<qualifiers>
		<x path="Null"><c path="Array"><e path="hxsl.VarQualifier"/></c></x>
		<meta><m n=":optional"/></meta>
	</qualifiers>
	<parent>
		<x path="Null"><t path="hxsl.TVar"/></x>
		<meta><m n=":optional"/></meta>
	</parent>
	<name><c path="String"/></name>
	<kind><e path="hxsl.VarKind"/></kind>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="hxsl.TFunction" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<ref><t path="hxsl.TVar"/></ref>
	<kind><e path="hxsl.FunctionKind"/></kind>
	<expr><t path="hxsl.TExpr"/></expr>
	<args><c path="Array"><t path="hxsl.TVar"/></c></args>
</a></typedef>
	<enum path="hxsl.FunctionKind" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Vertex/>
		<Fragment/>
		<Init/>
		<Helper/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TGlobal" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Radians/>
		<Degrees/>
		<Sin/>
		<Cos/>
		<Tan/>
		<Asin/>
		<Acos/>
		<Atan/>
		<Pow/>
		<Exp/>
		<Log/>
		<Exp2/>
		<Log2/>
		<Sqrt/>
		<Inversesqrt/>
		<Abs/>
		<Sign/>
		<Floor/>
		<Ceil/>
		<Fract/>
		<Mod/>
		<Min/>
		<Max/>
		<Clamp/>
		<Mix/>
		<Step/>
		<Smoothstep/>
		<Length/>
		<Distance/>
		<Dot/>
		<Cross/>
		<Normalize/>
		<LReflect/>
		<Texture/>
		<TextureLod/>
		<Texel/>
		<TexelLod/>
		<ToInt/>
		<ToFloat/>
		<ToBool/>
		<Vec2/>
		<Vec3/>
		<Vec4/>
		<IVec2/>
		<IVec3/>
		<IVec4/>
		<BVec2/>
		<BVec3/>
		<BVec4/>
		<Mat2/>
		<Mat3/>
		<Mat4/>
		<Mat3x4/>
		<Saturate/>
		<Pack/>
		<Unpack/>
		<PackNormal/>
		<UnpackNormal/>
		<ScreenToUv/>
		<UvToScreen/>
		<DFdx/>
		<DFdy/>
		<Fwidth/>
		<ChannelRead/>
		<ChannelReadLod/>
		<ChannelFetch/>
		<ChannelFetchLod/>
		<Trace/>
		<VertexID/>
		<InstanceID/>
		<FragCoord/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.Component" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<X/>
		<Y/>
		<Z/>
		<W/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TExprDef" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TConst a="c"><e path="hxsl.Const"/></TConst>
		<TVar a="v"><t path="hxsl.TVar"/></TVar>
		<TGlobal a="g"><e path="hxsl.TGlobal"/></TGlobal>
		<TParenthesis a="e"><t path="hxsl.TExpr"/></TParenthesis>
		<TBlock a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TBlock>
		<TBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TBinop>
		<TUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.TExpr"/>
		</TUnop>
		<TVarDecl a="v:?init">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
		</TVarDecl>
		<TCall a="e:args">
			<t path="hxsl.TExpr"/>
			<c path="Array"><t path="hxsl.TExpr"/></c>
		</TCall>
		<TSwiz a="e:regs">
			<t path="hxsl.TExpr"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</TSwiz>
		<TIf a="econd:eif:eelse">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TIf>
		<TDiscard/>
		<TReturn a="?e"><t path="hxsl.TExpr"/></TReturn>
		<TFor a="v:it:loop">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TFor>
		<TContinue/>
		<TBreak/>
		<TArray a="e:index">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TArray>
		<TArrayDecl a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TArrayDecl>
		<TSwitch a="e:cases:def">
			<t path="hxsl.TExpr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.TExpr"/></c></values>
	<expr><t path="hxsl.TExpr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TSwitch>
		<TWhile a="e:loop:normalWhile">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Bool"/>
		</TWhile>
		<TMeta a="m:args:e">
			<c path="String"/>
			<c path="Array"><e path="hxsl.Const"/></c>
			<t path="hxsl.TExpr"/>
		</TMeta>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.TExpr" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<t><e path="hxsl.Type"/></t>
	<p><t path="hxsl.Position"/></p>
	<e><e path="hxsl.TExprDef"/></e>
</a></typedef>
	<typedef path="hxsl.ShaderData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<vars><c path="Array"><t path="hxsl.TVar"/></c></vars>
	<name><c path="String"/></name>
	<funs><c path="Array"><t path="hxsl.TFunction"/></c></funs>
</a></typedef>
	<class path="hxsl.Tools" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<UID expr="0" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<SWIZ public="1" expr="Component.createAll()" line="294" static="1">
			<c path="Array"><e path="hxsl.Component"/></c>
			<meta><m n=":value"><e>Component.createAll()</e></m></meta>
		</SWIZ>
		<MAX_CHANNELS_BITS public="1" expr="3" line="295" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MAX_CHANNELS_BITS>
		<allocVarId public="1" set="method" line="297" static="1"><f a=""><x path="Int"/></f></allocVarId>
		<getName public="1" set="method" line="307" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getName>
		<getConstBits public="1" set="method" line="318" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
</f></getConstBits>
		<isConst public="1" set="method" line="342" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isConst>
		<isStruct public="1" set="method" line="354" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isStruct>
		<isArray public="1" set="method" line="358" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isArray>
		<hasQualifier public="1" set="method" line="362" static="1"><f a="v:q">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VarQualifier"/>
	<x path="Bool"/>
</f></hasQualifier>
		<isSampler public="1" set="method" line="370" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Bool"/>
</f></isSampler>
		<toString public="1" set="method" line="379" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<c path="String"/>
</f></toString>
		<toType public="1" set="method" line="396" static="1"><f a="t">
	<e path="hxsl.VecType"/>
	<e path="hxsl.Type"/>
</f></toType>
		<hasSideEffect public="1" set="method" line="404" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasSideEffect>
		<iter public="1" set="method" line="451" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="480" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TExpr"/>
</f></map>
		<size public="1" set="method" line="502" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></size>
		<evalConst public="1" set="method" line="523" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<d/>
</f></evalConst>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools2" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<toString public="1" set="method" line="548" static="1"><f a="g">
	<e path="hxsl.TGlobal"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools3" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="557" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.Tools4" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="565" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.BatchShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/BatchShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<Batch_Count public="1" get="accessor" set="accessor"><x path="Int"/></Batch_Count>
		<Batch_Count__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</Batch_Count__>
		<get_Batch_Count get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Batch_Count>
		<set_Batch_Count get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Batch_Count>
		<Batch_Buffer public="1" get="accessor" set="accessor"><t path="hxsl.Buffer"/></Batch_Buffer>
		<Batch_Buffer__>
			<t path="hxsl.Buffer"/>
			<meta><m n=":noCompletion"/></meta>
		</Batch_Buffer__>
		<get_Batch_Buffer get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Buffer"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Batch_Buffer>
		<set_Batch_Buffer get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Buffer"/>
				<t path="hxsl.Buffer"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Batch_Buffer>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const(65536) var Batch_Count:Int;
	@param var Batch_Buffer:Buffer<Vec4,Batch_Count>;
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="hxsl.SearchMap" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Cache.hx" module="hxsl.Cache">
		<linked public="1"><c path="hxsl.RuntimeShader"/></linked>
		<next public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl.SearchMap"/>
</t></next>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Cache" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Cache.hx">
		<INST static="1"><c path="hxsl.Cache"/></INST>
		<get public="1" set="method" line="565" static="1"><f a=""><c path="hxsl.Cache"/></f></get>
		<set public="1" set="method" line="572" static="1"><f a="c">
	<c path="hxsl.Cache"/>
	<x path="Void"/>
</f></set>
		<clear public="1" set="method" line="576" static="1"><f a=""><x path="Void"/></f></clear>
		<linkCache><c path="hxsl.SearchMap"/></linkCache>
		<linkShaders><t path="Map">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</t></linkShaders>
		<batchShaders><t path="Map">
	<x path="Int"/>
	<c path="hxsl.SharedShader"/>
</t></batchShaders>
		<byID><t path="Map">
	<c path="String"/>
	<c path="hxsl.RuntimeShader"/>
</t></byID>
		<constsToGlobal public="1"><x path="Bool"/></constsToGlobal>
		<getLinkShader public="1" set="method" line="36">
			<f a="vars">
				<c path="Array"><e path="hxsl.Output"/></c>
				<x path="Null"><c path="hxsl.Shader"/></x>
			</f>
			<haxe_doc>Creates a shader that generate the output requested.</haxe_doc>
		</getLinkShader>
		<link public="1" set="method" line="154">
			<f a="shaders:batchMode">
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<c path="hxsl.RuntimeShader"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</link>
		<compileRuntimeShader set="method" line="171"><f a="shaders:batchMode">
	<c path="hxsl.ShaderList"/>
	<x path="Bool"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileRuntimeShader>
		<buildRuntimeShader set="method" line="324"><f a="vertex:fragment:paramVars">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShader"/>
</f></buildRuntimeShader>
		<initGlobals set="method" line="340"><f a="r:s">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></initGlobals>
		<getPath set="method" line="354"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getPath>
		<flattenShader set="method" line="360"><f a="s:kind:params">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShaderData"/>
</f></flattenShader>
		<makeBatchShader public="1" set="method" line="431"><f a="rt">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.BatchShader"/>
</f></makeBatchShader>
		<createBatchShader set="method" line="442"><f a="rt">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.SharedShader"/>
</f></createBatchShader>
		<new set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Channel" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Channel.hx">
		<Unknown/>
		<R/>
		<G/>
		<B/>
		<A/>
		<PackedFloat/>
		<PackedNormal/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="hxsl.ChannelTexture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/ChannelTexture.hx"><a>
	<texture><t path="hxsl.ChannelTextureType"/></texture>
	<channel><e path="hxsl.Channel"/></channel>
</a></typedef>
	<class path="hxsl.Clone" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Clone.hx">
		<shaderData public="1" set="method" line="75" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shaderData>
		<varMap public="1"><t path="Map">
	<x path="Int"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<tvar public="1" set="method" line="12"><f a="v">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</f></tvar>
		<tfun public="1" set="method" line="28"><f a="f">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TFunction"/>
</f></tfun>
		<ttype public="1" set="method" line="38"><f a="t">
	<e path="hxsl.Type"/>
	<e path="hxsl.Type"/>
</f></ttype>
		<texpr public="1" set="method" line="51"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></texpr>
		<shader public="1" set="method" line="67"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shader>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Dce.Exit" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce"><new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new></class>
	<class path="hxsl._Dce.VarDeps" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce">
		<v public="1"><t path="hxsl.TVar"/></v>
		<keep public="1"><x path="Bool"/></keep>
		<used public="1"><x path="Bool"/></used>
		<deps public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></deps>
		<new public="1" set="method" line="14"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Dce" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Dce.hx">
		<used><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></used>
		<channelVars><c path="Array"><t path="hxsl.TVar"/></c></channelVars>
		<markAsKeep><x path="Bool"/></markAsKeep>
		<debug get="inline" set="null" line="30"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<dce public="1" set="method" line="37"><f a="vertex:fragment">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></dce>
		<get set="method" line="107"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Dce.VarDeps"/></x>
</f></get>
		<markRec set="method" line="116"><f a="v">
	<c path="hxsl._Dce.VarDeps"/>
	<x path="Void"/>
</f></markRec>
		<link set="method" line="124"><f a="v:writeTo">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></link>
		<check set="method" line="141"><f a="e:writeTo:isAffected">
	<t path="hxsl.TExpr"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></check>
		<checkBranches set="method" line="203"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkBranches>
		<mapExpr set="method" line="214"><f a="e:isVar">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Eval" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Eval.hx">
		<varMap public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<inlineCalls public="1"><x path="Bool"/></inlineCalls>
		<unrollLoops public="1"><x path="Bool"/></unrollLoops>
		<eliminateConditionals public="1"><x path="Bool"/></eliminateConditionals>
		<constants><t path="Map">
	<x path="Int"/>
	<e path="hxsl.TExprDef"/>
</t></constants>
		<funMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TFunction"/>
</t></funMap>
		<curFun><t path="hxsl.TFunction"/></curFun>
		<setConstant public="1" set="method" line="25"><f a="v:c">
	<t path="hxsl.TVar"/>
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></setConstant>
		<mapVar set="method" line="29"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><a>
	<type><e path="hxsl.Type"/></type>
	<qualifiers>
		<x path="Null"><c path="Array"><e path="hxsl.VarQualifier"/></c></x>
		<meta><m n=":optional"/></meta>
	</qualifiers>
	<parent>
		<x path="Null"><t path="hxsl.TVar"/></x>
		<meta><m n=":optional"/></meta>
	</parent>
	<name><c path="String"/></name>
	<kind><e path="hxsl.VarKind"/></kind>
	<id><x path="Int"/></id>
</a></x>
</f></mapVar>
		<eval public="1" set="method" line="73"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></eval>
		<markReturn><x path="Bool"/></markReturn>
		<hasReturn set="method" line="100"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasReturn>
		<hasReturnLoop set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></hasReturnLoop>
		<handleReturn set="method" line="115">
			<f a="e:?isFinal" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isFinal : false }</e></m></meta>
		</handleReturn>
		<handleReturnDef set="method" line="155"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></handleReturnDef>
		<evalCall set="method" line="159"><f a="g:args:oldArgs:pos">
	<e path="hxsl.TGlobal"/>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<t path="hxsl.Position"/>
	<e path="hxsl.TExprDef"/>
</f></evalCall>
		<constantsToString set="method" line="212"><f a=""><c path="String"/></f></constantsToString>
		<ifBlock set="method" line="216"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></ifBlock>
		<evalExpr set="method" line="222">
			<f a="e:?isVal" v=":true">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isVal : true }</e></m></meta>
		</evalExpr>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Evaluator : will substitute some variables (usually constants) by their runtime value and will
	evaluate and reduce the expression, unroll loops, etc.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Flatten.Alloc" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Flatten.hx" private="1" module="hxsl.Flatten">
		<t public="1"><e path="hxsl.VecType"/></t>
		<pos public="1"><x path="Int"/></pos>
		<size public="1"><x path="Int"/></size>
		<g public="1"><t path="hxsl.TVar"/></g>
		<v public="1"><x path="Null"><t path="hxsl.TVar"/></x></v>
		<new public="1" set="method" line="10"><f a="g:t:pos:size">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.ARead" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Flatten.hx" module="hxsl.Flatten">
		<AIndex a="a"><c path="hxsl._Flatten.Alloc"/></AIndex>
		<AOffset a="a:stride:delta">
			<c path="hxsl._Flatten.Alloc"/>
			<x path="Int"/>
			<t path="hxsl.TExpr"/>
		</AOffset>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Flatten" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Flatten.hx">
		<globals><c path="Array"><t path="hxsl.TVar"/></c></globals>
		<params><c path="Array"><t path="hxsl.TVar"/></c></params>
		<outVars><c path="Array"><t path="hxsl.TVar"/></c></outVars>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="hxsl._Flatten.Alloc"/>
</t></varMap>
		<econsts><t path="hxsl.TExpr"/></econsts>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<allocData public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</t></allocData>
		<flatten public="1" set="method" line="36"><f a="s:kind:constsToGlobal">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<x path="Bool"/>
	<t path="hxsl.ShaderData"/>
</f></flatten>
		<mapFun set="method" line="96"><f a="f:mapExpr">
	<t path="hxsl.TFunction"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TFunction"/>
</f></mapFun>
		<mapExpr set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<mapConsts set="method" line="137"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapConsts>
		<allocConst set="method" line="200"><f a="v:p">
	<x path="Float"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConst>
		<allocConsts set="method" line="209"><f a="va:p">
	<c path="Array"><x path="Float"/></c>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConsts>
		<mkInt get="inline" set="null" line="250"><f a="v:pos">
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mkInt>
		<readIndex get="inline" set="null" line="254"><f a="a:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readIndex>
		<readOffset get="inline" set="null" line="258"><f a="a:stride:delta:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readOffset>
		<access set="method" line="264"><f a="a:t:pos:acc">
	<c path="hxsl._Flatten.Alloc"/>
	<e path="hxsl.Type"/>
	<t path="hxsl.Position"/>
	<e path="hxsl.ARead"/>
	<t path="hxsl.TExpr"/>
</f></access>
		<optimize set="method" line="323"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></optimize>
		<packTextures set="method" line="348"><f a="name:vars:t">
	<c path="String"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.Type"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</f></packTextures>
		<packBuffers set="method" line="377"><f a="vars">
	<c path="Array"><t path="hxsl.TVar"/></c>
	<x path="Void"/>
</f></packBuffers>
		<pack set="method" line="396"><f a="name:kind:vars:t">
	<c path="String"/>
	<e path="hxsl.VarKind"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.VecType"/>
	<t path="hxsl.TVar"/>
</f></pack>
		<varSize set="method" line="444"><f a="v:t">
	<e path="hxsl.Type"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
</f></varSize>
		<gatherVar set="method" line="456"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></gatherVar>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxsl.GlobalSlot" params="T" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Globals.hx" module="hxsl.Globals">
		<this><x path="Int"/></this>
		<impl><class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="name">
			<c path="String"/>
			<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="8" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<set public="1" get="inline" set="null" line="11" static="1">
		<f a="this:globals:v">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="14" static="1">
		<f a="this:globals">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
</class></impl>
	</abstract>
	<class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="name">
				<c path="String"/>
				<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="8" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<set public="1" get="inline" set="null" line="11" static="1">
			<f a="this:globals:v">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="14" static="1">
			<f a="this:globals">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
	</class>
	<class path="hxsl.Globals" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Globals.hx">
		<ALL static="1"><c path="Array"><c path="String"/></c></ALL>
		<MAP static="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></MAP>
		<allocID public="1" set="method" line="62" static="1"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></allocID>
		<getIDName public="1" set="method" line="79" static="1"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></getIDName>
		<map><t path="Map">
	<x path="Int"/>
	<d/>
</t></map>
		<channels expr="[]">
			<c path="Array"><c path="h3d.mat.Texture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</channels>
		<maxChannels><x path="Int"/></maxChannels>
		<set public="1" set="method" line="29"><f a="path:v">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="33"><f a="path">
	<c path="String"/>
	<d/>
</f></get>
		<fastSet public="1" get="inline" set="null" line="37"><f a="id:v">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></fastSet>
		<fastGet public="1" get="inline" set="null" line="41"><f a="id">
	<x path="Int"/>
	<d/>
</f></fastGet>
		<resetChannels public="1" get="inline" set="null" line="45"><f a=""><x path="Void"/></f></resetChannels>
		<allocChannelID public="1" set="method" line="49"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></allocChannelID>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.AllocatedVar" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<id public="1"><x path="Int"/></id>
		<v public="1"><t path="hxsl.TVar"/></v>
		<path public="1"><c path="String"/></path>
		<merged public="1"><c path="Array"><t path="hxsl.TVar"/></c></merged>
		<kind public="1"><x path="Null"><e path="hxsl.FunctionKind"/></x></kind>
		<parent public="1"><c path="hxsl._Linker.AllocatedVar"/></parent>
		<instanceIndex public="1"><x path="Int"/></instanceIndex>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.ShaderInfos" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<UID expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<uid public="1"><x path="Int"/></uid>
		<name public="1"><c path="String"/></name>
		<priority public="1"><x path="Int"/></priority>
		<body public="1"><t path="hxsl.TExpr"/></body>
		<usedFunctions public="1"><c path="Array"><t path="hxsl.TFunction"/></c></usedFunctions>
		<deps public="1"><t path="Map">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Bool"/>
</t></deps>
		<read public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></read>
		<write public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></write>
		<processed public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></processed>
		<vertex public="1"><x path="Null"><x path="Bool"/></x></vertex>
		<onStack public="1"><x path="Bool"/></onStack>
		<hasDiscard public="1"><x path="Bool"/></hasDiscard>
		<marked public="1"><x path="Null"><x path="Bool"/></x></marked>
		<new public="1" set="method" line="31"><f a="n:v">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Linker" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Linker.hx">
		<allVars public="1"><c path="Array"><c path="hxsl._Linker.AllocatedVar"/></c></allVars>
		<varMap><t path="Map">
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></varMap>
		<curShader><c path="hxsl._Linker.ShaderInfos"/></curShader>
		<shaders><c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c></shaders>
		<varIdMap><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></varIdMap>
		<locals><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></locals>
		<curInstance><x path="Int"/></curInstance>
		<batchMode><x path="Bool"/></batchMode>
		<isBatchShader><x path="Bool"/></isBatchShader>
		<debugDepth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</debugDepth>
		<debug get="inline" set="null" line="59"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<error set="method" line="67"><f a="msg:p">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></error>
		<mergeVar set="method" line="71"><f a="path:v:v2:p">
	<c path="String"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></mergeVar>
		<allocVar set="method" line="101"><f a="v:p:?path:?parent">
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</f></allocVar>
		<mapExprVar set="method" line="174"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mapExprVar>
		<addShader set="method" line="227"><f a="name:vertex:e:p">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<c path="hxsl._Linker.ShaderInfos"/>
</f></addShader>
		<sortByPriorityDesc set="method" line="238"><f a="s1:s2">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Int"/>
</f></sortByPriorityDesc>
		<buildDependency set="method" line="244"><f a="s:v:isWritten">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildDependency>
		<initDependencies set="method" line="272"><f a="s">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Void"/>
</f></initDependencies>
		<collect set="method" line="295"><f a="cur:out:vertex">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></collect>
		<uniqueLocals set="method" line="317"><f a="expr:locals">
	<t path="hxsl.TExpr"/>
	<t path="Map">
		<c path="String"/>
		<x path="Bool"/>
	</t>
	<x path="Void"/>
</f></uniqueLocals>
		<link public="1" set="method" line="336"><f a="shadersData">
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<t path="hxsl.ShaderData"/>
</f></link>
		<new public="1" set="method" line="55">
			<f a="?batchMode" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ batchMode : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Output" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Output.hx">
		<Const a="v"><x path="Float"/></Const>
		<Value a="v:?size">
			<c path="String"/>
			<x path="Int"/>
		</Value>
		<PackNormal a="v"><e path="hxsl.Output"/></PackNormal>
		<PackFloat a="v"><e path="hxsl.Output"/></PackFloat>
		<Vec2 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec2>
		<Vec3 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec3>
		<Vec4 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec4>
		<Swiz a="a:swiz">
			<e path="hxsl.Output"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</Swiz>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Printer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Printer.hx">
		<SWIZ expr="[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;]" line="129" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["x", "y", "z", "w"]</e></m></meta>
		</SWIZ>
		<opStr public="1" set="method" line="300" static="1"><f a="op">
	<t path="hxsl.Binop"/>
	<c path="String"/>
</f></opStr>
		<toString public="1" set="method" line="331" static="1">
			<f a="e:?varId" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</toString>
		<shaderToString public="1" set="method" line="335" static="1">
			<f a="s:?varId" v=":false">
				<t path="hxsl.ShaderData"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</shaderToString>
		<check public="1" set="method" line="339" static="1"><f a="s:?from">
	<t path="hxsl.ShaderData"/>
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<x path="Void"/>
</f></check>
		<buffer><c path="StringBuf"/></buffer>
		<varId><x path="Bool"/></varId>
		<add get="inline" set="null" line="13"><f a="v">
	<d/>
	<x path="Void"/>
</f></add>
		<shaderString public="1" set="method" line="17"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></shaderString>
		<varString public="1" set="method" line="32"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></varString>
		<funString public="1" set="method" line="38"><f a="f">
	<t path="hxsl.TFunction"/>
	<c path="String"/>
</f></funString>
		<exprString public="1" set="method" line="44"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></exprString>
		<addVar set="method" line="50">
			<f a="v:defKind:?tabs:?parent" v="::&quot;&quot;:">
				<t path="hxsl.TVar"/>
				<e path="hxsl.VarKind"/>
				<c path="String"/>
				<t path="hxsl.TVar"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tabs : "" }</e></m></meta>
		</addVar>
		<addFun set="method" line="103"><f a="f">
	<t path="hxsl.TFunction"/>
	<x path="Void"/>
</f></addFun>
		<addVarName set="method" line="119"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addVarName>
		<addConst set="method" line="131"><f a="c">
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></addConst>
		<addExpr set="method" line="141"><f a="e:tabs">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
	<x path="Void"/>
</f></addExpr>
		<new public="1" set="method" line="9">
			<f a="?varId" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocParam" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<name public="1"><c path="String"/></name>
		<pos public="1"><x path="Int"/></pos>
		<instance public="1"><x path="Int"/></instance>
		<index public="1"><x path="Int"/></index>
		<type public="1"><e path="hxsl.Type"/></type>
		<perObjectGlobal public="1"><c path="hxsl.AllocGlobal"/></perObjectGlobal>
		<next public="1"><c path="hxsl.AllocParam"/></next>
		<clone public="1" set="method" line="18">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocParam"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="11"><f a="name:pos:instance:index:type">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocGlobal" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<pos public="1"><x path="Int"/></pos>
		<gid public="1"><x path="Int"/></gid>
		<path public="1"><c path="String"/></path>
		<type public="1"><e path="hxsl.Type"/></type>
		<next public="1"><c path="hxsl.AllocGlobal"/></next>
		<clone public="1" set="method" line="38">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocGlobal"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="32"><f a="pos:path:type">
	<x path="Int"/>
	<c path="String"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShaderData" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<vertex public="1"><x path="Bool"/></vertex>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<code public="1"><c path="String"/></code>
		<params public="1"><c path="hxsl.AllocParam"/></params>
		<paramsSize public="1"><x path="Int"/></paramsSize>
		<globals public="1"><c path="hxsl.AllocGlobal"/></globals>
		<globalsSize public="1"><x path="Int"/></globalsSize>
		<textures public="1"><c path="hxsl.AllocParam"/></textures>
		<texturesCount public="1"><x path="Int"/></texturesCount>
		<buffers public="1"><c path="hxsl.AllocParam"/></buffers>
		<bufferCount public="1"><x path="Int"/></bufferCount>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<new public="1" set="method" line="59"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstanceDesc" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<shader public="1"><c path="hxsl.SharedShader"/></shader>
		<bits public="1"><x path="Int"/></bits>
		<index public="1"><x path="Int"/></index>
		<new public="1" set="method" line="67"><f a="shader:bits">
	<c path="hxsl.SharedShader"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/RuntimeShader.hx">
		<UID expr="0" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<id public="1"><x path="Int"/></id>
		<vertex public="1"><c path="hxsl.RuntimeShaderData"/></vertex>
		<fragment public="1"><c path="hxsl.RuntimeShaderData"/></fragment>
		<globals public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></globals>
		<signature public="1">
			<c path="String"/>
			<haxe_doc>Signature of the resulting HxSL code.
		Several shaders with the different specification might still get the same resulting signature.</haxe_doc>
		</signature>
		<batchMode public="1"><x path="Bool"/></batchMode>
		<spec public="1"><a>
	<signature><c path="String"/></signature>
	<instances><c path="Array"><c path="hxsl.ShaderInstanceDesc"/></c></instances>
</a></spec>
		<hasGlobal public="1" get="inline" set="null" line="93"><f a="gid">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasGlobal>
		<new public="1" set="method" line="89"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Serializer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Serializer.hx">
		<TVECS expr="new Map()" line="101" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<e path="hxsl.Type"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</TVECS>
		<BOPS expr="{
	var ops = Binop.createAll();
	ops.insert(OpAssignOp(null).getIndex(), null);
	ops;
}" line="305" static="1">
			<c path="Array"><e path="haxe.macro.Binop"/></c>
			<meta><m n=":value"><e>{
	var ops = Binop.createAll();
	ops.insert(OpAssignOp(null).getIndex(), null);
	ops;
}</e></m></meta>
		</BOPS>
		<UNOPS expr="Unop.createAll()" line="310" static="1">
			<c path="Array"><e path="haxe.macro.Unop"/></c>
			<meta><m n=":value"><e>Unop.createAll()</e></m></meta>
		</UNOPS>
		<TGLOBALS expr="hxsl.TGlobal.createAll()" line="311" static="1">
			<c path="Array"><e path="hxsl.TGlobal"/></c>
			<meta><m n=":value"><e>hxsl.TGlobal.createAll()</e></m></meta>
		</TGLOBALS>
		<TSWIZ expr="new Map()" line="312" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="Array"><e path="hxsl.Component"/></c>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</TSWIZ>
		<REGS expr="[X, Y, Z, W]" line="313" static="1">
			<c path="Array"><e path="hxsl.Component"/></c>
			<meta><m n=":value"><e>[X, Y, Z, W]</e></m></meta>
		</REGS>
		<VKINDS expr="VarKind.createAll()" line="365" static="1">
			<c path="Array"><e path="hxsl.VarKind"/></c>
			<meta><m n=":value"><e>VarKind.createAll()</e></m></meta>
		</VKINDS>
		<PRECS expr="Prec.createAll()" line="366" static="1">
			<c path="Array"><e path="hxsl.Prec"/></c>
			<meta><m n=":value"><e>Prec.createAll()</e></m></meta>
		</PRECS>
		<FKIND expr="FunctionKind.createAll()" line="408" static="1">
			<c path="Array"><e path="hxsl.FunctionKind"/></c>
			<meta><m n=":value"><e>FunctionKind.createAll()</e></m></meta>
		</FKIND>
		<SIGN expr="0x8B741D" line="420" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B741D</e></m></meta>
		</SIGN>
		<run public="1" set="method" line="449" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></run>
		<out><c path="haxe.io.BytesBuffer"/></out>
		<input><c path="haxe.io.BytesInput"/></input>
		<varMap><t path="Map">
	<x path="Int"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<idMap><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></idMap>
		<typeIdMap><t path="Map">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</t></typeIdMap>
		<types><c path="Array"><e path="hxsl.Type"/></c></types>
		<uid expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</uid>
		<tid expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</tid>
		<writeArr params="T" get="inline" set="null" line="18"><f a="arr:f">
	<c path="Array"><c path="writeArr.T"/></c>
	<f a="">
		<c path="writeArr.T"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></writeArr>
		<readArr params="T" get="inline" set="null" line="23"><f a="f">
	<f a=""><c path="readArr.T"/></f>
	<c path="Array"><c path="readArr.T"/></c>
</f></readArr>
		<readVarInt set="method" line="27"><f a=""><x path="Int"/></f></readVarInt>
		<writeVarInt set="method" line="36"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></writeVarInt>
		<writeID set="method" line="51"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></writeID>
		<readID get="inline" set="null" line="61"><f a=""><x path="Int"/></f></readID>
		<writeTID set="method" line="65"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Bool"/>
</f></writeTID>
		<writeType set="method" line="77"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></writeType>
		<readType set="method" line="103"><f a=""><e path="hxsl.Type"/></f></readType>
		<writeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<readString set="method" line="156"><f a=""><c path="String"/></f></readString>
		<writeVar set="method" line="162"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></writeVar>
		<writeFun set="method" line="192"><f a="f">
	<t path="hxsl.TFunction"/>
	<x path="Void"/>
</f></writeFun>
		<writeConst set="method" line="200"><f a="c">
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></writeConst>
		<writeExpr set="method" line="211"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></writeExpr>
		<readConst set="method" line="294"><f a=""><e path="hxsl.Const"/></f></readConst>
		<readExpr set="method" line="315"><f a=""><t path="hxsl.TExpr"/></f></readExpr>
		<readVar set="method" line="368"><f a=""><t path="hxsl.TVar"/></f></readVar>
		<readFun set="method" line="410"><f a=""><t path="hxsl.TFunction"/></f></readFun>
		<unserialize public="1" set="method" line="422"><f a="data">
	<c path="String"/>
	<t path="hxsl.ShaderData"/>
</f></unserialize>
		<serialize public="1" set="method" line="435"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></serialize>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderList" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/ShaderList.hx">
		<addSort public="1" set="method" line="20" static="1"><f a="s:shaders">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></addSort>
		<s public="1"><c path="hxsl.Shader"/></s>
		<next public="1"><c path="hxsl.ShaderList"/></next>
		<clone public="1" set="method" line="10"><f a=""><x path="Null"><c path="hxsl.ShaderList"/></x></f></clone>
		<iterator public="1" get="inline" set="null" line="13"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></iterator>
		<iterateTo public="1" get="inline" set="null" line="16"><f a="s">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl._ShaderList.ShaderIterator"/>
</f></iterateTo>
		<new public="1" set="method" line="6"><f a="s:?n">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._ShaderList.ShaderIterator" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/ShaderList.hx" private="1" module="hxsl.ShaderList">
		<l><c path="hxsl.ShaderList"/></l>
		<last><c path="hxsl.ShaderList"/></last>
		<hasNext public="1" get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="46"><f a=""><c path="hxsl.Shader"/></f></next>
		<new public="1" get="inline" set="null" line="39"><f a="l:last">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstance" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<id public="1"><x path="Int"/></id>
		<shader public="1"><t path="hxsl.ShaderData"/></shader>
		<params public="1"><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></params>
		<new public="1" set="method" line="8"><f a="shader">
	<t path="hxsl.ShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderGlobal" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<globalId public="1"><x path="Int"/></globalId>
		<new public="1" set="method" line="18"><f a="v:gid">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderConst" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<pos public="1"><x path="Int"/></pos>
		<bits public="1"><x path="Int"/></bits>
		<globalId public="1"><x path="Int"/></globalId>
		<next public="1"><c path="hxsl.ShaderConst"/></next>
		<new public="1" set="method" line="30"><f a="v:pos:bits">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.SharedShader" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/SharedShader.hx">
		<UNROLL_LOOPS public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</UNROLL_LOOPS>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<globals public="1"><c path="Array"><c path="hxsl.ShaderGlobal"/></c></globals>
		<consts public="1"><c path="hxsl.ShaderConst"/></consts>
		<instanceCache><t path="Map">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</t></instanceCache>
		<paramsCount><x path="Int"/></paramsCount>
		<initialize set="method" line="57"><f a=""><x path="Void"/></f></initialize>
		<getInstance public="1" get="inline" set="null" line="63"><f a="constBits">
	<x path="Int"/>
	<x path="Null"><c path="hxsl.ShaderInstance"/></x>
</f></getInstance>
		<makeInstance set="method" line="68"><f a="constBits">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</f></makeInstance>
		<addSelfParam set="method" line="95"><f a="i:v">
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addSelfParam>
		<addParam set="method" line="108"><f a="eval:i:v">
	<c path="hxsl.Eval"/>
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addParam>
		<browseVar set="method" line="121"><f a="v:?path">
	<t path="hxsl.TVar"/>
	<c path="String"/>
	<x path="Void"/>
</f></browseVar>
		<new public="1" set="method" line="47"><f a="src">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Splitter.VarProps" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Splitter.hx" private="1" module="hxsl.Splitter">
		<v public="1"><t path="hxsl.TVar"/></v>
		<read public="1"><x path="Int"/></read>
		<write public="1"><x path="Int"/></write>
		<local public="1"><x path="Bool"/></local>
		<requireInit public="1"><x path="Bool"/></requireInit>
		<new public="1" set="method" line="10"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Splitter" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Splitter.hx">
		<vars><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Splitter.VarProps"/>
</t></vars>
		<varNames><t path="Map">
	<c path="String"/>
	<t path="hxsl.TVar"/>
</t></varNames>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<split public="1" set="method" line="26"><f a="s">
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></split>
		<addExpr set="method" line="184"><f a="f:e">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></addExpr>
		<checkVar set="method" line="193"><f a="v:vertex:vvars:p">
	<c path="hxsl._Splitter.VarProps"/>
	<x path="Bool"/>
	<t path="Map">
		<x path="Int"/>
		<c path="hxsl._Splitter.VarProps"/>
	</t>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></checkVar>
		<mapVars set="method" line="206"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapVars>
		<get set="method" line="222"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Splitter.VarProps"/></x>
</f></get>
		<uniqueName set="method" line="248"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></uniqueName>
		<checkExpr set="method" line="265"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkExpr>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Vec" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Vector"/></typedef>
	<typedef path="hxsl.IVec" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Int"/></c></typedef>
	<typedef path="hxsl.BVec" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Bool"/></c></typedef>
	<typedef path="hxsl.Matrix" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Matrix"/></typedef>
	<typedef path="hxsl.Texture" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2D" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2DArray" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.TextureArray"/></typedef>
	<typedef path="hxsl.SamplerCube" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.ChannelTextureType" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Buffer" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Buffer"/></typedef>
	<class path="hxsl.ChannelTools" params="" file="/usr/local/lib/haxeLibrary/heaps/git/hxsl/Types.hx" module="hxsl.Types"><isPackedFormat public="1" get="inline" set="null" line="15" static="1"><f a="c">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Bool"/>
</f></isPackedFormat></class>
	<class path="justPath.IPathContext" params="" file="/usr/local/lib/haxeLibrary/justPath/git/justPath/IPathContext.hx" interface="1">
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadTo public="1" set="method"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<curveTo public="1" set="method"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
	</class>
	<abstract path="lime.utils.ArrayBuffer" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBuffer.hx">
		<from>
			<icast><d/></icast>
			<icast><c path="haxe.io.Bytes"/></icast>
		</from>
		<this><c path="haxe.io.Bytes"/></this>
		<to>
			<icast><d/></icast>
			<icast><c path="haxe.io.Bytes"/></icast>
		</to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer" final="1">
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<get_byteLength get="inline" set="null" line="15" static="1">
		<f a="this">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_byteLength>
	<_new public="1" get="inline" set="null" line="20" static="1">
		<f a="byteLength">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<isView public="1" get="inline" set="null" line="25" static="1"><f a="arg">
	<d/>
	<x path="Bool"/>
</f></isView>
	<slice public="1" get="inline" set="null" line="30" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</slice>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer" final="1">
		<byteLength public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</byteLength>
		<get_byteLength get="inline" set="null" line="15" static="1">
			<f a="this">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_byteLength>
		<_new public="1" get="inline" set="null" line="20" static="1">
			<f a="byteLength">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<isView public="1" get="inline" set="null" line="25" static="1"><f a="arg">
	<d/>
	<x path="Bool"/>
</f></isView>
		<slice public="1" get="inline" set="null" line="30" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</slice>
	</class>
	<class path="lime.utils.ArrayBufferView" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx">
		<type public="1" expr="TypedArrayType.None">
			<x path="lime.utils.TypedArrayType"/>
			<meta><m n=":value"><e>TypedArrayType.None</e></m></meta>
		</type>
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<length public="1"><x path="Int"/></length>
		<bytesPerElement set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bytesPerElement>
		<initTypedArray get="inline" set="null" line="45">
			<f a="view">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initTypedArray>
		<initBuffer get="inline" set="null" line="76">
			<f a="in_buffer:?in_byteOffset:?len" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta>
				<m n=":value"><e>{ len : null, in_byteOffset : 0 }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</initBuffer>
		<initArray params="T" get="inline" set="null" line="112">
			<f a="array">
				<c path="Array"><c path="initArray.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initArray>
		<set public="1" params="T" get="inline" set="null" line="129">
			<f a="?view:?array:?offset" v="null:null:0">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="Array"><c path="set.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0, array : null, view : null }</e></m></meta>
		</set>
		<cloneBuffer get="inline" set="null" line="149">
			<f a="src:?srcByteOffset" v=":0">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ srcByteOffset : 0 }</e></m></meta>
		</cloneBuffer>
		<subarray params="T_subarray" get="inline" set="null" line="163">
			<f a="begin:?end" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="subarray.T_subarray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":generic"/>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</subarray>
		<bytesForType get="inline" set="null" line="208"><f a="type">
	<x path="lime.utils.TypedArrayType"/>
	<x path="Int"/>
</f></bytesForType>
		<toString get="inline" set="null" line="246"><f a=""><c path="String"/></f></toString>
		<toByteLength get="inline" set="null" line="268"><f a="elemCount">
	<x path="Int"/>
	<x path="Int"/>
</f></toByteLength>
		<copyFromArray set="method" line="278">
			<f a="array:?offset" v=":0">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</copyFromArray>
		<new get="inline" set="null" line="20">
			<f a="?elements:in_type" v="null:">
				<x path="Int"/>
				<x path="lime.utils.TypedArrayType"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ elements : null }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.utils.TAError" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<RangeError/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<abstract path="lime.utils.TypedArrayType" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1" final="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="406" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Int8 public="1" get="inline" set="null" expr="cast 1" line="407" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int8>
	<Int16 public="1" get="inline" set="null" expr="cast 2" line="408" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int16>
	<Int32 public="1" get="inline" set="null" expr="cast 3" line="409" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int32>
	<Uint8 public="1" get="inline" set="null" expr="cast 4" line="410" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8>
	<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="411" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8Clamped>
	<Uint16 public="1" get="inline" set="null" expr="cast 6" line="412" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint16>
	<Uint32 public="1" get="inline" set="null" expr="cast 7" line="413" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint32>
	<Float32 public="1" get="inline" set="null" expr="cast 8" line="414" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float32>
	<Float64 public="1" get="inline" set="null" expr="cast 9" line="415" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float64>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1" final="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="406" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Int8 public="1" get="inline" set="null" expr="cast 1" line="407" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int8>
		<Int16 public="1" get="inline" set="null" expr="cast 2" line="408" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int16>
		<Int32 public="1" get="inline" set="null" expr="cast 3" line="409" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int32>
		<Uint8 public="1" get="inline" set="null" expr="cast 4" line="410" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8>
		<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="411" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8Clamped>
		<Uint16 public="1" get="inline" set="null" expr="cast 6" line="412" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint16>
		<Uint32 public="1" get="inline" set="null" expr="cast 7" line="413" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint32>
		<Float32 public="1" get="inline" set="null" expr="cast 8" line="414" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float32>
		<Float64 public="1" get="inline" set="null" expr="cast 9" line="415" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float64>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.utils.ArrayBufferIO" params="" file="/projects/May2019/May2020/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<getInt8 public="1" get="inline" set="null" line="424" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getInt8>
		<setInt8 public="1" get="inline" set="null" line="438" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setInt8>
		<getUint8 public="1" get="inline" set="null" line="454" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getUint8>
		<setUint8Clamped public="1" get="inline" set="null" line="467" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint8Clamped>
		<setUint8 public="1" get="inline" set="null" line="476" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setUint8>
		<getInt16 public="1" set="method" line="491" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getInt16>
		<getInt16_BE public="1" set="method" line="505" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getInt16_BE>
		<setInt16 public="1" set="method" line="519" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setInt16>
		<setInt16_BE public="1" set="method" line="534" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setInt16_BE>
		<getUint16 public="1" get="inline" set="null" line="551" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getUint16>
		<getUint16_BE public="1" get="inline" set="null" line="567" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getUint16_BE>
		<setUint16 public="1" get="inline" set="null" line="583" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setUint16>
		<setUint16_BE public="1" get="inline" set="null" line="596" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setUint16_BE>
		<getInt32 public="1" get="inline" set="null" line="611" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getInt32>
		<getInt32_BE public="1" get="inline" set="null" line="624" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getInt32_BE>
		<setInt32 public="1" get="inline" set="null" line="637" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setInt32>
		<setInt32_BE public="1" get="inline" set="null" line="654" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setInt32_BE>
		<getUint32 public="1" get="inline" set="null" line="671" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getUint32>
		<getUint32_BE public="1" get="inline" set="null" line="684" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getUint32_BE>
		<setUint32 public="1" get="inline" set="null" line="697" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setUint32>
		<setUint32_BE public="1" get="inline" set="null" line="710" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setUint32_BE>
		<getFloat32 public="1" get="inline" set="null" line="724" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getFloat32>
		<getFloat32_BE public="1" get="inline" set="null" line="737" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getFloat32_BE>
		<setFloat32 public="1" get="inline" set="null" line="750" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setFloat32>
		<setFloat32_BE public="1" get="inline" set="null" line="766" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setFloat32_BE>
		<getFloat64 public="1" get="inline" set="null" line="782" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getFloat64>
		<getFloat64_BE public="1" get="inline" set="null" line="795" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</getFloat64_BE>
		<setFloat64 public="1" get="inline" set="null" line="808" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setFloat64>
		<setFloat64_BE public="1" get="inline" set="null" line="824" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":extern"/>
			</meta>
		</setFloat64_BE>
		<_clamp get="inline" set="null" line="841" static="1">
			<f a="_in">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</_clamp>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<abstract path="lime.utils.Float32Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="92" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<hello public="1" static="1"><x path="Int"/></hello>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="98" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Float"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="130" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="134" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="139" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="145" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="148" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":extern"/>
		</meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="153" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="160" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
</class></impl>
	</abstract>
	<class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<hello public="1" static="1"><x path="Int"/></hello>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Float"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="130" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="134" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="139" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="145" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="148" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":extern"/>
			</meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="153" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="160" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
	</class>
	<abstract path="lime.utils.Float64Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float64Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="90" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>8</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="95" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Float"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="127" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="131" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="95" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Float"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="127" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="131" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int16Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="90" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="95" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="127" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="131" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="95" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="127" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="131" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int32Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="90" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="95" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="127" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="131" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="95" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="127" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="131" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int8Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="88" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="93" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="125" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="129" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="93" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="125" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="129" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.UInt16Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="90" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="95" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="127" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="131" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="95" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="127" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="131" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.UInt32Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="90" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="95" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="127" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="131" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="147" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="160" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="95" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="127" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="131" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="147" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="160" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.UInt8Array" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="88" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="93" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="125" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="129" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="140" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="93" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="125" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="129" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="140" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
	</class>
	<abstract path="lime.utils.UInt8ClampedArray" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8ClampedArray.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="100" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="105" static="1">
		<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<x path="openfl.Vector"><x path="Int"/></x>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="137" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="141" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="146" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="152" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="157" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="164" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="170" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/projects/May2019/May2020/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="105" static="1">
			<f a="?elements:?buffer:?array:?vector:?view:?byteoffset:?len" v=":::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<x path="openfl.Vector"><x path="Int"/></x>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="137" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="141" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="146" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="152" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="157" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="164" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="170" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<enum path="nme.AlphaMode" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/AlphaMode.hx">
		<AlphaDefault/>
		<AlphaUnmultiplied/>
		<AlphaIsPremultiplied/>
		<AlphaPreprocess/>
		<AlphaPostprocess/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.AssetInfo" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/AssetInfo.hx">
		<path public="1"><c path="String"/></path>
		<className public="1"><c path="String"/></className>
		<type public="1"><e path="nme.AssetType"/></type>
		<cache public="1"><c path="nme.utils.WeakRef"><d/></c></cache>
		<isResource public="1"><x path="Bool"/></isResource>
		<alphaMode public="1"><e path="nme.AlphaMode"/></alphaMode>
		<toString public="1" set="method" line="31"><f a=""><c path="String"/></f></toString>
		<uncache public="1" set="method" line="37"><f a=""><x path="Void"/></f></uncache>
		<getCache public="1" set="method" line="42"><f a=""><d/></f></getCache>
		<setCache public="1" set="method" line="52"><f a="inVal:inWeak">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setCache>
		<new public="1" set="method" line="16"><f a="inPath:inType:inIsResource:?inClassName:?id:?inAlphaMode">
	<c path="String"/>
	<e path="nme.AssetType"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="nme.AlphaMode"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.AssetLib" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/AssetLib.hx">
		<eventCallback public="1"><d/></eventCallback>
		<exists public="1" set="method" line="18"><f a="id:type">
	<c path="String"/>
	<e path="nme.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<getBitmapData public="1" set="method" line="19"><f a="id">
	<c path="String"/>
	<c path="nme.display.BitmapData"/>
</f></getBitmapData>
		<getBytes public="1" set="method" line="20"><f a="id">
	<c path="String"/>
	<c path="nme.utils.ByteArray"/>
</f></getBytes>
		<getFont public="1" set="method" line="21"><f a="id">
	<c path="String"/>
	<c path="nme.text.Font"/>
</f></getFont>
		<getMovieClip public="1" set="method" line="22"><f a="id">
	<c path="String"/>
	<c path="nme.display.MovieClip"/>
</f></getMovieClip>
		<getMusic public="1" set="method" line="23"><f a="id">
	<c path="String"/>
	<c path="nme.media.Sound"/>
</f></getMusic>
		<getPath public="1" set="method" line="24"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getSound public="1" set="method" line="25"><f a="id">
	<c path="String"/>
	<c path="nme.media.Sound"/>
</f></getSound>
		<getText public="1" set="method" line="26"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="34"><f a="id:type">
	<c path="String"/>
	<e path="nme.AssetType"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="35"><f a="type">
	<e path="nme.AssetType"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<load public="1" set="method" line="36"><f a="handler">
	<f a="">
		<c path="nme.AssetLib"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadBitmapData public="1" set="method" line="39"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmapData>
		<loadBytes public="1" set="method" line="42"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.utils.ByteArray"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBytes>
		<loadFont public="1" set="method" line="45"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.text.Font"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFont>
		<loadMovieClip public="1" set="method" line="48"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.display.MovieClip"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMovieClip>
		<loadMusic public="1" set="method" line="51"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadSound public="1" set="method" line="54"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="nme.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadText public="1" set="method" line="57"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadText>
		<unload public="1" set="method" line="66"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="nme.AssetType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/AssetType.hx">
		<BINARY/>
		<FONT/>
		<IMAGE/>
		<MUSIC/>
		<SOUND/>
		<TEXT/>
		<SWF/>
		<MOVIE_CLIP/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.Cache" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Assets.hx" module="nme.Assets">
		<removeBitmapData public="1" set="method" line="36"><f a="inId">
	<c path="String"/>
	<x path="Void"/>
</f></removeBitmapData>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="nme.AssetLibrary" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Assets.hx" module="nme.Assets"><c path="nme.AssetLib"/></typedef>
	<typedef path="nme.AssetLibFactory" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Assets.hx" module="nme.Assets"><f a="">
	<c path="String"/>
	<c path="nme.AssetLib"/>
</f></typedef>
	<class path="nme.utils.IDataOutput" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/IDataOutput.hx" interface="1">
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<get_endian set="method"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
	</class>
	<class path="nme.utils.IMemoryRange" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/IMemoryRange.hx" interface="1">
		<getByteBuffer public="1" set="method"><f a=""><c path="nme.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method"><f a=""><x path="Int"/></f></getLength>
	</class>
	<class path="nme.utils.IDataInput" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/IDataInput.hx" interface="1">
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="outData:?inOffset:?inLen" v=":0:0">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inLen : 0, inOffset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<get_bytesAvailable set="method"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
	</class>
	<class path="nme.Loader" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Loader.hx">
		<foundNdll public="1" expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</foundNdll>
		<moduleInit expr="false" line="17" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</moduleInit>
		<moduleName expr="&quot;&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</moduleName>
		<findHaxeLib public="1" set="method" line="34" static="1"><f a="inLib">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<load public="1" set="method" line="85" static="1"><f a="func:args">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<loaderTrace public="1" set="method" line="170" static="1"><f a="inStr">
	<c path="String"/>
	<x path="Void"/>
</f></loaderTrace>
		<sysName set="method" line="184" static="1"><f a=""><c path="String"/></f></sysName>
		<tryLoad public="1" set="method" line="195" static="1"><f a="inName:func:args">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></tryLoad>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="sys.io.Process" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/Process.hx">
		<p><d/></p>
		<stdout public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard output. The output stream where a process writes its output data.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard error. The output stream to output error messages or diagnostics.</haxe_doc>
		</stderr>
		<stdin public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>Standard input. The stream data going into a process.</haxe_doc>
		</stdin>
		<close public="1" set="method" line="113">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the process handle and release the associated resources.
		All `Process` fields should not be used after `close()` is called.</haxe_doc>
		</close>
		<new public="1" set="method" line="94">
			<f a="cmd:?args:?detached">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Construct a `Process` object, which run the given command immediately.

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		`detached` allows the created process to be standalone. You cannot communicate with it but you can look at its exit code. Not supported on php.

		`close()` should be called when the `Process` is no longer used.</haxe_doc>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="41" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="46" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="31"><f a="p">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="67" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="73" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="61"><f a="p:out">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.FileSystem" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="30" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<stat public="1" set="method" line="38" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" line="60" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.</haxe_doc>
		</fullPath>
		<isDirectory public="1" set="method" line="74" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="78" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="92" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<readDirectory public="1" set="method" line="100" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="nme.utils.ByteArray" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="nme.utils.IDataOutput"/>
		<implements path="nme.utils.IMemoryRange"/>
		<implements path="nme.utils.IDataInput"/>
		<mangleFloat set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"::mangleFloat"</e></m></meta>
		</mangleFloat>
		<mangleDouble set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"::mangleDouble"</e></m></meta>
		</mangleDouble>
		<fromBytes public="1" set="method" line="371" static="1"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<c path="nme.utils.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="471" static="1"><f a="inString">
	<c path="String"/>
	<c path="nme.utils.ByteArray"/>
</f></readFile>
		<nme_byte_array_overwrite_file expr="nme.Loader.load(&quot;nme_byte_array_overwrite_file&quot;, 2)" line="832" static="1">
			<f a=":">
				<c path="String"/>
				<c path="nme.utils.ByteArray"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_byte_array_overwrite_file", 2)</e></m></meta>
		</nme_byte_array_overwrite_file>
		<nme_byte_array_read_file expr="nme.Loader.load(&quot;nme_byte_array_read_file&quot;, 1)" line="833" static="1">
			<f a="">
				<c path="String"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_byte_array_read_file", 1)</e></m></meta>
		</nme_byte_array_read_file>
		<nme_lzma_encode expr="PrimeLoader.load(&quot;nme_lzma_encode&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_lzma_encode", "oo")</e></m></meta>
		</nme_lzma_encode>
		<nme_lzma_decode expr="PrimeLoader.load(&quot;nme_lzma_decode&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_lzma_decode", "oo")</e></m></meta>
		</nme_lzma_decode>
		<bigEndian public="1"><x path="Bool"/></bigEndian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<position public="1"><x path="Int"/></position>
		<byteLength public="1" get="accessor" set="null"><x path="Int"/></byteLength>
		<__length public="1" get="accessor" set="accessor"><x path="Int"/></__length>
		<get___length public="1" get="inline" set="null" line="117"><f a=""><x path="Int"/></f></get___length>
		<set___length public="1" get="inline" set="null" line="118"><f a="inLength">
	<x path="Int"/>
	<x path="Int"/>
</f></set___length>
		<__resize public="1" get="inline" set="null" line="119"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></__resize>
		<__get public="1" get="inline" set="null" line="193">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="228">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<asString public="1" set="method" line="240"><f a=""><c path="String"/></f></asString>
		<checkData public="1" set="method" line="245"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></checkData>
		<clear public="1" set="method" line="251"><f a=""><x path="Void"/></f></clear>
		<compress public="1" set="method" line="258">
			<f a="?algorithm" v="null">
				<e path="nme.utils.CompressionAlgorithm"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ algorithm : null }</e></m></meta>
		</compress>
		<deflate public="1" set="method" line="304"><f a=""><x path="Void"/></f></deflate>
		<setAllocSize public="1" set="method" line="310"><f a="inSize">
	<x path="Int"/>
	<x path="Void"/>
</f></setAllocSize>
		<setByteSize public="1" set="method" line="349"><f a="inSize">
	<x path="Int"/>
	<x path="Void"/>
</f></setByteSize>
		<ensureElem set="method" line="355">
			<f a="inSize:inUpdateLength">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ensureElem>
		<getLength public="1" set="method" line="378"><f a=""><x path="Int"/></f></getLength>
		<getByteBuffer public="1" set="method" line="381"><f a=""><c path="nme.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method" line="382"><f a=""><x path="Int"/></f></getStart>
		<inflate public="1" set="method" line="385"><f a=""><x path="Void"/></f></inflate>
		<nmeFromBytes get="inline" set="null" line="391"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></nmeFromBytes>
		<readBoolean public="1" get="inline" set="null" line="405"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" get="inline" set="null" line="410"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="416">
			<f a="outData:?inOffset:?inLen" v=":0:0">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inLen : 0, inOffset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method" line="443">
			<f a=""><x path="Float"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readDouble>
		<readFloat public="1" set="method" line="477">
			<f a=""><x path="Float"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readFloat>
		<readInt public="1" set="method" line="504"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" get="inline" set="null" line="514"><f a="inLen:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method" line="520"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" get="inline" set="null" line="530"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="535"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="545"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="553"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="559">
			<f a="inLen">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readUTFBytes>
		<setLength public="1" set="method" line="581"><f a="inLength">
	<x path="Int"/>
	<x path="Int"/>
</f></setLength>
		<slice public="1" set="method" line="589"><f a="inBegin:?inEnd">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nme.utils.ByteArray"/>
</f></slice>
		<ThrowEOFi set="method" line="621">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</ThrowEOFi>
		<uncompress public="1" set="method" line="627">
			<f a="?algorithm" v="null">
				<e path="nme.utils.CompressionAlgorithm"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ algorithm : null }</e></m></meta>
		</uncompress>
		<write_uncheck get="inline" set="null" line="676">
			<f a="inByte">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>@private</haxe_doc>
		</write_uncheck>
		<writeBoolean public="1" set="method" line="686"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" get="inline" set="null" line="691">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</writeByte>
		<writeBytes public="1" set="method" line="705">
			<f a="bytes:?inOffset:?inLength" v=":0:0">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inLength : 0, inOffset : 0 }</e></m></meta>
		</writeBytes>
		<writeHaxeBytes public="1" set="method" line="710"><f a="bytes:inOffset:inLength">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeHaxeBytes>
		<writeDouble public="1" set="method" line="720"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFile public="1" set="method" line="734"><f a="inString">
	<c path="String"/>
	<x path="Void"/>
</f></writeFile>
		<writeFloat public="1" set="method" line="740"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="752"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method" line="775"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method" line="791"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method" line="796"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="808"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<get_bytesAvailable set="method" line="820"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_byteLength set="method" line="821"><f a=""><x path="Int"/></f></get_byteLength>
		<get_endian set="method" line="822"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method" line="823"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<new public="1" set="method" line="73">
			<f a="?inSize:?inWriteOnly" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ inWriteOnly : false, inSize : 0 }</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":cppFileCode"><e><![CDATA["\nnamespace {\n   float mangleFloat(float f) {\n      char *c = (char *)&f;\n      std::swap(c[0],c[3]);\n      std::swap(c[1],c[2]);\n      return f;\n   }\n   double mangleDouble(double d) {\n      char *c = (char *)&d;\n      std::swap(c[0],c[7]);\n      std::swap(c[1],c[6]);\n      std::swap(c[2],c[5]);\n      std::swap(c[3],c[4]);\n      return d;\n   }\n\n}\n"]]></e></m>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.Assets" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Assets.hx">
		<UNCACHED public="1" get="inline" set="null" expr="0" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNCACHED>
		<WEAK_CACHE public="1" get="inline" set="null" expr="1" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</WEAK_CACHE>
		<STRONG_CACHE public="1" get="inline" set="null" expr="2" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</STRONG_CACHE>
		<info public="1" expr="new haxe.ds.StringMap&lt;AssetInfo&gt;()" line="53" static="1">
			<c path="haxe.ds.StringMap"><c path="nme.AssetInfo"/></c>
			<meta><m n=":value"><e><![CDATA[new haxe.ds.StringMap<AssetInfo>()]]></e></m></meta>
		</info>
		<pathMapper public="1" expr="new haxe.ds.StringMap&lt;String&gt;()" line="54" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[new haxe.ds.StringMap<String>()]]></e></m></meta>
		</pathMapper>
		<byteFactory public="1" expr="new haxe.ds.StringMap&lt;Void&gt;()" line="55" static="1">
			<c path="haxe.ds.StringMap"><f a=""><c path="nme.utils.ByteArray"/></f></c>
			<meta><m n=":value"><e><![CDATA[new haxe.ds.StringMap<Void>()]]></e></m></meta>
		</byteFactory>
		<libraryFactories public="1" expr="new haxe.ds.StringMap&lt;AssetLibFactory&gt;()" line="56" static="1">
			<c path="haxe.ds.StringMap"><t path="nme.AssetLibFactory"/></c>
			<meta><m n=":value"><e><![CDATA[new haxe.ds.StringMap<AssetLibFactory>()]]></e></m></meta>
		</libraryFactories>
		<loadedLibraries public="1" expr="new haxe.ds.StringMap&lt;AssetLib&gt;()" line="57" static="1">
			<c path="haxe.ds.StringMap"><c path="nme.AssetLib"/></c>
			<meta><m n=":value"><e><![CDATA[new haxe.ds.StringMap<AssetLib>()]]></e></m></meta>
		</loadedLibraries>
		<cacheMode public="1" expr="WEAK_CACHE" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>WEAK_CACHE</e></m></meta>
		</cacheMode>
		<scriptBase public="1" expr="&quot;&quot;" line="64" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</scriptBase>
		<cache public="1" expr="new Cache()" line="66" static="1">
			<c path="nme.Cache"/>
			<meta><m n=":value"><e>new Cache()</e></m></meta>
		</cache>
		<fromAssetList public="1" set="method" line="70" static="1"><f a="assetList:inAddScriptBase:inAlphaToo">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></fromAssetList>
		<loadAssetList public="1" set="method" line="96" static="1"><f a=""><x path="Void"/></f></loadAssetList>
		<loadScriptAssetList public="1" set="method" line="123" static="1"><f a=""><x path="Void"/></f></loadScriptAssetList>
		<loadScriptAssetList2 public="1" set="method" line="132" static="1"><f a=""><x path="Void"/></f></loadScriptAssetList2>
		<addLibraryFactory public="1" set="method" line="142" static="1"><f a="inType:inFactory">
	<e path="nme.AssetType"/>
	<t path="nme.AssetLibFactory"/>
	<x path="Void"/>
</f></addLibraryFactory>
		<getAssetPath public="1" set="method" line="147" static="1"><f a="inName">
	<c path="String"/>
	<c path="String"/>
</f></getAssetPath>
		<getPath public="1" get="inline" set="null" line="152" static="1"><f a="inName">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<addEventListener public="1" set="method" line="154" static="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<isEmbedded public="1" set="method" line="159" static="1"><f a="inName">
	<c path="String"/>
	<x path="Bool"/>
</f></isEmbedded>
		<getResource public="1" set="method" line="166" static="1"><f a="inName">
	<c path="String"/>
	<c path="nme.utils.ByteArray"/>
</f></getResource>
		<isLocal public="1" set="method" line="192" static="1"><f a="inId:inType">
	<c path="String"/>
	<e path="nme.AssetType"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="204" static="1"><f a="?inFilter">
	<e path="nme.AssetType"/>
	<t path="Iterator"><c path="String"/></t>
</f></list>
		<removeBitmapData public="1" set="method" line="219" static="1"><f a="inId">
	<c path="String"/>
	<x path="Void"/>
</f></removeBitmapData>
		<trySetCache public="1" set="method" line="227" static="1"><f a="info:useCache:data">
	<c path="nme.AssetInfo"/>
	<x path="Null"><x path="Bool"/></x>
	<d/>
	<x path="Void"/>
</f></trySetCache>
		<noId public="1" set="method" line="233" static="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></noId>
		<badType public="1" set="method" line="239" static="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></badType>
		<hasBitmapData public="1" set="method" line="245" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBitmapData>
		<getInfo public="1" set="method" line="252" static="1"><f a="inName">
	<c path="String"/>
	<x path="Null"><c path="nme.AssetInfo"/></x>
</f></getInfo>
		<makeBitmapData set="method" line="289" static="1"><f a="inClassName">
	<c path="String"/>
	<c path="nme.display.BitmapData"/>
</f></makeBitmapData>
		<getBitmapData public="1" set="method" line="304" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<x path="Bool"/>
				<c path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
    * @usage      var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
    * @param   id      The ID or asset path for the bitmap
    * @param   useCache      (Optional) Whether to use BitmapData from the cache(Default: according to setting)
    * @return      A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getImage public="1" get="inline" set="null" line="359" static="1"><f a="id:?useCache">
	<c path="String"/>
	<x path="Bool"/>
	<c path="nme.display.BitmapData"/>
</f></getImage>
		<hasBytes public="1" set="method" line="362" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBytes>
		<exists public="1" set="method" line="368" static="1"><f a="id:?type">
	<c path="String"/>
	<e path="nme.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<getBytes public="1" set="method" line="385" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<x path="Bool"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
    * @usage      var bytes = Assets.getBytes("file.zip");
    * @param   id      The ID or asset path for the file
    * @return      A new ByteArray object</haxe_doc>
		</getBytes>
		<getBytesInfo public="1" set="method" line="396" static="1"><f a="i:?useCache">
	<c path="nme.AssetInfo"/>
	<x path="Bool"/>
	<c path="nme.utils.ByteArray"/>
</f></getBytesInfo>
		<hasFont public="1" set="method" line="453" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<getFont public="1" set="method" line="465" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<x path="Bool"/>
				<c path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
    * @usage      var fontName = Assets.getFont("font.ttf").fontName;
    * @param   id      The ID or asset path for the font
    * @return      A new Font object</haxe_doc>
		</getFont>
		<hasSound public="1" set="method" line="497" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasSound>
		<getSound public="1" set="method" line="512" static="1">
			<f a="id:?useCache:?forceMusic:?inEngine" v="::false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="nme.media.Sound"/>
			</f>
			<meta><m n=":value"><e>{ forceMusic : false }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded sound
    * @usage      var sound = Assets.getSound("sound.wav");
    * @param   id      The ID or asset path for the sound
    * @param   inEngine   Which sound engine (sdl, openal etc) to use
    * @return      A new Sound object</haxe_doc>
		</getSound>
		<getMusic public="1" set="method" line="562" static="1"><f a="id:?useCache">
	<c path="String"/>
	<x path="Bool"/>
	<c path="nme.media.Sound"/>
</f></getMusic>
		<hasText public="1" set="method" line="579" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasText>
		<hasString public="1" set="method" line="580" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasString>
		<getText public="1" set="method" line="590" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
    * @usage      var text = Assets.getText("text.txt");
    * @param   id      The ID or asset path for the file
    * @return      A new String object</haxe_doc>
		</getText>
		<getString public="1" set="method" line="611" static="1"><f a="id:?useCache">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getString>
		<parseLibId public="1" set="method" line="616" static="1"><f a="id">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></parseLibId>
		<loadLibrary public="1" set="method" line="624" static="1"><f a="inLibName:onLoad">
	<c path="String"/>
	<f a="">
		<c path="nme.AssetLib"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadLibrary>
		<getLoadedLibrary public="1" set="method" line="648" static="1"><f a="inLibName">
	<c path="String"/>
	<c path="nme.AssetLib"/>
</f></getLoadedLibrary>
		<getMovieClip public="1" set="method" line="673" static="1"><f a="id">
	<c path="String"/>
	<c path="nme.display.MovieClip"/>
</f></getMovieClip>
		<initResources expr="(function() {
	var nme_set_resource_factory = nme.PrimeLoader.load(&quot;nme_set_resource_factory&quot;, &quot;ov&quot;);
	if (nme_set_resource_factory != null) {
		var notFound = new Map&lt;String,Bool&gt;();
		nme_set_resource_factory(function(s) {
			if (notFound.exists(s)) return null;
			var reso = haxe.Resource.getBytes(s);
			if (reso != null) ByteArray.fromBytes(reso);
			for (asset  in  info) {
				if (asset.path == s) return getBytesInfo(asset);
			};
			if (hasBytes(s)) return getBytes(s);
			notFound.set(s, true);
			return null;
		});
	};
	return null;
})()" line="689" static="1">
			<d/>
			<meta>
				<m n=":value"><e><![CDATA[(function() {
	var nme_set_resource_factory = nme.PrimeLoader.load("nme_set_resource_factory", "ov");
	if (nme_set_resource_factory != null) {
		var notFound = new Map<String,Bool>();
		nme_set_resource_factory(function(s) {
			if (notFound.exists(s)) return null;
			var reso = haxe.Resource.getBytes(s);
			if (reso != null) ByteArray.fromBytes(reso);
			for (asset  in  info) {
				if (asset.path == s) return getBytesInfo(asset);
			};
			if (hasBytes(s)) return getBytes(s);
			notFound.set(s, true);
			return null;
		});
	};
	return null;
})()]]></e></m>
				<m n=":keep"/>
			</meta>
		</initResources>
		<initialize public="1" set="method" line="716" static="1"><f a=""><x path="Void"/></f></initialize>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.app.Application" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/Application.hx">
		<OrientationPortrait public="1" get="inline" set="null" expr="1" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</OrientationPortrait>
		<OrientationPortraitUpsideDown public="1" get="inline" set="null" expr="2" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</OrientationPortraitUpsideDown>
		<OrientationLandscapeRight public="1" get="inline" set="null" expr="3" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</OrientationLandscapeRight>
		<OrientationLandscapeLeft public="1" get="inline" set="null" expr="4" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</OrientationLandscapeLeft>
		<OrientationFaceUp public="1" get="inline" set="null" expr="5" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</OrientationFaceUp>
		<OrientationFaceDown public="1" get="inline" set="null" expr="6" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</OrientationFaceDown>
		<OrientationPortraitAny public="1" get="inline" set="null" expr="7" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</OrientationPortraitAny>
		<OrientationLandscapeAny public="1" get="inline" set="null" expr="8" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</OrientationLandscapeAny>
		<OrientationAny public="1" get="inline" set="null" expr="9" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</OrientationAny>
		<FULLSCREEN public="1" get="inline" set="null" expr="0x0001" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</FULLSCREEN>
		<BORDERLESS public="1" get="inline" set="null" expr="0x0002" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</BORDERLESS>
		<RESIZABLE public="1" get="inline" set="null" expr="0x0004" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</RESIZABLE>
		<HARDWARE public="1" get="inline" set="null" expr="0x0008" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</HARDWARE>
		<VSYNC public="1" get="inline" set="null" expr="0x0010" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</VSYNC>
		<HW_AA public="1" get="inline" set="null" expr="0x0020" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</HW_AA>
		<HW_AA_HIRES public="1" get="inline" set="null" expr="0x0060" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0060</e></m></meta>
		</HW_AA_HIRES>
		<DEPTH_BUFFER public="1" get="inline" set="null" expr="0x0200" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" get="inline" set="null" expr="0x0400" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0400</e></m></meta>
		</STENCIL_BUFFER>
		<SINGLE_INSTANCE public="1" get="inline" set="null" expr="0x0800" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0800</e></m></meta>
		</SINGLE_INSTANCE>
		<SCALE_BASE public="1" get="inline" set="null" expr="0x1000" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</SCALE_BASE>
		<nmeFrameHandle public="1" expr="null" line="60" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nmeFrameHandle>
		<nmeWindow public="1" expr="null" line="61" static="1">
			<c path="nme.app.Window"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nmeWindow>
		<silentRecreate public="1" expr="false" line="62" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</silentRecreate>
		<sIsInit public="1" expr="false" line="63" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sIsInit>
		<initHeight public="1" static="1"><x path="Int"/></initHeight>
		<initWidth public="1" static="1"><x path="Int"/></initWidth>
		<initFrameRate public="1" static="1"><x path="Float"/></initFrameRate>
		<company public="1" set="null" static="1"><c path="String"/></company>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<packageName public="1" set="null" static="1"><c path="String"/></packageName>
		<file public="1" set="null" static="1"><c path="String"/></file>
		<build public="1" get="accessor" set="null" static="1"><c path="String"/></build>
		<ndllVersion public="1" get="accessor" set="null" static="1"><x path="Int"/></ndllVersion>
		<nmeStateVersion public="1" get="accessor" set="null" static="1"><c path="String"/></nmeStateVersion>
		<bits public="1" get="accessor" set="null" static="1"><x path="Int"/></bits>
		<onQuit public="1" expr="close" line="80" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>close</e></m></meta>
		</onQuit>
		<nmeQuitting public="1" expr="false" line="81" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</nmeQuitting>
		<asyncPing public="1" expr="null" line="82" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</asyncPing>
		<pollClientList static="1"><c path="Array"><c path="nme.app.IPollClient"/></c></pollClientList>
		<mainThreadJobs expr="[]" line="85" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mainThreadJobs>
		<mainThreadJobMutex expr="new Mutex()" line="87" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mainThreadJobMutex>
		<createWindow public="1" set="method" line="96" static="1"><f a="inOnLoaded:inParams">
	<f a="">
		<c path="nme.app.Window"/>
		<x path="Void"/>
	</f>
	<t path="nme.app.WindowParams"/>
	<x path="Void"/>
</f></createWindow>
		<close public="1" set="method" line="128" static="1"><f a=""><x path="Void"/></f></close>
		<addPollClient public="1" set="method" line="135" static="1">
			<f a="client:?inAtEnd" v=":false">
				<c path="nme.app.IPollClient"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inAtEnd : false }</e></m></meta>
		</addPollClient>
		<pollThreadJobs public="1" set="method" line="146" static="1"><f a=""><x path="Void"/></f></pollThreadJobs>
		<pollClients public="1" set="method" line="163" static="1"><f a="timestamp">
	<x path="Float"/>
	<x path="Void"/>
</f></pollClients>
		<getNextWake public="1" set="method" line="177" static="1"><f a="timestamp">
	<x path="Float"/>
	<x path="Float"/>
</f></getNextWake>
		<setFixedOrientation public="1" set="method" line="195" static="1"><f a="inOrientation">
	<x path="Int"/>
	<x path="Void"/>
</f></setFixedOrientation>
		<exit public="1" set="method" line="200" static="1"><f a=""><x path="Void"/></f></exit>
		<forceClose public="1" set="method" line="215" static="1"><f a=""><x path="Void"/></f></forceClose>
		<pause public="1" set="method" line="222" static="1"><f a=""><x path="Void"/></f></pause>
		<setNativeWindow public="1" set="method" line="227" static="1"><f a="window">
	<d/>
	<x path="Void"/>
</f></setNativeWindow>
		<runOnMainThread public="1" set="method" line="232" static="1"><f a="inCallback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></runOnMainThread>
		<postUICallback public="1" set="method" line="245" static="1"><f a="inCallback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></postUICallback>
		<resume public="1" set="method" line="254" static="1"><f a=""><x path="Void"/></f></resume>
		<setIcon public="1" set="method" line="265" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></setIcon>
		<setPackage public="1" set="method" line="272" static="1"><f a="inCompany:inFile:inPack:inVersion">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setPackage>
		<get_build public="1" set="method" line="315" static="1"><f a=""><c path="String"/></f></get_build>
		<get_ndllVersion public="1" set="method" line="316" static="1"><f a=""><x path="Int"/></f></get_ndllVersion>
		<get_nmeStateVersion public="1" set="method" line="317" static="1"><f a=""><c path="String"/></f></get_nmeStateVersion>
		<get_bits public="1" set="method" line="318" static="1"><f a=""><x path="Int"/></f></get_bits>
		<nme_set_package expr="PrimeLoader.load(&quot;nme_set_package&quot;, &quot;ssssv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_set_package", "ssssv")</e></m></meta>
		</nme_set_package>
		<nme_pause_animation expr="PrimeLoader.load(&quot;nme_pause_animation&quot;, &quot;v&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><c path="cpp.Void"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_pause_animation", "v")</e></m></meta>
		</nme_pause_animation>
		<nme_resume_animation expr="PrimeLoader.load(&quot;nme_resume_animation&quot;, &quot;v&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><c path="cpp.Void"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_resume_animation", "v")</e></m></meta>
		</nme_resume_animation>
		<nme_get_ndll_version expr="PrimeLoader.load(&quot;nme_get_ndll_version&quot;, &quot;i&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Int"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_get_ndll_version", "i")</e></m></meta>
		</nme_get_ndll_version>
		<nme_get_nme_state_version expr="Loader.load(&quot;nme_get_nme_state_version&quot;, 0)" line="329" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":value"><e>Loader.load("nme_get_nme_state_version", 0)</e></m></meta>
		</nme_get_nme_state_version>
		<nme_stage_set_fixed_orientation expr="PrimeLoader.load(&quot;nme_stage_set_fixed_orientation&quot;, &quot;iv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_fixed_orientation", "iv")</e></m></meta>
		</nme_stage_set_fixed_orientation>
		<nme_get_bits expr="PrimeLoader.load(&quot;nme_get_bits&quot;, &quot;i&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Int"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_get_bits", "i")</e></m></meta>
		</nme_get_bits>
		<nme_set_native_window expr="PrimeLoader.load(&quot;nme_set_native_window&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_set_native_window", "ov")</e></m></meta>
		</nme_set_native_window>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.Lib" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Lib.hx">
		<stage public="1" get="accessor" set="null" static="1"><c path="nme.display.Stage"/></stage>
		<current public="1" get="accessor" set="null" static="1"><c path="nme.display.MovieClip"/></current>
		<nmeCurrent expr="null" line="29" static="1">
			<c path="nme.display.MovieClip"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nmeCurrent>
		<nmeStage expr="null" line="30" static="1">
			<c path="nme.display.Stage"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nmeStage>
		<FULLSCREEN public="1" expr="Application.FULLSCREEN" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.FULLSCREEN</e></m></meta>
		</FULLSCREEN>
		<BORDERLESS public="1" expr="Application.BORDERLESS" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.BORDERLESS</e></m></meta>
		</BORDERLESS>
		<RESIZABLE public="1" expr="Application.RESIZABLE" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.RESIZABLE</e></m></meta>
		</RESIZABLE>
		<HARDWARE public="1" expr="Application.HARDWARE" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.HARDWARE</e></m></meta>
		</HARDWARE>
		<VSYNC public="1" expr="Application.VSYNC" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.VSYNC</e></m></meta>
		</VSYNC>
		<HW_AA public="1" expr="Application.HW_AA" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.HW_AA</e></m></meta>
		</HW_AA>
		<HW_AA_HIRES public="1" expr="Application.HW_AA_HIRES" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.HW_AA_HIRES</e></m></meta>
		</HW_AA_HIRES>
		<ALLOW_SHADERS public="1" expr="0" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" expr="0" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" expr="Application.DEPTH_BUFFER" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.DEPTH_BUFFER</e></m></meta>
		</DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" expr="Application.STENCIL_BUFFER" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.STENCIL_BUFFER</e></m></meta>
		</STENCIL_BUFFER>
		<SINGLE_INSTANCE public="1" expr="Application.SINGLE_INSTANCE" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Application.SINGLE_INSTANCE</e></m></meta>
		</SINGLE_INSTANCE>
		<initHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></initHeight>
		<initWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></initWidth>
		<company public="1" get="accessor" set="null" static="1"><c path="String"/></company>
		<version public="1" get="accessor" set="null" static="1"><c path="String"/></version>
		<packageName public="1" get="accessor" set="null" static="1"><c path="String"/></packageName>
		<file public="1" get="accessor" set="null" static="1"><c path="String"/></file>
		<title public="1" static="1"><c path="String"/></title>
		<build public="1" get="accessor" set="null" static="1"><c path="String"/></build>
		<ndllVersion public="1" get="accessor" set="null" static="1"><x path="Int"/></ndllVersion>
		<nmeStateVersion public="1" get="accessor" set="null" static="1"><c path="String"/></nmeStateVersion>
		<bits public="1" get="accessor" set="null" static="1"><x path="Int"/></bits>
		<silentRecreate public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></silentRecreate>
		<stageFactory public="1" static="1"><f a="">
	<c path="nme.app.Window"/>
	<c path="nme.display.Stage"/>
</f></stageFactory>
		<create public="1" set="method" line="64" static="1">
			<f a="inOnLoaded:inWidth:inHeight:?inFrameRate:?inColour:?inFlags:?inTitle:?inIcon:?inDummy" v=":::60.0:0xffffffff:0x0f:&quot;NME&quot;::">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Null"><t path="nme.bare.Surface"/></x>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inTitle : "NME", inFlags : 0x0f, inColour : 0xffffffff, inFrameRate : 60.0 }</e></m></meta>
		</create>
		<load public="1" set="method" line="104" static="1">
			<f a="library:method:?args" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ args : 0 }</e></m></meta>
		</load>
		<crash public="1" set="method" line="114" static="1"><f a=""><x path="Void"/></f></crash>
		<log public="1" set="method" line="119" static="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<redirectTrace public="1" set="method" line="124" static="1"><f a=""><x path="Void"/></f></redirectTrace>
		<createManagedStage public="1" set="method" line="135" static="1">
			<f a="inWidth:inHeight:?inFlags" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.display.ManagedStage"/>
			</f>
			<meta><m n=":value"><e>{ inFlags : 0 }</e></m></meta>
		</createManagedStage>
		<getURL public="1" set="method" line="148" static="1"><f a="url:?target">
	<c path="nme.net.URLRequest"/>
	<c path="String"/>
	<x path="Void"/>
</f></getURL>
		<getTimer public="1" set="method" line="153" static="1"><f a=""><x path="Int"/></f></getTimer>
		<get_current set="method" line="161" static="1"><f a=""><c path="nme.display.MovieClip"/></f></get_current>
		<get_stage set="method" line="174" static="1"><f a=""><c path="nme.display.Stage"/></f></get_stage>
		<nmeSetCurrentStage public="1" set="method" line="182" static="1"><f a="inStage">
	<c path="nme.display.Stage"/>
	<x path="Void"/>
</f></nmeSetCurrentStage>
		<close public="1" expr="Application.close" line="188" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>Application.close</e></m></meta>
		</close>
		<exit public="1" expr="Application.exit" line="189" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>Application.exit</e></m></meta>
		</exit>
		<forceClose public="1" expr="Application.forceClose" line="190" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>Application.forceClose</e></m></meta>
		</forceClose>
		<pause public="1" expr="Application.pause" line="192" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>Application.pause</e></m></meta>
		</pause>
		<postUICallback public="1" expr="Application.postUICallback" line="193" static="1">
			<f a="inCallback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>Application.postUICallback</e></m></meta>
		</postUICallback>
		<resume public="1" expr="Application.resume" line="194" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>Application.resume</e></m></meta>
		</resume>
		<setPackage public="1" expr="Application.setPackage" line="195" static="1">
			<f a="inCompany:inFile:inPack:inVersion">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>Application.setPackage</e></m></meta>
		</setPackage>
		<setIcon public="1" expr="Application.setIcon" line="196" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>Application.setIcon</e></m></meta>
		</setIcon>
		<get_initWidth public="1" set="method" line="199" static="1"><f a=""><x path="Int"/></f></get_initWidth>
		<get_initHeight public="1" set="method" line="200" static="1"><f a=""><x path="Int"/></f></get_initHeight>
		<get_company public="1" set="method" line="202" static="1"><f a=""><c path="String"/></f></get_company>
		<get_version public="1" set="method" line="203" static="1"><f a=""><c path="String"/></f></get_version>
		<get_packageName public="1" set="method" line="204" static="1"><f a=""><c path="String"/></f></get_packageName>
		<get_file public="1" set="method" line="205" static="1"><f a=""><c path="String"/></f></get_file>
		<get_build public="1" set="method" line="207" static="1"><f a=""><c path="String"/></f></get_build>
		<get_ndllVersion public="1" set="method" line="208" static="1"><f a=""><x path="Int"/></f></get_ndllVersion>
		<get_nmeStateVersion public="1" set="method" line="209" static="1"><f a=""><c path="String"/></f></get_nmeStateVersion>
		<get_bits public="1" set="method" line="210" static="1"><f a=""><x path="Int"/></f></get_bits>
		<get_silentRecreate public="1" set="method" line="212" static="1"><f a=""><x path="Bool"/></f></get_silentRecreate>
		<set_silentRecreate public="1" set="method" line="213" static="1"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_silentRecreate>
		<nme_log expr="Loader.load(&quot;nme_log&quot;, 1)" line="217" static="1">
			<f a="">
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_log", 1)</e></m></meta>
		</nme_log>
		<nme_crash expr="Loader.load(&quot;nme_crash&quot;, 0)" line="218" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>Loader.load("nme_crash", 0)</e></m></meta>
		</nme_crash>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.Memory" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Memory.hx">
		<gcRef static="1"><c path="nme.utils.ByteArray"/></gcRef>
		<len static="1"><x path="Int"/></len>
		<select public="1" set="method" line="28" static="1">
			<f a="inBytes">
				<c path="nme.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</select>
		<getByte public="1" get="inline" set="null" line="207" static="1">
			<f a="addr">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getByte>
		<getDouble public="1" get="inline" set="null" line="213" static="1">
			<f a="addr">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getDouble>
		<getFloat public="1" get="inline" set="null" line="219" static="1">
			<f a="addr">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getFloat>
		<getI32 public="1" get="inline" set="null" line="225" static="1">
			<f a="addr">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getI32>
		<getUI16 public="1" get="inline" set="null" line="231" static="1">
			<f a="addr">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getUI16>
		<setByte public="1" get="inline" set="null" line="237" static="1">
			<f a="addr:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setByte>
		<setDouble public="1" get="inline" set="null" line="243" static="1">
			<f a="addr:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setDouble>
		<setFloat public="1" get="inline" set="null" line="249" static="1">
			<f a="addr:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFloat>
		<setI16 public="1" get="inline" set="null" line="255" static="1">
			<f a="addr:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setI16>
		<setI32 public="1" get="inline" set="null" line="261" static="1">
			<f a="addr:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setI32>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<typedef path="nme.NativeHandle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/NativeHandle.hx"><d/></typedef>
	<typedef path="nme.NativeHandler" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/NativeHandle.hx" module="nme.NativeHandle"><a><nmeHandle><t path="nme.NativeHandle"/></nmeHandle></a></typedef>
	<class path="nme.NativeResource" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/NativeResource.hx">
		<AUTO_CLEAR public="1" get="inline" set="null" expr="0x0001" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</AUTO_CLEAR>
		<WRITE_ONLY public="1" get="inline" set="null" expr="0x0002" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</WRITE_ONLY>
		<disposeHandler public="1" get="inline" set="null" line="116" static="1"><f a="handler">
	<t path="nme.NativeHandler"/>
	<x path="Void"/>
</f></disposeHandler>
		<setAutoClearHandler public="1" get="inline" set="null" line="119" static="1"><f a="handler">
	<t path="nme.NativeHandler"/>
	<x path="Void"/>
</f></setAutoClearHandler>
		<setWriteOnlyHandler public="1" get="inline" set="null" line="120" static="1"><f a="handler">
	<t path="nme.NativeHandler"/>
	<x path="Void"/>
</f></setWriteOnlyHandler>
		<lockHandler public="1" get="inline" set="null" line="121" static="1"><f a="handler">
	<t path="nme.NativeHandler"/>
	<x path="Void"/>
</f></lockHandler>
		<unlockHandler public="1" get="inline" set="null" line="122" static="1"><f a="handler">
	<t path="nme.NativeHandler"/>
	<x path="Void"/>
</f></unlockHandler>
		<dispose public="1" get="inline" set="null" line="124" static="1"><f a="handle">
	<t path="nme.NativeHandle"/>
	<t path="nme.NativeHandle"/>
</f></dispose>
		<setAutoClear public="1" get="inline" set="null" line="125" static="1"><f a="handle">
	<t path="nme.NativeHandle"/>
	<x path="Void"/>
</f></setAutoClear>
		<setWriteOnly public="1" get="inline" set="null" line="126" static="1"><f a="handle">
	<t path="nme.NativeHandle"/>
	<x path="Void"/>
</f></setWriteOnly>
		<lock public="1" get="inline" set="null" line="127" static="1"><f a="handle">
	<t path="nme.NativeHandle"/>
	<x path="Void"/>
</f></lock>
		<unlock public="1" get="inline" set="null" line="128" static="1"><f a="handle">
	<t path="nme.NativeHandle"/>
	<x path="Void"/>
</f></unlock>
		<releaseTempRefs public="1" get="inline" set="null" line="129" static="1"><f a=""><x path="Void"/></f></releaseTempRefs>
	</class>
	<class path="nme.PrimeLoader" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/PrimeLoader.hx"><load public="1" set="method" static="1"><f a="inName2:inSig">
	<d/>
	<d/>
	<d/>
</f></load></class>
	<typedef path="nme._Vector.VectorData" params="T" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx" private="1" module="nme.Vector"><c path="Array"><c path="nme._Vector.VectorData.T"/></c></typedef>
	<abstract path="nme.Vector" params="T" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx">
		<from><icast field="fromArray"><c path="Array"><c path="fromArray.U"/></c></icast></from>
		<this><t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="toArray.T"/></c></icast></to>
		<meta>
			<m n=":nativeProperty"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="nme._Vector.Vector_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx" private="1" module="nme.Vector" final="1">
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</fixed>
	<_new public="1" get="inline" set="null" line="36" static="1">
		<f a="?length:?fixed">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="nme.Vector"><c path="nme.Vector.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<concat public="1" get="inline" set="null" line="49" static="1">
		<f a="this:?a">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="nme.Vector"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copy public="1" get="inline" set="null" line="56" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="nme.Vector"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</copy>
	<iterator public="1" params="T" get="inline" set="null" line="67" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="iterator.T"/></t>
			<t path="Iterator"><c path="iterator.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<join public="1" get="inline" set="null" line="78" static="1">
		<f a="this:sep">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</join>
	<pop public="1" get="inline" set="null" line="85" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Null"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</pop>
	<push public="1" get="inline" set="null" line="92" static="1">
		<f a="this:x">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="nme.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<reverse public="1" get="inline" set="null" line="99" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<shift public="1" get="inline" set="null" line="106" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Null"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</shift>
	<unshift public="1" get="inline" set="null" line="113" static="1">
		<f a="this:x">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="nme.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unshift>
	<slice public="1" get="inline" set="null" line="120" static="1">
		<f a="this:?pos:?end">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Int"/>
			<x path="Int"/>
			<x path="nme.Vector"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</slice>
	<sort public="1" get="inline" set="null" line="127" static="1">
		<f a="this:f">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<f a=":">
				<c path="nme.Vector.T"/>
				<c path="nme.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</sort>
	<splice public="1" get="inline" set="null" line="134" static="1">
		<f a="this:pos:len">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Int"/>
			<x path="Int"/>
			<x path="nme.Vector"><c path="nme.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</splice>
	<toString public="1" get="inline" set="null" line="141" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<insertAt public="1" get="inline" set="null" line="149" static="1">
		<f a="this:index:element">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Int"/>
			<c path="nme.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</insertAt>
	<indexOf public="1" get="inline" set="null" line="155" static="1">
		<f a="this:x:?from" v="::0">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="nme.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ from : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</indexOf>
	<lastIndexOf public="1" get="inline" set="null" line="173" static="1">
		<f a="this:x:?from" v="::0">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<c path="nme.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ from : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</lastIndexOf>
	<ofArray public="1" params="T" get="inline" set="null" line="193" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="nme.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="204" static="1"><f a="v">
	<t path="nme._Vector.VectorData"><c path="convert.T"/></t>
	<x path="nme.Vector"><c path="convert.U"/></x>
</f></convert>
	<fromArray public="1" params="T:U" get="inline" set="null" line="215" static="1">
		<f a="a">
			<c path="Array"><c path="fromArray.U"/></c>
			<x path="nme.Vector"><c path="fromArray.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray>
	<toArray public="1" params="T" get="inline" set="null" line="231" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="toArray.T"/></t>
			<c path="Array"><c path="toArray.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toArray>
	<get_length get="inline" set="null" line="246" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<set_length get="inline" set="null" line="253" static="1">
		<f a="this:value">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_length>
	<get_fixed get="inline" set="null" line="264" static="1">
		<f a="this">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_fixed>
	<set_fixed get="inline" set="null" line="275" static="1">
		<f a="this:value">
			<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_fixed>
</class></impl>
	</abstract>
	<class path="nme._Vector.Vector_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Vector.hx" private="1" module="nme.Vector" final="1">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" get="inline" set="null" line="36" static="1">
			<f a="?length:?fixed">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="nme.Vector"><c path="nme.Vector.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<concat public="1" get="inline" set="null" line="49" static="1">
			<f a="this:?a">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="nme.Vector"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" get="inline" set="null" line="56" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="nme.Vector"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" get="inline" set="null" line="67" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="iterator.T"/></t>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" get="inline" set="null" line="78" static="1">
			<f a="this:sep">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" get="inline" set="null" line="85" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Null"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" get="inline" set="null" line="92" static="1">
			<f a="this:x">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="nme.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" get="inline" set="null" line="99" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" get="inline" set="null" line="106" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Null"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" get="inline" set="null" line="113" static="1">
			<f a="this:x">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="nme.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" get="inline" set="null" line="120" static="1">
			<f a="this:?pos:?end">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="nme.Vector"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</slice>
		<sort public="1" get="inline" set="null" line="127" static="1">
			<f a="this:f">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<f a=":">
					<c path="nme.Vector.T"/>
					<c path="nme.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" get="inline" set="null" line="134" static="1">
			<f a="this:pos:len">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="nme.Vector"><c path="nme.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" get="inline" set="null" line="141" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<insertAt public="1" get="inline" set="null" line="149" static="1">
			<f a="this:index:element">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Int"/>
				<c path="nme.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</insertAt>
		<indexOf public="1" get="inline" set="null" line="155" static="1">
			<f a="this:x:?from" v="::0">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="nme.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ from : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</indexOf>
		<lastIndexOf public="1" get="inline" set="null" line="173" static="1">
			<f a="this:x:?from" v="::0">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<c path="nme.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ from : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</lastIndexOf>
		<ofArray public="1" params="T" get="inline" set="null" line="193" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="nme.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="204" static="1"><f a="v">
	<t path="nme._Vector.VectorData"><c path="convert.T"/></t>
	<x path="nme.Vector"><c path="convert.U"/></x>
</f></convert>
		<fromArray public="1" params="T:U" get="inline" set="null" line="215" static="1">
			<f a="a">
				<c path="Array"><c path="fromArray.U"/></c>
				<x path="nme.Vector"><c path="fromArray.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
		<toArray public="1" params="T" get="inline" set="null" line="231" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="toArray.T"/></t>
				<c path="Array"><c path="toArray.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<get_length get="inline" set="null" line="246" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<set_length get="inline" set="null" line="253" static="1">
			<f a="this:value">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_length>
		<get_fixed get="inline" set="null" line="264" static="1">
			<f a="this">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_fixed>
		<set_fixed get="inline" set="null" line="275" static="1">
			<f a="this:value">
				<t path="nme._Vector.VectorData"><c path="nme.Vector.T"/></t>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_fixed>
	</class>
	<class path="nme.Version" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/Version.hx"><name public="1" get="inline" set="null" expr="&quot;6.0.123&quot;" line="3" static="1">
	<c path="String"/>
	<meta><m n=":value"><e>"6.0.123"</e></m></meta>
</name></class>
	<abstract path="nme.app.AppEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/AppEvent.hx">
		<from><icast><c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c></icast></from>
		<this><c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c></this>
		<meta><m n=":nativeProperty"/></meta>
		<impl><class path="nme.app._AppEvent.AppEvent_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/AppEvent.hx" private="1" module="nme.app.AppEvent" final="1">
	<type public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</type>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</y>
	<value public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</value>
	<code public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</code>
	<id public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</id>
	<flags public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</flags>
	<result public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</result>
	<sx public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</sx>
	<sy public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</sy>
	<deltaX public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</deltaX>
	<deltaY public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</deltaY>
	<pollTime public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</pollTime>
	<text public="1" get="accessor" set="accessor" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</text>
	<get_type get="inline" set="null" line="25" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_type>
	<get_x get="inline" set="null" line="26" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<get_y get="inline" set="null" line="27" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_x get="inline" set="null" line="28" static="1">
		<f a="this:val">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<set_y get="inline" set="null" line="29" static="1">
		<f a="this:val">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<get_value get="inline" set="null" line="30" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_value>
	<get_code get="inline" set="null" line="31" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_code>
	<get_id get="inline" set="null" line="32" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_id>
	<get_flags get="inline" set="null" line="33" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_flags>
	<get_result get="inline" set="null" line="34" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_result>
	<set_result get="inline" set="null" line="35" static="1">
		<f a="this:inResult">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_result>
	<get_sx get="inline" set="null" line="36" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_sx>
	<get_sy get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_sy>
	<get_deltaX get="inline" set="null" line="38" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_deltaX>
	<get_deltaY get="inline" set="null" line="39" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_deltaY>
	<get_pollTime get="inline" set="null" line="40" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pollTime>
	<set_pollTime get="inline" set="null" line="41" static="1">
		<f a="this:inWake">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_pollTime>
	<get_text get="inline" set="null" line="42" static="1">
		<f a="this">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<c path="String"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":impl"/>
		</meta>
	</get_text>
	<set_text get="inline" set="null" line="43" static="1">
		<f a="this:inText">
			<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_text>
</class></impl>
	</abstract>
	<class path="nme.app._AppEvent.AppEvent_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/AppEvent.hx" private="1" module="nme.app.AppEvent" final="1">
		<type public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</type>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</y>
		<value public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</value>
		<code public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</code>
		<id public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</id>
		<flags public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</flags>
		<result public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</result>
		<sx public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</sx>
		<sy public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</sy>
		<deltaX public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</deltaX>
		<deltaY public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</deltaY>
		<pollTime public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</pollTime>
		<text public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
		</text>
		<get_type get="inline" set="null" line="25" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_type>
		<get_x get="inline" set="null" line="26" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<get_y get="inline" set="null" line="27" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_x get="inline" set="null" line="28" static="1">
			<f a="this:val">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<set_y get="inline" set="null" line="29" static="1">
			<f a="this:val">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<get_value get="inline" set="null" line="30" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_value>
		<get_code get="inline" set="null" line="31" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_code>
		<get_id get="inline" set="null" line="32" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_id>
		<get_flags get="inline" set="null" line="33" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_flags>
		<get_result get="inline" set="null" line="34" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_result>
		<set_result get="inline" set="null" line="35" static="1">
			<f a="this:inResult">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_result>
		<get_sx get="inline" set="null" line="36" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_sx>
		<get_sy get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_sy>
		<get_deltaX get="inline" set="null" line="38" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_deltaX>
		<get_deltaY get="inline" set="null" line="39" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_deltaY>
		<get_pollTime get="inline" set="null" line="40" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pollTime>
		<set_pollTime get="inline" set="null" line="41" static="1">
			<f a="this:inWake">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_pollTime>
		<get_text get="inline" set="null" line="42" static="1">
			<f a="this">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":impl"/>
			</meta>
		</get_text>
		<set_text get="inline" set="null" line="43" static="1">
			<f a="this:inText">
				<c path="cpp.Pointer"><c path="nme.native.NativeEvent"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_text>
	</class>
	<typedef path="nme.app.WindowParams" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/Application.hx" module="nme.app.Application"><a>
	<width>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</width>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<icon>
		<x path="Null"><t path="nme.bare.Surface"/></x>
		<meta><m n=":optional"/></meta>
	</icon>
	<height>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</height>
	<fps>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</fps>
	<flags>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</flags>
	<color>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</color>
</a></typedef>
	<class path="nme.app.EventId" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/EventId.hx">
		<Unknown public="1" get="inline" set="null" expr="0" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</Unknown>
		<KeyDown public="1" get="inline" set="null" expr="1" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</KeyDown>
		<Char public="1" get="inline" set="null" expr="2" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</Char>
		<KeyUp public="1" get="inline" set="null" expr="3" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</KeyUp>
		<MouseMove public="1" get="inline" set="null" expr="4" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MouseMove>
		<MouseDown public="1" get="inline" set="null" expr="5" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</MouseDown>
		<MouseClick public="1" get="inline" set="null" expr="6" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</MouseClick>
		<MouseUp public="1" get="inline" set="null" expr="7" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</MouseUp>
		<Resize public="1" get="inline" set="null" expr="8" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</Resize>
		<Poll public="1" get="inline" set="null" expr="9" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</Poll>
		<Quit public="1" get="inline" set="null" expr="10" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</Quit>
		<Focus public="1" get="inline" set="null" expr="11" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</Focus>
		<ShouldRotate public="1" get="inline" set="null" expr="12" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</ShouldRotate>
		<DestroyHandler public="1" get="inline" set="null" expr="13" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</DestroyHandler>
		<Redraw public="1" get="inline" set="null" expr="14" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</Redraw>
		<TouchBegin public="1" get="inline" set="null" expr="15" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</TouchBegin>
		<TouchMove public="1" get="inline" set="null" expr="16" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</TouchMove>
		<TouchEnd public="1" get="inline" set="null" expr="17" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</TouchEnd>
		<TouchTap public="1" get="inline" set="null" expr="18" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</TouchTap>
		<Change public="1" get="inline" set="null" expr="19" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</Change>
		<Activate public="1" get="inline" set="null" expr="20" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</Activate>
		<Deactivate public="1" get="inline" set="null" expr="21" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</Deactivate>
		<GotInputFocus public="1" get="inline" set="null" expr="22" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</GotInputFocus>
		<LostInputFocus public="1" get="inline" set="null" expr="23" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>23</e></m></meta>
		</LostInputFocus>
		<JoyAxisMove public="1" get="inline" set="null" expr="24" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>24</e></m></meta>
		</JoyAxisMove>
		<JoyBallMove public="1" get="inline" set="null" expr="25" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</JoyBallMove>
		<JoyHatMove public="1" get="inline" set="null" expr="26" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>26</e></m></meta>
		</JoyHatMove>
		<JoyButtonDown public="1" get="inline" set="null" expr="27" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</JoyButtonDown>
		<JoyButtonUp public="1" get="inline" set="null" expr="28" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</JoyButtonUp>
		<JoyDeviceAdded public="1" get="inline" set="null" expr="29" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</JoyDeviceAdded>
		<JoyDeviceRemoved public="1" get="inline" set="null" expr="30" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</JoyDeviceRemoved>
		<SysWM public="1" get="inline" set="null" expr="31" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>31</e></m></meta>
		</SysWM>
		<RenderContextLost public="1" get="inline" set="null" expr="32" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</RenderContextLost>
		<RenderContextRestored public="1" get="inline" set="null" expr="33" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33</e></m></meta>
		</RenderContextRestored>
		<Scroll public="1" get="inline" set="null" expr="34" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
		</Scroll>
		<AppLink public="1" get="inline" set="null" expr="35" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35</e></m></meta>
		</AppLink>
		<DpiChanged public="1" get="inline" set="null" expr="36" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36</e></m></meta>
		</DpiChanged>
		<DropBegin public="1" get="inline" set="null" expr="37" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37</e></m></meta>
		</DropBegin>
		<DropFile public="1" get="inline" set="null" expr="38" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>38</e></m></meta>
		</DropFile>
		<DropEnd public="1" get="inline" set="null" expr="39" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>39</e></m></meta>
		</DropEnd>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.app.EventName" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/EventName.hx">
		<KEY_DOWN public="1" get="inline" set="null" expr="&quot;keyDown&quot;" line="6" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyDown"</e></m></meta>
		</KEY_DOWN>
		<KEY_UP public="1" get="inline" set="null" expr="&quot;keyUp&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyUp"</e></m></meta>
		</KEY_UP>
		<MOUSE_MOVE public="1" get="inline" set="null" expr="&quot;mouseMove&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseMove"</e></m></meta>
		</MOUSE_MOVE>
		<MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;mouseDown&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseDown"</e></m></meta>
		</MOUSE_DOWN>
		<MOUSE_UP public="1" get="inline" set="null" expr="&quot;mouseUp&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseUp"</e></m></meta>
		</MOUSE_UP>
		<CLICK public="1" get="inline" set="null" expr="&quot;click&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"click"</e></m></meta>
		</CLICK>
		<TOUCH_BEGIN public="1" get="inline" set="null" expr="&quot;touchBegin&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchBegin"</e></m></meta>
		</TOUCH_BEGIN>
		<TOUCH_MOVE public="1" get="inline" set="null" expr="&quot;touchMove&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchMove"</e></m></meta>
		</TOUCH_MOVE>
		<TOUCH_END public="1" get="inline" set="null" expr="&quot;touchEnd&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchEnd"</e></m></meta>
		</TOUCH_END>
		<TOUCH_TAP public="1" get="inline" set="null" expr="&quot;touchTap&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchTap"</e></m></meta>
		</TOUCH_TAP>
		<AXIS_MOVE public="1" get="inline" set="null" expr="&quot;axisMove&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"axisMove"</e></m></meta>
		</AXIS_MOVE>
		<BALL_MOVE public="1" get="inline" set="null" expr="&quot;ballMove&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ballMove"</e></m></meta>
		</BALL_MOVE>
		<HAT_MOVE public="1" get="inline" set="null" expr="&quot;hatMove&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"hatMove"</e></m></meta>
		</HAT_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" expr="&quot;buttonDown&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"buttonDown"</e></m></meta>
		</BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" expr="&quot;buttonUp&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"buttonUp"</e></m></meta>
		</BUTTON_UP>
		<DEVICE_ADDED public="1" get="inline" set="null" expr="&quot;deviceAdded&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceAdded"</e></m></meta>
		</DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" expr="&quot;deviceRemoved&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceRemoved"</e></m></meta>
		</DEVICE_REMOVED>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.app.FrameTimer" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/FrameTimer.hx">
		<implements path="nme.app.IPollClient"/>
		<fps public="1" set="accessor"><x path="Float"/></fps>
		<lastRender public="1"><x path="Float"/></lastRender>
		<framePeriod public="1" set="null"><x path="Float"/></framePeriod>
		<window public="1"><c path="nme.app.Window"/></window>
		<invalid public="1"><x path="Bool"/></invalid>
		<catchup public="1"><x path="Bool"/></catchup>
		<offTarget public="1"><x path="Float"/></offTarget>
		<set_fps set="method" line="25"><f a="inFps">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fps>
		<onPoll public="1" set="method" line="32"><f a="timestamp">
	<x path="Float"/>
	<x path="Void"/>
</f></onPoll>
		<invalidate public="1" set="method" line="71"><f a=""><x path="Void"/></f></invalidate>
		<getNextWake public="1" set="method" line="76"><f a="defaultWake:timestamp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getNextWake>
		<new public="1" set="method" line="14"><f a="inWindow:inFps">
	<c path="nme.app.Window"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.app.IAppEventHandler" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/IAppEventHandler.hx" interface="1">
		<onRender public="1" set="method"><f a="inTimed">
	<x path="Bool"/>
	<x path="Void"/>
</f></onRender>
		<onText public="1" set="method"><f a="event:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onText>
		<onKey public="1" set="method"><f a="event:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onKey>
		<onMouse public="1" set="method"><f a="event:type:inFromMouse">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></onMouse>
		<onTouch public="1" set="method"><f a="event:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onTouch>
		<onResize public="1" set="method"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<onDisplayObjectFocus public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDisplayObjectFocus>
		<onInputFocus public="1" set="method"><f a="acquired">
	<x path="Bool"/>
	<x path="Void"/>
</f></onInputFocus>
		<onChange public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onChange>
		<onActive public="1" set="method"><f a="activated">
	<x path="Bool"/>
	<x path="Void"/>
</f></onActive>
		<onJoystick public="1" set="method"><f a="event:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onJoystick>
		<onSysMessage public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onSysMessage>
		<onAppLink public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onAppLink>
		<onContextLost public="1" set="method"><f a=""><x path="Void"/></f></onContextLost>
		<onScroll public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onScroll>
		<onDpiChanged public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDpiChanged>
		<onDrop public="1" set="method"><f a="event">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDrop>
		<onUnhandledException public="1" set="method"><f a="exception:stack">
	<d/>
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Void"/>
</f></onUnhandledException>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.app.Window" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/app/Window.hx">
		<nme_stage_resize_window expr="PrimeLoader.load(&quot;nme_stage_resize_window&quot;, &quot;oiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_resize_window", "oiiv")</e></m></meta>
		</nme_stage_resize_window>
		<nme_stage_is_opengl expr="PrimeLoader.load(&quot;nme_stage_is_opengl&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_is_opengl", "ob")</e></m></meta>
		</nme_stage_is_opengl>
		<nme_stage_get_stage_width expr="PrimeLoader.load(&quot;nme_stage_get_stage_width&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_stage_width", "oi")</e></m></meta>
		</nme_stage_get_stage_width>
		<nme_stage_get_stage_height expr="PrimeLoader.load(&quot;nme_stage_get_stage_height&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_stage_height", "oi")</e></m></meta>
		</nme_stage_get_stage_height>
		<nme_stage_get_dpi_scale expr="PrimeLoader.load(&quot;nme_stage_get_dpi_scale&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_dpi_scale", "od")</e></m></meta>
		</nme_stage_get_dpi_scale>
		<nme_stage_get_scale_mode expr="PrimeLoader.load(&quot;nme_stage_get_scale_mode&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_scale_mode", "oi")</e></m></meta>
		</nme_stage_get_scale_mode>
		<nme_stage_set_scale_mode expr="PrimeLoader.load(&quot;nme_stage_set_scale_mode&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_scale_mode", "oiv")</e></m></meta>
		</nme_stage_set_scale_mode>
		<nme_stage_get_align expr="PrimeLoader.load(&quot;nme_stage_get_align&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_align", "oi")</e></m></meta>
		</nme_stage_get_align>
		<nme_stage_set_align expr="PrimeLoader.load(&quot;nme_stage_set_align&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_align", "oiv")</e></m></meta>
		</nme_stage_set_align>
		<nme_stage_get_quality expr="PrimeLoader.load(&quot;nme_stage_get_quality&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_quality", "oi")</e></m></meta>
		</nme_stage_get_quality>
		<nme_stage_set_quality expr="PrimeLoader.load(&quot;nme_stage_set_quality&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_quality", "oiv")</e></m></meta>
		</nme_stage_set_quality>
		<nme_stage_get_display_state expr="PrimeLoader.load(&quot;nme_stage_get_display_state&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_display_state", "oi")</e></m></meta>
		</nme_stage_get_display_state>
		<nme_stage_set_display_state expr="PrimeLoader.load(&quot;nme_stage_set_display_state&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_display_state", "oiv")</e></m></meta>
		</nme_stage_set_display_state>
		<nme_stage_set_window_position expr="PrimeLoader.load(&quot;nme_stage_set_window_position&quot;, &quot;oiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_window_position", "oiiv")</e></m></meta>
		</nme_stage_set_window_position>
		<nme_stage_get_window_x expr="PrimeLoader.load(&quot;nme_stage_get_window_x&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_window_x", "oi")</e></m></meta>
		</nme_stage_get_window_x>
		<nme_stage_get_window_y expr="PrimeLoader.load(&quot;nme_stage_get_window_y&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_window_y", "oi")</e></m></meta>
		</nme_stage_get_window_y>
		<nme_stage_set_next_wake expr="PrimeLoader.load(&quot;nme_stage_set_next_wake&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_next_wake", "odv")</e></m></meta>
		</nme_stage_set_next_wake>
		<nme_stage_begin_render expr="PrimeLoader.load(&quot;nme_stage_begin_render&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_begin_render", "obv")</e></m></meta>
		</nme_stage_begin_render>
		<nme_stage_end_render expr="PrimeLoader.load(&quot;nme_stage_end_render&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_end_render", "ov")</e></m></meta>
		</nme_stage_end_render>
		<nme_get_frame_stage expr="PrimeLoader.load(&quot;nme_get_frame_stage&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_get_frame_stage", "oo")</e></m></meta>
		</nme_get_frame_stage>
		<nme_display_object_set_bg expr="Loader.load(&quot;nme_display_object_set_bg&quot;, 2)" line="431" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_set_bg", 2)</e></m></meta>
		</nme_display_object_set_bg>
		<nme_stage_get_title expr="PrimeLoader.load(&quot;nme_stage_get_title&quot;, &quot;os&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="String"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_title", "os")</e></m></meta>
		</nme_stage_get_title>
		<nme_stage_set_title expr="PrimeLoader.load(&quot;nme_stage_set_title&quot;, &quot;osv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<c path="String"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_title", "osv")</e></m></meta>
		</nme_stage_set_title>
		<nme_set_stage_handler expr="PrimeLoader.load(&quot;nme_set_stage_handler_native&quot;, &quot;ooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_set_stage_handler_native", "ooiiv")</e></m></meta>
		</nme_set_stage_handler>
		<active public="1"><x path="Bool"/></active>
		<align public="1" get="accessor" set="accessor"><e path="nme.display.StageAlign"/></align>
		<displayState public="1" get="accessor" set="accessor"><e path="nme.display.StageDisplayState"/></displayState>
		<dpiScale public="1" get="accessor" set="null"><x path="Float"/></dpiScale>
		<isOpenGL public="1" get="accessor" set="null"><x path="Bool"/></isOpenGL>
		<quality public="1" get="accessor" set="accessor"><e path="nme.display.StageQuality"/></quality>
		<scaleMode public="1" get="accessor" set="accessor"><e path="nme.display.StageScaleMode"/></scaleMode>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<x public="1" get="accessor" set="null"><x path="Int"/></x>
		<y public="1" get="accessor" set="null"><x path="Int"/></y>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<autoClear public="1"><x path="Bool"/></autoClear>
		<renderRequest public="1"><f a=""><x path="Bool"/></f></renderRequest>
		<nextWakeHandler public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></nextWakeHandler>
		<beginRenderImmediate public="1"><f a=""><x path="Void"/></f></beginRenderImmediate>
		<endRenderImmediate public="1"><f a=""><x path="Void"/></f></endRenderImmediate>
		<appEventHandler public="1"><c path="nme.app.IAppEventHandler"/></appEventHandler>
		<onText public="1"><f a="">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onText>
		<nmeHandle public="1" set="null"><t path="nme.NativeHandle"/></nmeHandle>
		<enterFramePending><x path="Bool"/></enterFramePending>
		<shouldRenderNow public="1" set="method" line="62"><f a=""><x path="Bool"/></f></shouldRenderNow>
		<setBackground public="1" set="method" line="69"><f a="inBackground">
	<x path="Null"><x path="Int"/></x>
	<x path="Void"/>
</f></setBackground>
		<onNewFrame public="1" set="method" line="78"><f a=""><x path="Void"/></f></onNewFrame>
		<onInvalidFrame public="1" set="method" line="99"><f a=""><x path="Void"/></f></onInvalidFrame>
		<nmeProcessWindowEvent set="method" line="118">
			<f a="inEvent">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</nmeProcessWindowEvent>
		<beginRender public="1" set="method" line="289"><f a=""><x path="Void"/></f></beginRender>
		<endRender public="1" set="method" line="293"><f a=""><x path="Void"/></f></endRender>
		<get_align public="1" set="method" line="299"><f a=""><e path="nme.display.StageAlign"/></f></get_align>
		<set_align public="1" set="method" line="305"><f a="inMode">
	<e path="nme.display.StageAlign"/>
	<e path="nme.display.StageAlign"/>
</f></set_align>
		<get_displayState public="1" set="method" line="311"><f a=""><e path="nme.display.StageDisplayState"/></f></get_displayState>
		<set_displayState public="1" set="method" line="317"><f a="inState">
	<e path="nme.display.StageDisplayState"/>
	<e path="nme.display.StageDisplayState"/>
</f></set_displayState>
		<get_dpiScale public="1" set="method" line="323"><f a=""><x path="Float"/></f></get_dpiScale>
		<get_isOpenGL public="1" set="method" line="330"><f a=""><x path="Bool"/></f></get_isOpenGL>
		<get_quality public="1" set="method" line="335"><f a=""><e path="nme.display.StageQuality"/></f></get_quality>
		<set_quality public="1" set="method" line="341"><f a="inQuality">
	<e path="nme.display.StageQuality"/>
	<e path="nme.display.StageQuality"/>
</f></set_quality>
		<get_scaleMode public="1" set="method" line="347"><f a=""><e path="nme.display.StageScaleMode"/></f></get_scaleMode>
		<set_scaleMode public="1" set="method" line="353"><f a="inMode">
	<e path="nme.display.StageScaleMode"/>
	<e path="nme.display.StageScaleMode"/>
</f></set_scaleMode>
		<get_x public="1" set="method" line="359"><f a=""><x path="Int"/></f></get_x>
		<get_y public="1" set="method" line="364"><f a=""><x path="Int"/></f></get_y>
		<get_height public="1" set="method" line="371"><f a=""><x path="Int"/></f></get_height>
		<get_width public="1" set="method" line="376"><f a=""><x path="Int"/></f></get_width>
		<resize public="1" set="method" line="382"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setPosition public="1" set="method" line="388"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPosition>
		<get_title public="1" set="method" line="393"><f a=""><c path="String"/></f></get_title>
		<set_title public="1" set="method" line="398"><f a="inTitle">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<new public="1" set="method" line="44"><f a="inFrameHandle:inWidth:inHeight">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<typedef path="nme.bare.Surface" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/bare/Surface.hx"><c path="nme.display.BitmapData"/></typedef>
	<class path="nme.events.IEventDispatcher" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/IEventDispatcher.hx" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<t path="nme.events.Function"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<t path="nme.events.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="nme.events.EventDispatcher" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/EventDispatcher.hx">
		<implements path="nme.events.IEventDispatcher"/>
		<sortEvents get="inline" set="null" line="88" static="1"><f a="a:b">
	<c path="nme.events.Listener"/>
	<c path="nme.events.Listener"/>
	<x path="Int"/>
</f></sortEvents>
		<nmeEventMap>
			<t path="nme.events.EventMap"/>
			<haxe_doc>@private</haxe_doc>
		</nmeEventMap>
		<nmeTarget>
			<c path="nme.events.IEventDispatcher"/>
			<haxe_doc>@private</haxe_doc>
		</nmeTarget>
		<addEventListener public="1" set="method" line="63">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<t path="nme.events.Function"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<mightRespondTo public="1" set="method" line="83"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></mightRespondTo>
		<DispatchCompleteEvent public="1" set="method" line="106"><f a=""><x path="Void"/></f></DispatchCompleteEvent>
		<dispatchEvent public="1" set="method" line="112"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<DispatchIOErrorEvent public="1" set="method" line="160"><f a=""><x path="Void"/></f></DispatchIOErrorEvent>
		<hasEventListener public="1" set="method" line="166"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method" line="183">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<t path="nme.events.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ capture : false }</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method" line="206"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method" line="211"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method" line="57"><f a="?target">
	<c path="nme.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="nme.display.IBitmapDrawable" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/IBitmapDrawable.hx" interface="1"><nmeDrawToSurface public="1" set="method">
	<f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
		<d/>
		<c path="nme.geom.Matrix"/>
		<c path="nme.geom.ColorTransform"/>
		<c path="String"/>
		<c path="nme.geom.Rectangle"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@private</haxe_doc>
</nmeDrawToSurface></class>
	<class path="nme.display.DisplayObject" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/DisplayObject.hx">
		<extends path="nme.events.EventDispatcher"/>
		<implements path="nme.display.IBitmapDrawable"/>
		<DISPLAY_KEEP_ID get="inline" set="null" expr="0x0001" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</DISPLAY_KEEP_ID>
		<decodeDisplay public="1" set="method" line="155" static="1">
			<f a="inBytes:?inFlags" v=":0">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<c path="nme.display.DisplayObject"/>
			</f>
			<meta><m n=":value"><e>{ inFlags : 0 }</e></m></meta>
		</decodeDisplay>
		<nme_create_display_object expr="PrimeLoader.load(&quot;nme_create_display_object&quot;, &quot;o&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><t path="cpp.Object"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_create_display_object", "o")</e></m></meta>
		</nme_create_display_object>
		<nme_display_object_get_graphics expr="PrimeLoader.load(&quot;nme_display_object_get_graphics&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_graphics", "oo")</e></m></meta>
		</nme_display_object_get_graphics>
		<nme_display_object_draw_to_surface expr="PrimeLoader.load(&quot;nme_display_object_draw_to_surface&quot;, &quot;ooooiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_draw_to_surface", "ooooiov")</e></m></meta>
		</nme_display_object_draw_to_surface>
		<nme_display_object_get_id expr="PrimeLoader.load(&quot;nme_display_object_get_id&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_id", "oi")</e></m></meta>
		</nme_display_object_get_id>
		<nme_display_object_get_x expr="PrimeLoader.load(&quot;nme_display_object_get_x&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_x", "od")</e></m></meta>
		</nme_display_object_get_x>
		<nme_display_object_set_x expr="PrimeLoader.load(&quot;nme_display_object_set_x&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_x", "odv")</e></m></meta>
		</nme_display_object_set_x>
		<nme_display_object_get_y expr="PrimeLoader.load(&quot;nme_display_object_get_y&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_y", "od")</e></m></meta>
		</nme_display_object_get_y>
		<nme_display_object_set_y expr="PrimeLoader.load(&quot;nme_display_object_set_y&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_y", "odv")</e></m></meta>
		</nme_display_object_set_y>
		<nme_display_object_get_scale_x expr="PrimeLoader.load(&quot;nme_display_object_get_scale_x&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_scale_x", "od")</e></m></meta>
		</nme_display_object_get_scale_x>
		<nme_display_object_set_scale_x expr="PrimeLoader.load(&quot;nme_display_object_set_scale_x&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_scale_x", "odv")</e></m></meta>
		</nme_display_object_set_scale_x>
		<nme_display_object_get_scale_y expr="PrimeLoader.load(&quot;nme_display_object_get_scale_y&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_scale_y", "od")</e></m></meta>
		</nme_display_object_get_scale_y>
		<nme_display_object_set_scale_y expr="PrimeLoader.load(&quot;nme_display_object_set_scale_y&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_scale_y", "odv")</e></m></meta>
		</nme_display_object_set_scale_y>
		<nme_display_object_get_mouse_x expr="PrimeLoader.load(&quot;nme_display_object_get_mouse_x&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_mouse_x", "od")</e></m></meta>
		</nme_display_object_get_mouse_x>
		<nme_display_object_get_mouse_y expr="PrimeLoader.load(&quot;nme_display_object_get_mouse_y&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_mouse_y", "od")</e></m></meta>
		</nme_display_object_get_mouse_y>
		<nme_display_object_get_rotation expr="PrimeLoader.load(&quot;nme_display_object_get_rotation&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_rotation", "od")</e></m></meta>
		</nme_display_object_get_rotation>
		<nme_display_object_set_rotation expr="PrimeLoader.load(&quot;nme_display_object_set_rotation&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_rotation", "odv")</e></m></meta>
		</nme_display_object_set_rotation>
		<nme_display_object_get_bg expr="PrimeLoader.load(&quot;nme_display_object_get_bg&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_bg", "oi")</e></m></meta>
		</nme_display_object_get_bg>
		<nme_display_object_set_bg expr="PrimeLoader.load(&quot;nme_display_object_set_bg&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_bg", "oiv")</e></m></meta>
		</nme_display_object_set_bg>
		<nme_display_object_get_name expr="nme.Loader.load(&quot;nme_display_object_get_name&quot;, 1)" line="601" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_display_object_get_name", 1)</e></m></meta>
		</nme_display_object_get_name>
		<nme_display_object_set_name expr="nme.Loader.load(&quot;nme_display_object_set_name&quot;, 2)" line="603" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_display_object_set_name", 2)</e></m></meta>
		</nme_display_object_set_name>
		<nme_display_object_get_width expr="PrimeLoader.load(&quot;nme_display_object_get_width&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_width", "od")</e></m></meta>
		</nme_display_object_get_width>
		<nme_display_object_set_width expr="PrimeLoader.load(&quot;nme_display_object_set_width&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_width", "odv")</e></m></meta>
		</nme_display_object_set_width>
		<nme_display_object_get_height expr="PrimeLoader.load(&quot;nme_display_object_get_height&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_height", "od")</e></m></meta>
		</nme_display_object_get_height>
		<nme_display_object_set_height expr="PrimeLoader.load(&quot;nme_display_object_set_height&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_height", "odv")</e></m></meta>
		</nme_display_object_set_height>
		<nme_display_object_get_alpha expr="PrimeLoader.load(&quot;nme_display_object_get_alpha&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_alpha", "od")</e></m></meta>
		</nme_display_object_get_alpha>
		<nme_display_object_set_alpha expr="PrimeLoader.load(&quot;nme_display_object_set_alpha&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_alpha", "odv")</e></m></meta>
		</nme_display_object_set_alpha>
		<nme_display_object_get_blend_mode expr="PrimeLoader.load(&quot;nme_display_object_get_blend_mode&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_blend_mode", "oi")</e></m></meta>
		</nme_display_object_get_blend_mode>
		<nme_display_object_set_blend_mode expr="PrimeLoader.load(&quot;nme_display_object_set_blend_mode&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_blend_mode", "oiv")</e></m></meta>
		</nme_display_object_set_blend_mode>
		<nme_display_object_get_cache_as_bitmap expr="PrimeLoader.load(&quot;nme_display_object_get_cache_as_bitmap&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_cache_as_bitmap", "ob")</e></m></meta>
		</nme_display_object_get_cache_as_bitmap>
		<nme_display_object_set_cache_as_bitmap expr="PrimeLoader.load(&quot;nme_display_object_set_cache_as_bitmap&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_cache_as_bitmap", "obv")</e></m></meta>
		</nme_display_object_set_cache_as_bitmap>
		<nme_display_object_get_pedantic_bitmap_caching expr="PrimeLoader.load(&quot;nme_display_object_get_pedantic_bitmap_caching&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_pedantic_bitmap_caching", "ob")</e></m></meta>
		</nme_display_object_get_pedantic_bitmap_caching>
		<nme_display_object_set_pedantic_bitmap_caching expr="PrimeLoader.load(&quot;nme_display_object_set_pedantic_bitmap_caching&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_pedantic_bitmap_caching", "obv")</e></m></meta>
		</nme_display_object_set_pedantic_bitmap_caching>
		<nme_display_object_get_pixel_snapping expr="PrimeLoader.load(&quot;nme_display_object_get_pixel_snapping&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_pixel_snapping", "oi")</e></m></meta>
		</nme_display_object_get_pixel_snapping>
		<nme_display_object_set_pixel_snapping expr="PrimeLoader.load(&quot;nme_display_object_set_pixel_snapping&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_pixel_snapping", "oiv")</e></m></meta>
		</nme_display_object_set_pixel_snapping>
		<nme_display_object_get_visible expr="PrimeLoader.load(&quot;nme_display_object_get_visible&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_visible", "ob")</e></m></meta>
		</nme_display_object_get_visible>
		<nme_display_object_set_visible expr="PrimeLoader.load(&quot;nme_display_object_set_visible&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_visible", "obv")</e></m></meta>
		</nme_display_object_set_visible>
		<nme_display_object_set_filters expr="PrimeLoader.load(&quot;nme_display_object_set_filters&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_filters", "oov")</e></m></meta>
		</nme_display_object_set_filters>
		<nme_display_object_global_to_local expr="PrimeLoader.load(&quot;nme_display_object_global_to_local&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_global_to_local", "oov")</e></m></meta>
		</nme_display_object_global_to_local>
		<nme_display_object_local_to_global expr="PrimeLoader.load(&quot;nme_display_object_local_to_global&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_local_to_global", "oov")</e></m></meta>
		</nme_display_object_local_to_global>
		<nme_display_object_set_scale9_grid expr="PrimeLoader.load(&quot;nme_display_object_set_scale9_grid&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_scale9_grid", "oov")</e></m></meta>
		</nme_display_object_set_scale9_grid>
		<nme_display_object_set_scroll_rect expr="PrimeLoader.load(&quot;nme_display_object_set_scroll_rect&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_scroll_rect", "oov")</e></m></meta>
		</nme_display_object_set_scroll_rect>
		<nme_display_object_set_mask expr="PrimeLoader.load(&quot;nme_display_object_set_mask&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_mask", "oov")</e></m></meta>
		</nme_display_object_set_mask>
		<nme_display_object_set_matrix expr="PrimeLoader.load(&quot;nme_display_object_set_matrix&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_matrix", "oov")</e></m></meta>
		</nme_display_object_set_matrix>
		<nme_display_object_get_matrix expr="PrimeLoader.load(&quot;nme_display_object_get_matrix&quot;, &quot;oobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_matrix", "oobv")</e></m></meta>
		</nme_display_object_get_matrix>
		<nme_display_object_get_color_transform expr="PrimeLoader.load(&quot;nme_display_object_get_color_transform&quot;, &quot;oobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_color_transform", "oobv")</e></m></meta>
		</nme_display_object_get_color_transform>
		<nme_display_object_set_color_transform expr="PrimeLoader.load(&quot;nme_display_object_set_color_transform&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_color_transform", "oov")</e></m></meta>
		</nme_display_object_set_color_transform>
		<nme_display_object_get_pixel_bounds expr="PrimeLoader.load(&quot;nme_display_object_get_pixel_bounds&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_pixel_bounds", "oov")</e></m></meta>
		</nme_display_object_get_pixel_bounds>
		<nme_display_object_get_bounds expr="PrimeLoader.load(&quot;nme_display_object_get_bounds&quot;, &quot;ooobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_bounds", "ooobv")</e></m></meta>
		</nme_display_object_get_bounds>
		<nme_display_object_hit_test_point expr="PrimeLoader.load(&quot;nme_display_object_hit_test_point&quot;, &quot;oddbbb&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_hit_test_point", "oddbbb")</e></m></meta>
		</nme_display_object_hit_test_point>
		<nme_display_object_get_hit_enabled expr="PrimeLoader.load(&quot;nme_display_object_get_hit_enabled&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_get_hit_enabled", "ob")</e></m></meta>
		</nme_display_object_get_hit_enabled>
		<nme_display_object_set_hit_enabled expr="PrimeLoader.load(&quot;nme_display_object_set_hit_enabled&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_display_object_set_hit_enabled", "obv")</e></m></meta>
		</nme_display_object_set_hit_enabled>
		<nme_doc_add_child expr="PrimeLoader.load(&quot;nme_doc_add_child&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_add_child", "oov")</e></m></meta>
		</nme_doc_add_child>
		<nme_display_object_encode expr="nme.PrimeLoader.load(&quot;nme_display_object_encode&quot;, &quot;oio&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_display_object_encode", "oio")</e></m></meta>
		</nme_display_object_encode>
		<nme_display_object_decode expr="nme.PrimeLoader.load(&quot;nme_display_object_decode&quot;, &quot;oio&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_display_object_decode", "oio")</e></m></meta>
		</nme_display_object_decode>
		<alpha public="1" get="accessor" set="accessor"><x path="Float"/></alpha>
		<blendMode public="1" get="accessor" set="accessor"><e path="nme.display.BlendMode"/></blendMode>
		<cacheAsBitmap public="1" get="accessor" set="accessor"><x path="Bool"/></cacheAsBitmap>
		<pedanticBitmapCaching public="1" get="accessor" set="accessor"><x path="Bool"/></pedanticBitmapCaching>
		<pixelSnapping public="1" get="accessor" set="accessor"><e path="nme.display.PixelSnapping"/></pixelSnapping>
		<filters public="1" get="accessor" set="accessor"><c path="Array"><d/></c></filters>
		<graphics public="1" get="accessor" set="null"><c path="nme.display.Graphics"/></graphics>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<hitEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></hitEnabled>
		<loaderInfo public="1"><c path="nme.display.LoaderInfo"/></loaderInfo>
		<mask public="1" set="accessor"><c path="nme.display.DisplayObject"/></mask>
		<mouseX public="1" get="accessor" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Float"/></mouseY>
		<name public="1" get="accessor" set="accessor"><c path="String"/></name>
		<opaqueBackground public="1" get="accessor" set="accessor"><x path="Null"><x path="Int"/></x></opaqueBackground>
		<parent public="1" get="accessor" set="null"><c path="nme.display.DisplayObjectContainer"/></parent>
		<rotation public="1" get="accessor" set="accessor"><x path="Float"/></rotation>
		<scale9Grid public="1" get="accessor" set="accessor"><c path="nme.geom.Rectangle"/></scale9Grid>
		<scaleX public="1" get="accessor" set="accessor"><x path="Float"/></scaleX>
		<scaleY public="1" get="accessor" set="accessor"><x path="Float"/></scaleY>
		<scrollRect public="1" get="accessor" set="accessor"><c path="nme.geom.Rectangle"/></scrollRect>
		<stage public="1" get="accessor" set="null"><c path="nme.display.Stage"/></stage>
		<transform public="1" get="accessor" set="accessor"><c path="nme.geom.Transform"/></transform>
		<visible public="1" get="accessor" set="accessor"><x path="Bool"/></visible>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<nmeHandle public="1">
			<t path="nme.NativeHandle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<nmeFilters>
			<c path="Array"><d/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeFilters>
		<nmeGraphicsCache>
			<c path="nme.display.Graphics"/>
			<haxe_doc>@private</haxe_doc>
		</nmeGraphicsCache>
		<nmeID>
			<x path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</nmeID>
		<nmeParent>
			<c path="nme.display.DisplayObjectContainer"/>
			<haxe_doc>@private</haxe_doc>
		</nmeParent>
		<nmeScale9Grid>
			<c path="nme.geom.Rectangle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeScale9Grid>
		<nmeScrollRect>
			<c path="nme.geom.Rectangle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeScrollRect>
		<dispatchEvent public="1" set="method" line="68" override="1"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<get_hitEnabled set="method" line="84"><f a=""><x path="Bool"/></f></get_hitEnabled>
		<set_hitEnabled set="method" line="85"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hitEnabled>
		<getBounds public="1" set="method" line="91"><f a="targetCoordinateSpace">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method" line="98"><f a="targetCoordinateSpace">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method" line="105"><f a="inGlobal">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></globalToLocal>
		<hitTestObject public="1" set="method" line="112"><f a="object">
	<c path="nme.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method" line="136">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<localToGlobal public="1" set="method" line="141"><f a="inLocal">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></localToGlobal>
		<encodeDisplay public="1" set="method" line="148">
			<f a="?inFlags" v="0">
				<x path="Int"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>{ inFlags : 0 }</e></m></meta>
		</encodeDisplay>
		<nmeAsInteractiveObject set="method" line="162">
			<f a=""><c path="nme.display.InteractiveObject"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeAsInteractiveObject>
		<nmeBroadcast public="1" set="method" line="166">
			<f a="inEvt">
				<c path="nme.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeBroadcast>
		<nmeDispatchEvent public="1" set="method" line="170">
			<f a="inEvt">
				<c path="nme.events.Event"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDispatchEvent>
		<nmeDrawToSurface public="1" set="method" line="180">
			<f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
				<d/>
				<c path="nme.geom.Matrix"/>
				<c path="nme.geom.ColorTransform"/>
				<c path="String"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDrawToSurface>
		<nmeFindByID set="method" line="185">
			<f a="inID">
				<x path="Int"/>
				<c path="nme.display.DisplayObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFindByID>
		<nmeFireEvent set="method" line="191">
			<f a="inEvt">
				<c path="nme.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFireEvent>
		<nmeGetColorTransform public="1" set="method" line="240">
			<f a=""><c path="nme.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetColorTransform>
		<nmeGetConcatenatedColorTransform public="1" set="method" line="246">
			<f a=""><c path="nme.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedColorTransform>
		<nmeGetConcatenatedMatrix public="1" set="method" line="252">
			<f a=""><c path="nme.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedMatrix>
		<nmeGetInteractiveObjectStack public="1" set="method" line="258">
			<f a="outStack">
				<c path="Array"><c path="nme.display.InteractiveObject"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetInteractiveObjectStack>
		<nmeGetMatrix public="1" set="method" line="268">
			<f a=""><c path="nme.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMatrix>
		<nmeGetObjectsUnderPoint public="1" set="method" line="274">
			<f a="point:result">
				<c path="nme.geom.Point"/>
				<c path="Array"><c path="nme.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetObjectsUnderPoint>
		<nmeGetPixelBounds public="1" set="method" line="279">
			<f a=""><c path="nme.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPixelBounds>
		<nmeOnAdded set="method" line="285">
			<f a="inObj:inIsOnStage">
				<c path="nme.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnAdded>
		<nmeOnRemoved set="method" line="301">
			<f a="inObj:inWasOnStage">
				<c path="nme.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnRemoved>
		<nmeSetColorTransform public="1" set="method" line="317">
			<f a="inTrans">
				<c path="nme.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetColorTransform>
		<nmeSetMatrix public="1" set="method" line="321">
			<f a="inMatrix">
				<c path="nme.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMatrix>
		<nmeSetParent public="1" set="method" line="325">
			<f a="inParent">
				<c path="nme.display.DisplayObjectContainer"/>
				<c path="nme.display.DisplayObjectContainer"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetParent>
		<toString public="1" set="method" line="356" override="1"><f a=""><c path="String"/></f></toString>
		<get_alpha set="method" line="362"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha set="method" line="363"><f a="inAlpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<get_opaqueBackground set="method" line="369"><f a=""><x path="Null"><x path="Int"/></x></f></get_opaqueBackground>
		<set_opaqueBackground set="method" line="378"><f a="inBG">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_opaqueBackground>
		<get_blendMode set="method" line="388"><f a=""><e path="nme.display.BlendMode"/></f></get_blendMode>
		<set_blendMode set="method" line="394"><f a="inMode">
	<e path="nme.display.BlendMode"/>
	<e path="nme.display.BlendMode"/>
</f></set_blendMode>
		<get_cacheAsBitmap set="method" line="400"><f a=""><x path="Bool"/></f></get_cacheAsBitmap>
		<set_cacheAsBitmap set="method" line="401"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmap>
		<get_pedanticBitmapCaching set="method" line="407"><f a=""><x path="Bool"/></f></get_pedanticBitmapCaching>
		<set_pedanticBitmapCaching set="method" line="408"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pedanticBitmapCaching>
		<get_pixelSnapping set="method" line="414"><f a=""><e path="nme.display.PixelSnapping"/></f></get_pixelSnapping>
		<set_pixelSnapping set="method" line="420"><f a="inVal">
	<e path="nme.display.PixelSnapping"/>
	<e path="nme.display.PixelSnapping"/>
</f></set_pixelSnapping>
		<get_filters set="method" line="434"><f a=""><c path="Array"><d/></c></f></get_filters>
		<set_filters set="method" line="446"><f a="inFilters">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_filters>
		<get_graphics set="method" line="465"><f a=""><c path="nme.display.Graphics"/></f></get_graphics>
		<get_height set="method" line="473"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="474"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_mask set="method" line="480"><f a="inObject">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.display.DisplayObject"/>
</f></set_mask>
		<get_mouseX set="method" line="487"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="488"><f a=""><x path="Float"/></f></get_mouseY>
		<get_name set="method" line="490"><f a=""><c path="String"/></f></get_name>
		<set_name set="method" line="491"><f a="inVal">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<get_parent set="method" line="497"><f a=""><c path="nme.display.DisplayObjectContainer"/></f></get_parent>
		<get_rotation set="method" line="499"><f a=""><x path="Float"/></f></get_rotation>
		<set_rotation set="method" line="500"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_scale9Grid set="method" line="506"><f a=""><c path="nme.geom.Rectangle"/></f></get_scale9Grid>
		<set_scale9Grid set="method" line="507"><f a="inRect">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></set_scale9Grid>
		<get_scaleX set="method" line="514"><f a=""><x path="Float"/></f></get_scaleX>
		<set_scaleX set="method" line="515"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<get_scaleY set="method" line="521"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleY set="method" line="522"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<get_scrollRect set="method" line="528"><f a=""><c path="nme.geom.Rectangle"/></f></get_scrollRect>
		<set_scrollRect set="method" line="529"><f a="inRect">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></set_scrollRect>
		<get_stage set="method" line="536"><f a=""><c path="nme.display.Stage"/></f></get_stage>
		<get_transform set="method" line="544"><f a=""><c path="nme.geom.Transform"/></f></get_transform>
		<set_transform set="method" line="545"><f a="inTransform">
	<c path="nme.geom.Transform"/>
	<c path="nme.geom.Transform"/>
</f></set_transform>
		<get_visible set="method" line="552"><f a=""><x path="Bool"/></f></get_visible>
		<set_visible set="method" line="553"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<get_width set="method" line="559"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="560"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_x set="method" line="566"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="567"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y set="method" line="573"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="574"><f a="inVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<new public="1" set="method" line="56"><f a="inHandle:inType">
	<t path="nme.NativeHandle"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.Bitmap" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Bitmap.hx">
		<extends path="nme.display.DisplayObject"/>
		<bitmapData public="1" set="accessor"><c path="nme.display.BitmapData"/></bitmapData>
		<smoothing public="1" set="accessor"><x path="Bool"/></smoothing>
		<mGraphics><c path="nme.display.Graphics"/></mGraphics>
		<nmeRebuild set="method" line="32"><f a=""><x path="Void"/></f></nmeRebuild>
		<set_bitmapData set="method" line="49"><f a="inBitmapData">
	<c path="nme.display.BitmapData"/>
	<c path="nme.display.BitmapData"/>
</f></set_bitmapData>
		<set_smoothing set="method" line="57"><f a="inSmooth">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_smoothing>
		<new public="1" set="method" line="15">
			<f a="?bitmapData:?pixelSnapping:?smoothing" v="null:null:false">
				<c path="nme.display.BitmapData"/>
				<e path="nme.display.PixelSnapping"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, pixelSnapping : null, bitmapData : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.BitmapData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/BitmapData.hx">
		<implements path="nme.display.IBitmapDrawable"/>
		<PNG public="1" get="inline" set="null" expr="&quot;png&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"png"</e></m></meta>
		</PNG>
		<JPG public="1" get="inline" set="null" expr="&quot;jpg&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"jpg"</e></m></meta>
		</JPG>
		<TRANSPARENT public="1" expr="0x0001" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</TRANSPARENT>
		<HARDWARE public="1" expr="0x0002" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</HARDWARE>
		<FLAG_NOREPEAT_NONPOT public="1" expr="0x0001" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</FLAG_NOREPEAT_NONPOT>
		<FLAG_FIXED_FORMAT public="1" expr="0x0002" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</FLAG_FIXED_FORMAT>
		<FLAG_MIPMAPS public="1" expr="0x0004" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</FLAG_MIPMAPS>
		<CHANNEL_RED public="1" get="inline" set="null" expr="0x0001" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</CHANNEL_RED>
		<CHANNEL_GREEN public="1" get="inline" set="null" expr="0x0002" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</CHANNEL_GREEN>
		<CHANNEL_BLUE public="1" get="inline" set="null" expr="0x0004" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</CHANNEL_BLUE>
		<CHANNEL_ALPHA public="1" get="inline" set="null" expr="0x0008" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</CHANNEL_ALPHA>
		<FLOAT_UNSCALED public="1" get="inline" set="null" expr="0x0000" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</FLOAT_UNSCALED>
		<FLOAT_ZERO_MEAN public="1" get="inline" set="null" expr="0x0001" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</FLOAT_ZERO_MEAN>
		<FLOAT_128_MEAN public="1" get="inline" set="null" expr="0x0002" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</FLOAT_128_MEAN>
		<FLOAT_UNIT_SCALE public="1" get="inline" set="null" expr="0x0004" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</FLOAT_UNIT_SCALE>
		<FLOAT_STD_SCALE public="1" get="inline" set="null" expr="0x0008" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</FLOAT_STD_SCALE>
		<FLOAT_SWIZZLE_RGB public="1" get="inline" set="null" expr="0x0010" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</FLOAT_SWIZZLE_RGB>
		<FLOAT_100_SCALE public="1" get="inline" set="null" expr="0x0020" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</FLOAT_100_SCALE>
		<FLOAT_NORM public="1" get="inline" set="null" expr="0x0009" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0009</e></m></meta>
		</FLOAT_NORM>
		<FLOAT_EXPAND public="1" get="inline" set="null" expr="0x0006" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0006</e></m></meta>
		</FLOAT_EXPAND>
		<CLEAR public="1" expr="createColor(0, 0)" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0, 0)</e></m></meta>
		</CLEAR>
		<BLACK public="1" expr="createColor(0x000000)" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0x000000)</e></m></meta>
		</BLACK>
		<WHITE public="1" expr="createColor(0x000000)" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0x000000)</e></m></meta>
		</WHITE>
		<RED public="1" expr="createColor(0xff0000)" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0xff0000)</e></m></meta>
		</RED>
		<GREEN public="1" expr="createColor(0x00ff00)" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0x00ff00)</e></m></meta>
		</GREEN>
		<BLUE public="1" expr="createColor(0x0000ff)" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>createColor(0x0000ff)</e></m></meta>
		</BLUE>
		<defaultPremultiplied public="1" expr="true" line="59" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</defaultPremultiplied>
		<defaultMipmaps public="1" expr="false" line="60" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</defaultMipmaps>
		<createPremultiplied public="1" set="method" line="104" static="1">
			<f a="width:height:?inArgb" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ inArgb : 0 }</e></m></meta>
		</createPremultiplied>
		<createGrey public="1" set="method" line="109" static="1"><f a="width:height:?inLuma">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="nme.display.BitmapData"/>
</f></createGrey>
		<createAlpha public="1" set="method" line="114" static="1">
			<f a="width:height:?inAlpha" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ inAlpha : 0 }</e></m></meta>
		</createAlpha>
		<createUInt16 public="1" set="method" line="121" static="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nme.display.BitmapData"/>
</f></createUInt16>
		<createUInt32 public="1" set="method" line="127" static="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nme.display.BitmapData"/>
</f></createUInt32>
		<createColor public="1" get="inline" set="null" line="418" static="1">
			<f a="inRGB:?inAlpha" v=":0xFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ inAlpha : 0xFF }</e></m></meta>
		</createColor>
		<extractAlpha public="1" get="inline" set="null" line="431" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></extractAlpha>
		<extractColor public="1" get="inline" set="null" line="433" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></extractColor>
		<sameValue get="inline" set="null" line="436" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></sameValue>
		<flip_pixel4 public="1" get="inline" set="null" line="447" static="1">
			<f a="pix4">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Flips an ARGB pixel value to BGRA or vice-versa
    * @param	pix4 a 4-byte pixel value in AARRGGBB or BBGGRRAA format
    * @return   pix4 flipped-endian format</haxe_doc>
		</flip_pixel4>
		<ucompare public="1" set="method" line="564" static="1">
			<f a="n1:n2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Compare 2 integers, byte-for-byte (unsigned mode)
	 * @param	n1	an integer
	 * @param	n2	another integer
	 * @return	0 if n1 == n2, 1 if n1 > n2, -1 if n1 < n2]]></haxe_doc>
		</ucompare>
		<getRGBAPixels public="1" set="method" line="682" static="1"><f a="bitmapData">
	<c path="nme.display.BitmapData"/>
	<c path="nme.utils.ByteArray"/>
</f></getRGBAPixels>
		<load public="1" set="method" line="703" static="1">
			<f a="inFilename:?format" v=":-1">
				<c path="String"/>
				<x path="Int"/>
				<c path="nme.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ format : -1 }</e></m></meta>
		</load>
		<loadFromBytes public="1" set="method" line="728" static="1"><f a="inBytes:?inRawAlpha">
	<c path="nme.utils.ByteArray"/>
	<c path="nme.utils.ByteArray"/>
	<c path="nme.display.BitmapData"/>
</f></loadFromBytes>
		<loadFromHaxeBytes public="1" set="method" line="739" static="1"><f a="inBytes:?inRawAlpha">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<c path="nme.display.BitmapData"/>
</f></loadFromHaxeBytes>
		<nme_bitmap_data_apply_filter expr="PrimeLoader.load(&quot;nme_bitmap_data_apply_filter&quot;, &quot;ooooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_apply_filter", "ooooov")</e></m></meta>
		</nme_bitmap_data_apply_filter>
		<nme_bitmap_data_generate_filter_rect expr="PrimeLoader.load(&quot;nme_bitmap_data_generate_filter_rect&quot;, &quot;ooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_generate_filter_rect", "ooov")</e></m></meta>
		</nme_bitmap_data_generate_filter_rect>
		<nme_bitmap_data_create expr="PrimeLoader.load(&quot;nme_bitmap_data_create&quot;, &quot;iiiibo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_create", "iiiibo")</e></m></meta>
		</nme_bitmap_data_create>
		<nme_bitmap_data_load expr="nme.Loader.load(&quot;nme_bitmap_data_load&quot;, 2)" line="763" static="1">
			<f a=":">
				<c path="String"/>
				<x path="Int"/>
				<t path="nme.NativeHandle"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_bitmap_data_load", 2)</e></m></meta>
		</nme_bitmap_data_load>
		<nme_bitmap_data_from_bytes expr="PrimeLoader.load(&quot;nme_bitmap_data_from_bytes&quot;, &quot;ooo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_from_bytes", "ooo")</e></m></meta>
		</nme_bitmap_data_from_bytes>
		<nme_bitmap_data_clear expr="PrimeLoader.load(&quot;nme_bitmap_data_clear&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_clear", "oiv")</e></m></meta>
		</nme_bitmap_data_clear>
		<nme_bitmap_data_clone expr="PrimeLoader.load(&quot;nme_bitmap_data_clone&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_clone", "oo")</e></m></meta>
		</nme_bitmap_data_clone>
		<nme_bitmap_data_color_transform expr="PrimeLoader.load(&quot;nme_bitmap_data_color_transform&quot;, &quot;ooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_color_transform", "ooov")</e></m></meta>
		</nme_bitmap_data_color_transform>
		<nme_bitmap_data_copy expr="PrimeLoader.load(&quot;nme_bitmap_data_copy&quot;, &quot;oooobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_copy", "oooobv")</e></m></meta>
		</nme_bitmap_data_copy>
		<nme_bitmap_data_copy_channel expr="PrimeLoader.load(&quot;nme_bitmap_data_copy_channel&quot;, &quot;ooooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_copy_channel", "ooooiiv")</e></m></meta>
		</nme_bitmap_data_copy_channel>
		<nme_bitmap_data_fill expr="PrimeLoader.load(&quot;nme_bitmap_data_fill&quot;, &quot;ooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_fill", "ooiiv")</e></m></meta>
		</nme_bitmap_data_fill>
		<nme_bitmap_data_get_pixels expr="PrimeLoader.load(&quot;nme_bitmap_data_get_pixels&quot;, &quot;ooo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_pixels", "ooo")</e></m></meta>
		</nme_bitmap_data_get_pixels>
		<nme_bitmap_data_get_pixel expr="PrimeLoader.load(&quot;nme_bitmap_data_get_pixel&quot;, &quot;oiii&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_pixel", "oiii")</e></m></meta>
		</nme_bitmap_data_get_pixel>
		<nme_bitmap_data_get_pixel32 expr="PrimeLoader.load(&quot;nme_bitmap_data_get_pixel32&quot;, &quot;oiii&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_pixel32", "oiii")</e></m></meta>
		</nme_bitmap_data_get_pixel32>
		<nme_bitmap_data_get_array expr="PrimeLoader.load(&quot;nme_bitmap_data_get_array&quot;, &quot;ooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_array", "ooov")</e></m></meta>
		</nme_bitmap_data_get_array>
		<nme_bitmap_data_get_color_bounds_rect expr="PrimeLoader.load(&quot;nme_bitmap_data_get_color_bounds_rect&quot;, &quot;oiibov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_color_bounds_rect", "oiibov")</e></m></meta>
		</nme_bitmap_data_get_color_bounds_rect>
		<nme_bitmap_data_scroll expr="PrimeLoader.load(&quot;nme_bitmap_data_scroll&quot;, &quot;oiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_scroll", "oiiv")</e></m></meta>
		</nme_bitmap_data_scroll>
		<nme_bitmap_data_set_pixel expr="PrimeLoader.load(&quot;nme_bitmap_data_set_pixel&quot;, &quot;oiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_pixel", "oiiiv")</e></m></meta>
		</nme_bitmap_data_set_pixel>
		<nme_bitmap_data_set_pixel32 expr="PrimeLoader.load(&quot;nme_bitmap_data_set_pixel32&quot;, &quot;oiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_pixel32", "oiiiv")</e></m></meta>
		</nme_bitmap_data_set_pixel32>
		<nme_bitmap_data_set_bytes expr="PrimeLoader.load(&quot;nme_bitmap_data_set_bytes&quot;, &quot;oooiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_bytes", "oooiv")</e></m></meta>
		</nme_bitmap_data_set_bytes>
		<nme_bitmap_data_set_format expr="PrimeLoader.load(&quot;nme_bitmap_data_set_format&quot;, &quot;oibv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_format", "oibv")</e></m></meta>
		</nme_bitmap_data_set_format>
		<nme_bitmap_data_get_format expr="PrimeLoader.load(&quot;nme_bitmap_data_get_format&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_format", "oi")</e></m></meta>
		</nme_bitmap_data_get_format>
		<nme_bitmap_data_set_array expr="PrimeLoader.load(&quot;nme_bitmap_data_set_array&quot;, &quot;ooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_array", "ooov")</e></m></meta>
		</nme_bitmap_data_set_array>
		<nme_bitmap_data_create_hardware_surface expr="PrimeLoader.load(&quot;nme_bitmap_data_create_hardware_surface&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_create_hardware_surface", "ov")</e></m></meta>
		</nme_bitmap_data_create_hardware_surface>
		<nme_bitmap_data_destroy_hardware_surface expr="PrimeLoader.load(&quot;nme_bitmap_data_destroy_hardware_surface&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_destroy_hardware_surface", "ov")</e></m></meta>
		</nme_bitmap_data_destroy_hardware_surface>
		<nme_render_surface_to_surface expr="PrimeLoader.load(&quot;nme_render_surface_to_surface&quot;, &quot;ooooiobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_render_surface_to_surface", "ooooiobv")</e></m></meta>
		</nme_render_surface_to_surface>
		<nme_bitmap_data_height expr="PrimeLoader.load(&quot;nme_bitmap_data_height&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_height", "oi")</e></m></meta>
		</nme_bitmap_data_height>
		<nme_bitmap_data_width expr="PrimeLoader.load(&quot;nme_bitmap_data_width&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_width", "oi")</e></m></meta>
		</nme_bitmap_data_width>
		<nme_bitmap_data_get_transparent expr="PrimeLoader.load(&quot;nme_bitmap_data_get_transparent&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_transparent", "ob")</e></m></meta>
		</nme_bitmap_data_get_transparent>
		<nme_bitmap_data_set_flags expr="PrimeLoader.load(&quot;nme_bitmap_data_set_flags&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_flags", "oiv")</e></m></meta>
		</nme_bitmap_data_set_flags>
		<nme_bitmap_data_get_flags expr="PrimeLoader.load(&quot;nme_bitmap_data_get_flags&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_flags", "oi")</e></m></meta>
		</nme_bitmap_data_get_flags>
		<nme_bitmap_data_encode expr="nme.Loader.load(&quot;nme_bitmap_data_encode&quot;, 3)" line="798" static="1">
			<f a="::">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
				<x path="Float"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_bitmap_data_encode", 3)</e></m></meta>
		</nme_bitmap_data_encode>
		<nme_bitmap_data_dump_bits expr="PrimeLoader.load(&quot;nme_bitmap_data_dump_bits&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_dump_bits", "ov")</e></m></meta>
		</nme_bitmap_data_dump_bits>
		<nme_bitmap_data_dispose expr="PrimeLoader.load(&quot;nme_bitmap_data_dispose&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_dispose", "ov")</e></m></meta>
		</nme_bitmap_data_dispose>
		<nme_bitmap_data_noise expr="PrimeLoader.load(&quot;nme_bitmap_data_noise&quot;, &quot;oiiiibv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_noise", "oiiiibv")</e></m></meta>
		</nme_bitmap_data_noise>
		<nme_bitmap_data_flood_fill expr="PrimeLoader.load(&quot;nme_bitmap_data_flood_fill&quot;, &quot;oiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_flood_fill", "oiiiv")</e></m></meta>
		</nme_bitmap_data_flood_fill>
		<nme_bitmap_data_get_prem_alpha expr="PrimeLoader.load(&quot;nme_bitmap_data_get_prem_alpha&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_prem_alpha", "ob")</e></m></meta>
		</nme_bitmap_data_get_prem_alpha>
		<nme_bitmap_data_set_prem_alpha expr="PrimeLoader.load(&quot;nme_bitmap_data_set_prem_alpha&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_prem_alpha", "obv")</e></m></meta>
		</nme_bitmap_data_set_prem_alpha>
		<nme_bitmap_data_get_floats32 expr="PrimeLoader.load(&quot;nme_bitmap_data_get_floats32&quot;, &quot;ooiiiiiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_floats32", "ooiiiiiov")</e></m></meta>
		</nme_bitmap_data_get_floats32>
		<nme_bitmap_data_set_floats32 expr="PrimeLoader.load(&quot;nme_bitmap_data_set_floats32&quot;, &quot;ooiiiiiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_floats32", "ooiiiiiov")</e></m></meta>
		</nme_bitmap_data_set_floats32>
		<nme_bitmap_data_get_uints8 expr="PrimeLoader.load(&quot;nme_bitmap_data_get_uints8&quot;, &quot;ooiiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_get_uints8", "ooiiiiv")</e></m></meta>
		</nme_bitmap_data_get_uints8>
		<nme_bitmap_data_set_uints8 expr="PrimeLoader.load(&quot;nme_bitmap_data_set_uints8&quot;, &quot;ooiiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_bitmap_data_set_uints8", "ooiiiiv")</e></m></meta>
		</nme_bitmap_data_set_uints8>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<rect public="1" get="accessor" set="null"><c path="nme.geom.Rectangle"/></rect>
		<transparent public="1" get="accessor" set="null"><x path="Bool"/></transparent>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<format public="1" get="accessor" set="accessor"><x path="Int"/></format>
		<premultipliedAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></premultipliedAlpha>
		<nmeHandle public="1"><t path="nme.NativeHandle"/></nmeHandle>
		<data public="1" get="accessor" set="null"><c path="nme.utils.UInt8Array"/></data>
		<mipmaps public="1" get="accessor" set="accessor"><x path="Bool"/></mipmaps>
		<clear public="1" set="method" line="134"><f a="color">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<colorTransform public="1" set="method" line="139"><f a="rect:colorTransform">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="144"><f a="sourceBitmapData:sourceRect:destPoint:inSourceChannel:inDestChannel">
	<c path="nme.display.BitmapData"/>
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="149">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::::false">
				<c path="nme.display.BitmapData"/>
				<c path="nme.geom.Rectangle"/>
				<c path="nme.geom.Point"/>
				<c path="nme.display.BitmapData"/>
				<c path="nme.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false }</e></m></meta>
		</copyPixels>
		<createHardwareSurface public="1" set="method" line="155"><f a=""><x path="Void"/></f></createHardwareSurface>
		<destroyHardwareSurface public="1" set="method" line="160"><f a=""><x path="Void"/></f></destroyHardwareSurface>
		<dispose public="1" set="method" line="165"><f a=""><x path="Void"/></f></dispose>
		<dumpBits public="1" set="method" line="171"><f a=""><x path="Void"/></f></dumpBits>
		<encode public="1" set="method" line="176">
			<f a="inFormat:?inQuality" v=":0.9">
				<c path="String"/>
				<x path="Float"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>{ inQuality : 0.9 }</e></m></meta>
		</encode>
		<fillRect public="1" set="method" line="182"><f a="rect:inColour">
	<c path="nme.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<fillRectEx public="1" set="method" line="189">
			<f a="rect:inColour:?inAlpha" v="::255">
				<c path="nme.geom.Rectangle"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inAlpha : 255 }</e></m></meta>
		</fillRectEx>
		<floodFill public="1" set="method" line="195"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<getColorBoundsRect public="1" set="method" line="201">
			<f a="mask:color:?findColor" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="nme.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="208"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="213"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="218"><f a="?rect">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method" line="225"><f a="rect">
	<c path="nme.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
</f></getVector>
		<nmeDrawToSurface public="1" set="method" line="246"><f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
	<d/>
	<c path="nme.geom.Matrix"/>
	<c path="nme.geom.ColorTransform"/>
	<c path="String"/>
	<c path="nme.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></nmeDrawToSurface>
		<nmeLoadFromBytes get="inline" set="null" line="253"><f a="inBytes:?inRawAlpha">
	<c path="nme.utils.ByteArray"/>
	<c path="nme.utils.ByteArray"/>
	<x path="Void"/>
</f></nmeLoadFromBytes>
		<scroll public="1" set="method" line="258"><f a="inDX:inDY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setFlags public="1" set="method" line="263"><f a="inFlags">
	<x path="Int"/>
	<x path="Void"/>
</f></setFlags>
		<getFlags public="1" set="method" line="269"><f a=""><x path="Int"/></f></getFlags>
		<setPixel public="1" set="method" line="276"><f a="inX:inY:inColour">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="281"><f a="inX:inY:inColour">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="286"><f a="rect:pixels">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method" line="294"><f a="rect:inPixels">
	<c path="nme.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></setVector>
		<get_data public="1" set="method" line="311"><f a=""><c path="nme.utils.UInt8Array"/></f></get_data>
		<getUInts8 public="1" set="method" line="316">
			<f a="dataHandle:dataOffset:dataStride:pixelFormat:?subSample" v="::::1">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ subSample : 1 }</e></m></meta>
		</getUInts8>
		<setUInts8 public="1" set="method" line="322">
			<f a="dataHandle:dataOffset:dataStride:pixelFormat:?expand" v="::::1">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ expand : 1 }</e></m></meta>
		</setUInts8>
		<getFloats32 public="1" set="method" line="327">
			<f a="dataHandle:dataOffset:dataStride:pixelFormat:transform:?subSample:?subrect" v=":::::1:">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ subSample : 1 }</e></m></meta>
		</getFloats32>
		<setFloats32 public="1" set="method" line="334">
			<f a="dataHandle:dataOffset:dataStride:pixelFormat:transform:?expand:?subrect" v=":::::1:">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ expand : 1 }</e></m></meta>
		</setFloats32>
		<setFormat public="1" set="method" line="342">
			<f a="format:?inConvert" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inConvert : true }</e></m></meta>
		</setFormat>
		<set_format public="1" get="inline" set="null" line="347"><f a="format">
	<x path="Int"/>
	<x path="Int"/>
</f></set_format>
		<get_format public="1" set="method" line="353"><f a=""><x path="Int"/></f></get_format>
		<noise public="1" set="method" line="361">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7, high : 255, low : 0 }</e></m></meta>
		</noise>
		<get_rect set="method" line="367"><f a=""><c path="nme.geom.Rectangle"/></f></get_rect>
		<get_width set="method" line="368"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="369"><f a=""><x path="Int"/></f></get_height>
		<get_transparent set="method" line="370"><f a=""><x path="Bool"/></f></get_transparent>
		<get_premultipliedAlpha set="method" line="371"><f a=""><x path="Bool"/></f></get_premultipliedAlpha>
		<set_premultipliedAlpha set="method" line="372"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_premultipliedAlpha>
		<get_mipmaps set="method" line="377"><f a=""><x path="Bool"/></f></get_mipmaps>
		<set_mipmaps set="method" line="381"><f a="inMipmaps">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mipmaps>
		<applyFilter public="1" set="method" line="395"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="nme.display.BitmapData"/>
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Point"/>
	<c path="nme.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method" line="400"><f a=""><c path="nme.display.BitmapData"/></f></clone>
		<cloneRect public="1" set="method" line="408"><f a="x0:y0:inWidth:inHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="nme.display.BitmapData"/>
</f></cloneRect>
		<draw public="1" set="method" line="423">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":null:null:null:null:false">
				<c path="nme.display.IBitmapDrawable"/>
				<c path="nme.geom.Matrix"/>
				<c path="nme.geom.ColorTransform"/>
				<e path="nme.display.BlendMode"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, clipRect : null, blendMode : null, colorTransform : null, matrix : null }</e></m></meta>
		</draw>
		<unmultiplyAlpha public="1" get="inline" set="null" line="429"><f a=""><x path="Void"/></f></unmultiplyAlpha>
		<threshold public="1" set="method" line="467">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0x00000000:0xFFFFFFFF:false">
				<c path="nme.display.BitmapData"/>
				<c path="nme.geom.Rectangle"/>
				<c path="nme.geom.Point"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ copySource : false, mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
			<haxe_doc><![CDATA[* Tests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.
    * @param	sourceBitmapData input bitmap data. Source can be different BitmapData or can refer to current BitmapData. 
    * @param	sourceRect rectangle that defines area of source image to use as input. 
    * @param	destPoint point within destination image (current BitmapData) corresponding to upper-left corner of source rectangle. 
    * @param	operation one of these strings: "<", "<=", ">", ">=", "==", "!="
    * @param	threshold value each pixel is tested against to see if it meets or exceeds the threshhold.
    * @param	color color value a pixel is set to if threshold test succeeds.
    * @param	mask mask used to isolate a color component. 
    * @param	copySource If true, pixel values from source image are copied to destination when threshold test fails. If false, source image is not copied when threshold test fails.
    * @return]]></haxe_doc>
		</threshold>
		<_self_threshold public="1" set="method" line="627">
			<f a="operation:threshold:?color:?mask" v="::0x00000000:0xFFFFFFFF">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
			<haxe_doc>* Fast version for when you're not messing with multiple thingies
    * @param	operation
    * @param	threshold
    * @param	color
    * @param	mask
    * @param	copySource
    * @return</haxe_doc>
		</_self_threshold>
		<generateFilterRect public="1" set="method" line="675"><f a="sourceRect:filter">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.filters.BitmapFilter"/>
	<c path="nme.geom.Rectangle"/>
</f></generateFilterRect>
		<save public="1" set="method" line="716">
			<f a="inFilename:?inQuality" v=":0.9">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inQuality : 0.9 }</e></m></meta>
		</save>
		<lock public="1" set="method" line="744"><f a=""><x path="Void"/></f></lock>
		<unlock public="1" set="method" line="749"><f a="?changeRect">
	<c path="nme.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<toString public="1" set="method" line="754"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="73">
			<f a="inWidth:inHeight:?inTransparent:?inFillARGB:?inPixelFormat" v="::true::-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inPixelFormat : -1, inTransparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>nme.macros.Embed.embedAsset("NME_bitmap_", ":bitmap")</e></m>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<enum path="nme.display.BlendMode" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/BlendMode.hx">
		<NORMAL/>
		<LAYER/>
		<MULTIPLY/>
		<SCREEN/>
		<LIGHTEN/>
		<DARKEN/>
		<DIFFERENCE/>
		<ADD/>
		<SUBTRACT/>
		<INVERT/>
		<ALPHA/>
		<ERASE/>
		<OVERLAY/>
		<HARDLIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="nme.display.CapsStyle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/CapsStyle.hx">
		<ROUND/>
		<NONE/>
		<SQUARE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.display.InteractiveObject" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/InteractiveObject.hx">
		<extends path="nme.display.DisplayObject"/>
		<nme_display_object_set_mouse_enabled expr="Loader.load(&quot;nme_display_object_set_mouse_enabled&quot;, 2)" line="76" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_set_mouse_enabled", 2)</e></m></meta>
		</nme_display_object_set_mouse_enabled>
		<nme_display_object_set_needs_soft_keyboard expr="Loader.load(&quot;nme_display_object_set_needs_soft_keyboard&quot;, 2)" line="77" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_set_needs_soft_keyboard", 2)</e></m></meta>
		</nme_display_object_set_needs_soft_keyboard>
		<nme_display_object_get_needs_soft_keyboard expr="Loader.load(&quot;nme_display_object_get_needs_soft_keyboard&quot;, 1)" line="78" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_get_needs_soft_keyboard", 1)</e></m></meta>
		</nme_display_object_get_needs_soft_keyboard>
		<nme_display_object_set_moves_for_soft_keyboard expr="Loader.load(&quot;nme_display_object_set_moves_for_soft_keyboard&quot;, 2)" line="79" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_set_moves_for_soft_keyboard", 2)</e></m></meta>
		</nme_display_object_set_moves_for_soft_keyboard>
		<nme_display_object_get_moves_for_soft_keyboard expr="Loader.load(&quot;nme_display_object_get_moves_for_soft_keyboard&quot;, 1)" line="80" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_get_moves_for_soft_keyboard", 1)</e></m></meta>
		</nme_display_object_get_moves_for_soft_keyboard>
		<nme_display_object_request_soft_keyboard expr="Loader.load(&quot;nme_display_object_request_soft_keyboard&quot;, 1)" line="81" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_request_soft_keyboard", 1)</e></m></meta>
		</nme_display_object_request_soft_keyboard>
		<nme_display_object_set_soft_keyboard expr="Loader.load(&quot;nme_display_object_set_soft_keyboard&quot;, 2)" line="82" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_set_soft_keyboard", 2)</e></m></meta>
		</nme_display_object_set_soft_keyboard>
		<nme_display_object_get_soft_keyboard expr="Loader.load(&quot;nme_display_object_get_soft_keyboard&quot;, 1)" line="83" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_display_object_get_soft_keyboard", 1)</e></m></meta>
		</nme_display_object_get_soft_keyboard>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<mouseEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></mouseEnabled>
		<moveForSoftKeyboard public="1" get="accessor" set="accessor"><x path="Bool"/></moveForSoftKeyboard>
		<needsSoftKeyboard public="1" get="accessor" set="accessor"><x path="Bool"/></needsSoftKeyboard>
		<softKeyboard public="1" get="accessor" set="accessor"><x path="Int"/></softKeyboard>
		<nmeMouseEnabled>
			<x path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeMouseEnabled>
		<nmeAsInteractiveObject set="method" line="24" override="1">
			<f a=""><c path="nme.display.InteractiveObject"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeAsInteractiveObject>
		<requestSoftKeyboard public="1" set="method" line="28"><f a=""><x path="Bool"/></f></requestSoftKeyboard>
		<get_mouseEnabled set="method" line="34"><f a=""><x path="Bool"/></f></get_mouseEnabled>
		<set_mouseEnabled set="method" line="35"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseEnabled>
		<set_moveForSoftKeyboard set="method" line="42"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moveForSoftKeyboard>
		<get_moveForSoftKeyboard set="method" line="48"><f a=""><x path="Bool"/></f></get_moveForSoftKeyboard>
		<set_needsSoftKeyboard set="method" line="53"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_needsSoftKeyboard>
		<get_needsSoftKeyboard set="method" line="59"><f a=""><x path="Bool"/></f></get_needsSoftKeyboard>
		<get_softKeyboard set="method" line="64"><f a=""><x path="Int"/></f></get_softKeyboard>
		<set_softKeyboard set="method" line="69"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_softKeyboard>
		<new public="1" set="method" line="16"><f a="inHandle:inType">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.display.DisplayObjectContainer" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/DisplayObjectContainer.hx">
		<extends path="nme.display.InteractiveObject"/>
		<nme_create_display_object_container expr="PrimeLoader.load(&quot;nme_create_display_object_container&quot;, &quot;o&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><t path="cpp.Object"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_create_display_object_container", "o")</e></m></meta>
		</nme_create_display_object_container>
		<nme_doc_add_child expr="PrimeLoader.load(&quot;nme_doc_add_child&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_add_child", "oov")</e></m></meta>
		</nme_doc_add_child>
		<nme_doc_remove_child expr="PrimeLoader.load(&quot;nme_doc_remove_child&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_remove_child", "oiv")</e></m></meta>
		</nme_doc_remove_child>
		<nme_doc_set_child_index expr="PrimeLoader.load(&quot;nme_doc_set_child_index&quot;, &quot;ooiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_set_child_index", "ooiv")</e></m></meta>
		</nme_doc_set_child_index>
		<nme_doc_get_mouse_children expr="PrimeLoader.load(&quot;nme_doc_get_mouse_children&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_get_mouse_children", "ob")</e></m></meta>
		</nme_doc_get_mouse_children>
		<nme_doc_set_mouse_children expr="PrimeLoader.load(&quot;nme_doc_set_mouse_children&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_set_mouse_children", "obv")</e></m></meta>
		</nme_doc_set_mouse_children>
		<nme_doc_swap_children expr="PrimeLoader.load(&quot;nme_doc_swap_children&quot;, &quot;ooov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_doc_swap_children", "ooov")</e></m></meta>
		</nme_doc_swap_children>
		<mouseChildren public="1" get="accessor" set="accessor"><x path="Bool"/></mouseChildren>
		<numChildren public="1" get="accessor" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1" get="accessor" set="accessor"><x path="Bool"/></tabChildren>
		<nmeChildren>
			<c path="Array"><c path="nme.display.DisplayObject"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeChildren>
		<addChild public="1" set="method" line="24"><f a="child">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method" line="30"><f a="child:index">
	<c path="nme.display.DisplayObject"/>
	<x path="Int"/>
	<c path="nme.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="37"><f a="point">
	<c path="nme.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="42"><f a="child">
	<c path="nme.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method" line="57"><f a="index">
	<x path="Int"/>
	<c path="nme.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method" line="68"><f a="name">
	<c path="String"/>
	<c path="nme.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method" line="76"><f a="child">
	<c path="nme.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="81"><f a="point">
	<c path="nme.geom.Point"/>
	<c path="Array"><c path="nme.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<nmeAddChild get="inline" set="null" line="88">
			<f a="child">
				<c path="nme.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeAddChild>
		<nmeBroadcast public="1" set="method" line="108" override="1">
			<f a="inEvt">
				<c path="nme.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeBroadcast>
		<nmeFindByID set="method" line="131" override="1">
			<f a="inID">
				<x path="Int"/>
				<c path="nme.display.DisplayObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFindByID>
		<nmeGetChildIndex set="method" line="146">
			<f a="child">
				<c path="nme.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetChildIndex>
		<nmeGetObjectsUnderPoint public="1" set="method" line="153" override="1">
			<f a="point:result">
				<c path="nme.geom.Point"/>
				<c path="Array"><c path="nme.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetObjectsUnderPoint>
		<nmeOnAdded set="method" line="160" override="1">
			<f a="inObj:inIsOnStage">
				<c path="nme.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnAdded>
		<nmeOnRemoved set="method" line="167" override="1">
			<f a="inObj:inWasOnStage">
				<c path="nme.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnRemoved>
		<nmeRemoveChildFromArray public="1" set="method" line="174">
			<f a="child">
				<c path="nme.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeRemoveChildFromArray>
		<nmeSetChildIndex get="inline" set="null" line="184">
			<f a="child:index">
				<c path="nme.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetChildIndex>
		<nmeSwapChildrenAt get="inline" set="null" line="244">
			<f a="index1:index2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSwapChildrenAt>
		<removeChild public="1" set="method" line="257"><f a="child">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="271"><f a="index">
	<x path="Int"/>
	<c path="nme.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="283">
			<f a="?beginIndex:?endIndex" v="0:0x7FFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 0x7FFFFFFF, beginIndex : 0 }</e></m></meta>
		</removeChildren>
		<setChildIndex public="1" set="method" line="304"><f a="child:index">
	<c path="nme.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method" line="309"><f a="child1:child2">
	<c path="nme.display.DisplayObject"/>
	<c path="nme.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method" line="318"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<get_mouseChildren set="method" line="324"><f a=""><x path="Bool"/></f></get_mouseChildren>
		<set_mouseChildren set="method" line="325"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseChildren>
		<get_numChildren set="method" line="331"><f a=""><x path="Int"/></f></get_numChildren>
		<get_tabChildren set="method" line="332"><f a=""><x path="Bool"/></f></get_tabChildren>
		<set_tabChildren set="method" line="333"><f a="inValue">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabChildren>
		<new public="1" set="method" line="18"><f a="inHandle:inType">
	<t path="nme.NativeHandle"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.FrameLabel" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/FrameLabel.hx">
		<extends path="nme.events.EventDispatcher"/>
		<frame public="1"><x path="Int"/></frame>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="8"><f a="inName:inFrame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="nme.display.GradientType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.display.Graphics" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Graphics.hx">
		<TILE_SCALE public="1" get="inline" set="null" expr="0x0001" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" expr="0x0002" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" expr="0x0004" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" expr="0x0008" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" expr="0x0010" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" expr="0x0020" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" expr="0x0040" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</TILE_ORIGIN>
		<TILE_NO_ID public="1" get="inline" set="null" expr="0x0080" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</TILE_NO_ID>
		<TILE_MOUSE_ENABLE public="1" get="inline" set="null" expr="0x0100" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
		</TILE_MOUSE_ENABLE>
		<TILE_FIXED_SIZE public="1" get="inline" set="null" expr="0x0200" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</TILE_FIXED_SIZE>
		<TILE_SMOOTH get="inline" set="null" expr="0x1000" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</TILE_SMOOTH>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" expr="0x00000000" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" expr="0x00010000" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00010000</e></m></meta>
		</TILE_BLEND_ADD>
		<RGBA public="1" get="inline" set="null" line="186" static="1">
			<f a="inRGB:?inA" v=":0xff">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ inA : 0xff }</e></m></meta>
		</RGBA>
		<nme_gfx_clear expr="PrimeLoader.load(&quot;nme_gfx_clear&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_clear", "ov")</e></m></meta>
		</nme_gfx_clear>
		<nme_gfx_begin_fill expr="PrimeLoader.load(&quot;nme_gfx_begin_fill&quot;, &quot;oidv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_begin_fill", "oidv")</e></m></meta>
		</nme_gfx_begin_fill>
		<nme_gfx_begin_bitmap_fill expr="PrimeLoader.load(&quot;nme_gfx_begin_bitmap_fill&quot;, &quot;ooobbv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_begin_bitmap_fill", "ooobbv")</e></m></meta>
		</nme_gfx_begin_bitmap_fill>
		<nme_gfx_line_bitmap_fill expr="PrimeLoader.load(&quot;nme_gfx_line_bitmap_fill&quot;, &quot;ooobbv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_line_bitmap_fill", "ooobbv")</e></m></meta>
		</nme_gfx_line_bitmap_fill>
		<nme_gfx_begin_set_gradient_fill expr="nme.PrimeLoader.load(&quot;nme_gfx_begin_set_gradient_fill&quot;, &quot;oiooooiidbv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::::::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_gfx_begin_set_gradient_fill", "oiooooiidbv")</e></m></meta>
		</nme_gfx_begin_set_gradient_fill>
		<nme_gfx_end_fill expr="PrimeLoader.load(&quot;nme_gfx_end_fill&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_end_fill", "ov")</e></m></meta>
		</nme_gfx_end_fill>
		<nme_gfx_line_style expr="nme.PrimeLoader.load(&quot;nme_gfx_line_style&quot;, &quot;ooidbiiidv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_gfx_line_style", "ooidbiiidv")</e></m></meta>
		</nme_gfx_line_style>
		<nme_gfx_move_to expr="PrimeLoader.load(&quot;nme_gfx_move_to&quot;, &quot;oddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_move_to", "oddv")</e></m></meta>
		</nme_gfx_move_to>
		<nme_gfx_line_to expr="PrimeLoader.load(&quot;nme_gfx_line_to&quot;, &quot;oddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_line_to", "oddv")</e></m></meta>
		</nme_gfx_line_to>
		<nme_gfx_curve_to expr="PrimeLoader.load(&quot;nme_gfx_curve_to&quot;, &quot;oddddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_curve_to", "oddddv")</e></m></meta>
		</nme_gfx_curve_to>
		<nme_gfx_arc_to expr="PrimeLoader.load(&quot;nme_gfx_arc_to&quot;, &quot;oddddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_arc_to", "oddddv")</e></m></meta>
		</nme_gfx_arc_to>
		<nme_gfx_draw_ellipse expr="PrimeLoader.load(&quot;nme_gfx_draw_ellipse&quot;, &quot;oddddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_ellipse", "oddddv")</e></m></meta>
		</nme_gfx_draw_ellipse>
		<nme_gfx_draw_data expr="PrimeLoader.load(&quot;nme_gfx_draw_data&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_data", "oov")</e></m></meta>
		</nme_gfx_draw_data>
		<nme_gfx_draw_datum expr="PrimeLoader.load(&quot;nme_gfx_draw_datum&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_datum", "oov")</e></m></meta>
		</nme_gfx_draw_datum>
		<nme_gfx_draw_rect expr="PrimeLoader.load(&quot;nme_gfx_draw_rect&quot;, &quot;oddddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_rect", "oddddv")</e></m></meta>
		</nme_gfx_draw_rect>
		<nme_gfx_draw_path expr="PrimeLoader.load(&quot;nme_gfx_draw_path&quot;, &quot;ooobv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_path", "ooobv")</e></m></meta>
		</nme_gfx_draw_path>
		<nme_gfx_draw_tiles expr="PrimeLoader.load(&quot;nme_gfx_draw_tiles&quot;, &quot;oooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_tiles", "oooiiv")</e></m></meta>
		</nme_gfx_draw_tiles>
		<nme_gfx_draw_points expr="PrimeLoader.load(&quot;nme_gfx_draw_points&quot;, &quot;oooibdv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_gfx_draw_points", "oooibdv")</e></m></meta>
		</nme_gfx_draw_points>
		<nme_gfx_draw_round_rect expr="nme.PrimeLoader.load(&quot;nme_gfx_draw_round_rect&quot;, &quot;oddddddv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_gfx_draw_round_rect", "oddddddv")</e></m></meta>
		</nme_gfx_draw_round_rect>
		<nme_gfx_draw_triangles expr="nme.PrimeLoader.load(&quot;nme_gfx_draw_triangles&quot;, &quot;ooooioiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::::::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_gfx_draw_triangles", "ooooioiv")</e></m></meta>
		</nme_gfx_draw_triangles>
		<nmeHandle>
			<t path="nme.NativeHandle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<arcTo public="1" set="method" line="32"><f a="inCX:inCY:inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arcTo>
		<beginBitmapFill public="1" set="method" line="37">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="nme.display.BitmapData"/>
				<c path="nme.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true }</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method" line="42">
			<f a="color:?alpha" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method" line="47">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0.0">
				<e path="nme.display.GradientType"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="nme.geom.Matrix"/>
				<e path="nme.display.SpreadMethod"/>
				<e path="nme.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0.0 }</e></m></meta>
		</beginGradientFill>
		<clear public="1" set="method" line="58"><f a=""><x path="Void"/></f></clear>
		<curveTo public="1" set="method" line="63"><f a="inCX:inCY:inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method" line="68"><f a="inX:inY:inRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method" line="73"><f a="inX:inY:inWidth:inHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method" line="78"><f a="graphicsData">
	<c path="Array"><c path="nme.display.IGraphicsData"/></c>
	<x path="Void"/>
</f></drawGraphicsData>
		<drawGraphicsDatum public="1" set="method" line="88"><f a="graphicsDatum">
	<c path="nme.display.IGraphicsData"/>
	<x path="Void"/>
</f></drawGraphicsDatum>
		<drawPoints public="1" set="method" line="93">
			<f a="inXY:?inPointRGBA:?inDefaultRGBA:?inSize" v=":null:0xffffffff:-1.0">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inSize : -1.0, inDefaultRGBA : 0xffffffff, inPointRGBA : null }</e></m></meta>
		</drawPoints>
		<drawRect public="1" set="method" line="98"><f a="inX:inY:inWidth:inHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method" line="103"><f a="inX:inY:inWidth:inHeight:inRadX:?inRadY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawPath public="1" set="method" line="111">
			<f a="commands:data:?winding" v="::GraphicsPathWinding.EVEN_ODD">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ winding : GraphicsPathWinding.EVEN_ODD }</e></m></meta>
		</drawPath>
		<drawTiles public="1" set="method" line="116">
			<f a="sheet:inXYID:?inSmooth:?inFlags:?inCount" v="::false:0:-1">
				<c path="nme.display.Tilesheet"/>
				<x path="nme.utils.Floats3264"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inCount : -1, inFlags : 0, inSmooth : false }</e></m></meta>
		</drawTiles>
		<drawTriangles public="1" set="method" line="144">
			<f a="vertices:?indices:?uvtData:?culling:?colours:?blendMode" v=":::::0">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<e path="nme.display.TriangleCulling"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ blendMode : 0 }</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method" line="150"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method" line="155">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="nme.display.BitmapData"/>
				<c path="nme.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true }</e></m></meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method" line="160">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0.0">
				<e path="nme.display.GradientType"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="nme.geom.Matrix"/>
				<e path="nme.display.SpreadMethod"/>
				<e path="nme.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0.0 }</e></m></meta>
		</lineGradientStyle>
		<lineStyle public="1" set="method" line="171">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v=":0:1.0:false::::3">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="nme.display.LineScaleMode"/>
				<e path="nme.display.CapsStyle"/>
				<e path="nme.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miterLimit : 3, pixelHinting : false, alpha : 1.0, color : 0 }</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method" line="176"><f a="inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="181"><f a="inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="27"><f a="inHandle">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.GraphicsPathWinding" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/GraphicsPathWinding.hx">
		<EVEN_ODD public="1" get="inline" set="null" expr="&quot;evenOdd&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"evenOdd"</e></m></meta>
		</EVEN_ODD>
		<NON_ZERO public="1" get="inline" set="null" expr="&quot;nonZero&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"nonZero"</e></m></meta>
		</NON_ZERO>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.display.IGraphicsData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/IGraphicsData.hx">
		<nmeHandle public="1">
			<t path="nme.NativeHandle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<new public="1" set="method" line="9"><f a="inHandle">
	<t path="nme.NativeHandle"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="nme.display.InterpolationMethod" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="nme.display.JointStyle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="nme.display.LineScaleMode" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/LineScaleMode.hx">
		<NORMAL/>
		<NONE/>
		<VERTICAL/>
		<HORIZONTAL/>
		<OPENGL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.display.Sprite" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Sprite.hx">
		<extends path="nme.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<nmeGetType set="method" line="17">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetType>
		<startDrag public="1" set="method" line="23">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startDrag>
		<stopDrag public="1" set="method" line="29"><f a=""><x path="Void"/></f></stopDrag>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.Loader" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Loader.hx">
		<extends path="nme.display.Sprite"/>
		<content public="1" set="null"><c path="nme.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="nme.display.LoaderInfo"/></contentLoaderInfo>
		<nmeImage>
			<c path="nme.display.BitmapData"/>
			<haxe_doc>@private</haxe_doc>
		</nmeImage>
		<doLoad set="method" line="35"><f a="inBytes">
	<c path="nme.utils.ByteArray"/>
	<x path="Bool"/>
</f></doLoad>
		<load public="1" set="method" line="62">
			<f a="request:?context" v=":null">
				<c path="nme.net.URLRequest"/>
				<c path="nme.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadBytes public="1" set="method" line="68">
			<f a="bytes:?context" v=":null">
				<c path="nme.utils.ByteArray"/>
				<c path="nme.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</loadBytes>
		<unload public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</unload>
		<onData set="method" line="105"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Void"/>
</f></onData>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.net.URLLoader" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLLoader.hx">
		<extends path="nme.events.EventDispatcher"/>
		<activeLoaders expr="new List&lt;URLLoader&gt;()" line="42" static="1">
			<c path="haxe.ds.List"><c path="nme.net.URLLoader"/></c>
			<meta><m n=":value"><e><![CDATA[new List<URLLoader>()]]></e></m></meta>
		</activeLoaders>
		<urlInvalid public="1" get="inline" set="null" expr="0" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</urlInvalid>
		<urlInit public="1" get="inline" set="null" expr="1" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</urlInit>
		<urlLoading public="1" get="inline" set="null" expr="2" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</urlLoading>
		<urlComplete public="1" get="inline" set="null" expr="3" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</urlComplete>
		<urlError public="1" get="inline" set="null" expr="4" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</urlError>
		<hasActive public="1" set="method" line="71" static="1"><f a=""><x path="Bool"/></f></hasActive>
		<initialize public="1" set="method" line="76" static="1"><f a="inCACertFilePath">
	<c path="String"/>
	<x path="Void"/>
</f></initialize>
		<nmeLoadPending public="1" set="method" line="150" static="1"><f a=""><x path="Bool"/></f></nmeLoadPending>
		<nmePollData public="1" set="method" line="155" static="1"><f a=""><x path="Void"/></f></nmePollData>
		<pollLoaders set="method" line="283" static="1"><f a=""><x path="Void"/></f></pollLoaders>
		<nme_curl_create expr="Loader.load(&quot;nme_curl_create&quot;, 1)" line="290" static="1">
			<f a="">
				<c path="nme.net.URLRequest"/>
				<t path="nme.NativeHandle"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_create", 1)</e></m></meta>
		</nme_curl_create>
		<nme_curl_process_loaders expr="Loader.load(&quot;nme_curl_process_loaders&quot;, 0)" line="291" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>Loader.load("nme_curl_process_loaders", 0)</e></m></meta>
		</nme_curl_process_loaders>
		<nme_curl_update_loader expr="Loader.load(&quot;nme_curl_update_loader&quot;, 2)" line="292" static="1">
			<f a=":">
				<t path="nme.net.HttpHandle"/>
				<c path="nme.net.URLLoader"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_update_loader", 2)</e></m></meta>
		</nme_curl_update_loader>
		<nme_curl_get_code expr="Loader.load(&quot;nme_curl_get_code&quot;, 1)" line="293" static="1">
			<f a="">
				<t path="nme.net.HttpHandle"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_get_code", 1)</e></m></meta>
		</nme_curl_get_code>
		<nme_curl_get_error_message expr="Loader.load(&quot;nme_curl_get_error_message&quot;, 1)" line="294" static="1">
			<f a="">
				<t path="nme.net.HttpHandle"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_get_error_message", 1)</e></m></meta>
		</nme_curl_get_error_message>
		<nme_curl_get_data expr="Loader.load(&quot;nme_curl_get_data&quot;, 1)" line="295" static="1">
			<f a="">
				<t path="nme.net.HttpHandle"/>
				<c path="nme.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_get_data", 1)</e></m></meta>
		</nme_curl_get_data>
		<nme_curl_get_cookies expr="Loader.load(&quot;nme_curl_get_cookies&quot;, 1)" line="296" static="1">
			<f a="">
				<t path="nme.net.HttpHandle"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_get_cookies", 1)</e></m></meta>
		</nme_curl_get_cookies>
		<nme_curl_get_headers expr="Loader.load(&quot;nme_curl_get_headers&quot;, 1)" line="297" static="1">
			<f a="">
				<t path="nme.net.HttpHandle"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_get_headers", 1)</e></m></meta>
		</nme_curl_get_headers>
		<nme_curl_initialize expr="Loader.load(&quot;nme_curl_initialize&quot;, 1)" line="298" static="1">
			<f a="">
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_curl_initialize", 1)</e></m></meta>
		</nme_curl_initialize>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1"><e path="nme.net.URLLoaderDataFormat"/></dataFormat>
		<nmeHandle public="1"><t path="nme.net.HttpHandle"/></nmeHandle>
		<state><x path="Int"/></state>
		<nmeOnComplete public="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nmeOnComplete>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="83"><f a="request">
	<c path="nme.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<nmeDataComplete set="method" line="131"><f a=""><x path="Void"/></f></nmeDataComplete>
		<onError set="method" line="173"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<dispatchHTTPStatus set="method" line="180"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></dispatchHTTPStatus>
		<update set="method" line="195">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</update>
		<getErrorMessage set="method" line="271"><f a=""><c path="String"/></f></getErrorMessage>
		<getData set="method" line="272"><f a=""><c path="nme.utils.ByteArray"/></f></getData>
		<getString set="method" line="273"><f a=""><c path="String"/></f></getString>
		<getCode set="method" line="278"><f a=""><x path="Int"/></f></getCode>
		<updateLoader set="method" line="279"><f a=""><x path="Void"/></f></updateLoader>
		<getHeaders set="method" line="280"><f a=""><c path="Array"><c path="String"/></c></f></getHeaders>
		<createLoader set="method" line="281"><f a="request">
	<c path="nme.net.URLRequest"/>
	<t path="nme.NativeHandle"/>
</f></createLoader>
		<getCookies public="1" set="method" line="282"><f a=""><c path="Array"><c path="String"/></c></f></getCookies>
		<disposeHandler set="method" line="284"><f a=""><x path="Void"/></f></disposeHandler>
		<new public="1" set="method" line="53"><f a="?request">
	<c path="nme.net.URLRequest"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.LoaderInfo" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/LoaderInfo.hx">
		<extends path="nme.net.URLLoader"/>
		<create public="1" set="method" line="43" static="1"><f a="ldr">
	<c path="nme.display.Loader"/>
	<c path="nme.display.LoaderInfo"/>
</f></create>
		<bytes public="1" get="accessor" set="null"><c path="nme.utils.ByteArray"/></bytes>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<content public="1"><c path="nme.display.DisplayObject"/></content>
		<contentType public="1"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<loader public="1" set="null"><c path="nme.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="nme.events.EventDispatcher"/></sharedEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
		<pendingURL><c path="String"/></pendingURL>
		<load public="1" set="method" line="57" override="1"><f a="request">
	<c path="nme.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<onURLLoaded set="method" line="84"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Void"/>
</f></onURLLoaded>
		<get_bytes set="method" line="90"><f a=""><c path="nme.utils.ByteArray"/></f></get_bytes>
		<new set="method" line="31"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.Stage" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Stage.hx">
		<extends path="nme.display.DisplayObjectContainer"/>
		<implements path="nme.app.IAppEventHandler"/>
		<implements path="nme.app.IPollClient"/>
		<nmeEarlyWakeup public="1" expr="0.005" line="62" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.005</e></m></meta>
			<haxe_doc>* Time, in seconds, we wake up before the frame is due.  We then do a
    * "busy wait" to ensure the frame comes at the right time.  By increasing this number,
    * the frame rate will be more constant, but the busy wait will take more CPU.
    * @private</haxe_doc>
		</nmeEarlyWakeup>
		<OrientationPortrait public="1" get="inline" set="null" expr="1" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</OrientationPortrait>
		<OrientationPortraitUpsideDown public="1" get="inline" set="null" expr="2" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</OrientationPortraitUpsideDown>
		<OrientationLandscapeRight public="1" get="inline" set="null" expr="3" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</OrientationLandscapeRight>
		<OrientationLandscapeLeft public="1" get="inline" set="null" expr="4" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</OrientationLandscapeLeft>
		<OrientationFaceUp public="1" get="inline" set="null" expr="5" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</OrientationFaceUp>
		<OrientationFaceDown public="1" get="inline" set="null" expr="6" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</OrientationFaceDown>
		<OrientationPortraitAny public="1" get="inline" set="null" expr="7" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</OrientationPortraitAny>
		<OrientationLandscapeAny public="1" get="inline" set="null" expr="8" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</OrientationLandscapeAny>
		<OrientationAny public="1" get="inline" set="null" expr="9" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</OrientationAny>
		<OrientationUseFunction public="1" get="inline" set="null" expr="-1" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</OrientationUseFunction>
		<efLeftDown expr="0x0001" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</efLeftDown>
		<efShiftDown expr="0x0002" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</efShiftDown>
		<efCtrlDown expr="0x0004" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</efCtrlDown>
		<efAltDown expr="0x0008" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</efAltDown>
		<efCommandDown expr="0x0010" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</efCommandDown>
		<efLocationRight expr="0x4000" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x4000</e></m></meta>
		</efLocationRight>
		<efNoNativeClick expr="0x10000" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x10000</e></m></meta>
		</efNoNativeClick>
		<nmeMouseChanges expr="[MouseEvent.MOUSE_OUT, MouseEvent.MOUSE_OVER, MouseEvent.ROLL_OUT, MouseEvent.ROLL_OVER]" line="118" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[MouseEvent.MOUSE_OUT, MouseEvent.MOUSE_OVER, MouseEvent.ROLL_OUT, MouseEvent.ROLL_OVER]</e></m></meta>
		</nmeMouseChanges>
		<nmeTouchChanges expr="[TouchEvent.TOUCH_OUT, TouchEvent.TOUCH_OVER, TouchEvent.TOUCH_ROLL_OUT, TouchEvent.TOUCH_ROLL_OVER]" line="119" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[TouchEvent.TOUCH_OUT, TouchEvent.TOUCH_OVER, TouchEvent.TOUCH_ROLL_OUT, TouchEvent.TOUCH_ROLL_OVER]</e></m></meta>
		</nmeTouchChanges>
		<sClickEvents expr="[&quot;click&quot;, &quot;middleClick&quot;, &quot;rightClick&quot;]" line="120" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["click", "middleClick", "rightClick"]</e></m></meta>
		</sClickEvents>
		<sDownEvents expr="[&quot;mouseDown&quot;, &quot;middleMouseDown&quot;, &quot;rightMouseDown&quot;]" line="121" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["mouseDown", "middleMouseDown", "rightMouseDown"]</e></m></meta>
		</sDownEvents>
		<sUpEvents expr="[&quot;mouseUp&quot;, &quot;middleMouseUp&quot;, &quot;rightMouseUp&quot;]" line="122" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["mouseUp", "middleMouseUp", "rightMouseUp"]</e></m></meta>
		</sUpEvents>
		<nmeQuitting public="1" expr="false" line="124" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</nmeQuitting>
		<getOrientation public="1" set="dynamic" line="201" static="1"><f a=""><x path="Int"/></f></getOrientation>
		<getNormalOrientation public="1" set="dynamic" line="206" static="1"><f a=""><x path="Int"/></f></getNormalOrientation>
		<setFixedOrientation public="1" set="method" line="1078" static="1"><f a="inOrientation">
	<x path="Int"/>
	<x path="Void"/>
</f></setFixedOrientation>
		<shouldRotateInterface public="1" set="dynamic" line="1085" static="1"><f a="inOrientation">
	<x path="Int"/>
	<x path="Bool"/>
</f></shouldRotateInterface>
		<nme_render_stage expr="PrimeLoader.load(&quot;nme_render_stage&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_render_stage", "ov")</e></m></meta>
		</nme_render_stage>
		<nme_set_render_gc_free expr="PrimeLoader.load(&quot;nme_set_render_gc_free&quot;, &quot;bv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_set_render_gc_free", "bv")</e></m></meta>
		</nme_set_render_gc_free>
		<nme_stage_get_focus_id expr="PrimeLoader.load(&quot;nme_stage_get_focus_id&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_focus_id", "oi")</e></m></meta>
		</nme_stage_get_focus_id>
		<nme_stage_set_focus expr="PrimeLoader.load(&quot;nme_stage_set_focus&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_focus", "oov")</e></m></meta>
		</nme_stage_set_focus>
		<nme_stage_get_focus_rect expr="PrimeLoader.load(&quot;nme_stage_get_focus_rect&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_focus_rect", "ob")</e></m></meta>
		</nme_stage_get_focus_rect>
		<nme_stage_set_focus_rect expr="PrimeLoader.load(&quot;nme_stage_set_focus_rect&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_set_focus_rect", "obv")</e></m></meta>
		</nme_stage_set_focus_rect>
		<nme_stage_resize_window expr="PrimeLoader.load(&quot;nme_stage_resize_window&quot;, &quot;oiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_resize_window", "oiiv")</e></m></meta>
		</nme_stage_resize_window>
		<nme_stage_show_cursor expr="PrimeLoader.load(&quot;nme_stage_show_cursor&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_show_cursor", "obv")</e></m></meta>
		</nme_stage_show_cursor>
		<nme_stage_get_orientation expr="PrimeLoader.load(&quot;nme_stage_get_orientation&quot;, &quot;i&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Int"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_orientation", "i")</e></m></meta>
		</nme_stage_get_orientation>
		<nme_stage_get_normal_orientation expr="PrimeLoader.load(&quot;nme_stage_get_normal_orientation&quot;, &quot;i&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Int"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_get_normal_orientation", "i")</e></m></meta>
		</nme_stage_get_normal_orientation>
		<nme_stage_check_cache expr="PrimeLoader.load(&quot;nme_stage_check_cache&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_stage_check_cache", "ob")</e></m></meta>
		</nme_stage_check_cache>
		<nme_set_stage_mouse_handler_native expr="PrimeLoader.load(&quot;nme_set_stage_mouse_handler_native&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_set_stage_mouse_handler_native", "oov")</e></m></meta>
		</nme_set_stage_mouse_handler_native>
		<window public="1" set="null"><c path="nme.app.Window"/></window>
		<active public="1" get="accessor" set="null"><x path="Bool"/></active>
		<align public="1" get="accessor" set="accessor"><e path="nme.display.StageAlign"/></align>
		<displayState public="1" get="accessor" set="accessor"><e path="nme.display.StageDisplayState"/></displayState>
		<dpiScale public="1" get="accessor" set="null"><x path="Float"/></dpiScale>
		<focus public="1" get="accessor" set="accessor"><c path="nme.display.InteractiveObject"/></focus>
		<frameRate public="1" get="accessor" set="accessor"><x path="Float"/></frameRate>
		<onQuit public="1" get="accessor" set="accessor"><f a=""><x path="Void"/></f></onQuit>
		<isOpenGL public="1" get="accessor" set="null"><x path="Bool"/></isOpenGL>
		<exceptionHandler public="1"><f a=":">
	<d/>
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Void"/>
</f></exceptionHandler>
		<pauseWhenDeactivated public="1"><x path="Bool"/></pauseWhenDeactivated>
		<quality public="1" get="accessor" set="accessor"><e path="nme.display.StageQuality"/></quality>
		<scaleMode public="1" get="accessor" set="accessor"><e path="nme.display.StageScaleMode"/></scaleMode>
		<stageFocusRect public="1" get="accessor" set="accessor"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1" get="accessor" set="null"><x path="Int"/></stageHeight>
		<stageWidth public="1" get="accessor" set="null"><x path="Int"/></stageWidth>
		<renderRequest public="1" get="accessor" set="accessor"><f a=""><x path="Bool"/></f></renderRequest>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<invalid><x path="Bool"/></invalid>
		<stageVideos public="1"><x path="nme.Vector"><c path="nme.media.StageVideo"/></x></stageVideos>
		<nmeJoyAxisData><c path="Array"><c path="Array"><x path="Float"/></c></c></nmeJoyAxisData>
		<nmeDragBounds><c path="nme.geom.Rectangle"/></nmeDragBounds>
		<nmeDragObject><c path="nme.display.Sprite"/></nmeDragObject>
		<nmeDragOffsetX><x path="Float"/></nmeDragOffsetX>
		<nmeDragOffsetY><x path="Float"/></nmeDragOffsetY>
		<nmeFocusOverObjects><c path="Array"><c path="nme.display.InteractiveObject"/></c></nmeFocusOverObjects>
		<nmeFramePeriod><x path="Float"/></nmeFramePeriod>
		<nmeLastClickTime><x path="Float"/></nmeLastClickTime>
		<nmeLastDown><c path="Array"><c path="nme.display.InteractiveObject"/></c></nmeLastDown>
		<nmeLastRender><x path="Float"/></nmeLastRender>
		<nmeMouseOverObjects><c path="Array"><c path="nme.display.InteractiveObject"/></c></nmeMouseOverObjects>
		<nmeTouchInfo><t path="Map">
	<x path="Int"/>
	<c path="nme.display.TouchInfo"/>
</t></nmeTouchInfo>
		<nmeFrameTimer><c path="nme.app.FrameTimer"/></nmeFrameTimer>
		<nmeEnterFrameEvent><c path="nme.events.Event"/></nmeEnterFrameEvent>
		<nmeRenderEvent><c path="nme.events.Event"/></nmeRenderEvent>
		<nmeDropItems><c path="Array"><c path="String"/></c></nmeDropItems>
		<nmePrenderListeners><c path="Array"><f a=""><x path="Void"/></f></c></nmePrenderListeners>
		<nmePreemptiveGcFreq><x path="Int"/></nmePreemptiveGcFreq>
		<nmePreemptiveGcSince><x path="Int"/></nmePreemptiveGcSince>
		<nmeCollectionLock><c path="sys.thread.Lock"/></nmeCollectionLock>
		<nmeCollectionAgency><x path="sys.thread.Thread"/></nmeCollectionAgency>
		<nmeFrameAlloc><c path="Array"><x path="Int"/></c></nmeFrameAlloc>
		<nmeLastCurrentMemory><x path="Int"/></nmeLastCurrentMemory>
		<nmeLastPreempt><x path="Bool"/></nmeLastPreempt>
		<nmeFrameMemIndex><x path="Int"/></nmeFrameMemIndex>
		<invalidate public="1" set="method" line="211"><f a=""><x path="Void"/></f></invalidate>
		<isDisplayListDirty public="1" set="method" line="218"><f a=""><x path="Bool"/></f></isDisplayListDirty>
		<get_onQuit set="method" line="224"><f a=""><f a=""><x path="Void"/></f></f></get_onQuit>
		<set_onQuit set="method" line="225"><f a="val">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
</f></set_onQuit>
		<addEventListener public="1" set="method" line="227" override="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<nmeCheckFocusInOuts set="method" line="234"><f a="inEvent:inStack">
	<x path="nme.app.AppEvent"/>
	<c path="Array"><c path="nme.display.InteractiveObject"/></c>
	<x path="Void"/>
</f></nmeCheckFocusInOuts>
		<nmeCheckInOuts set="method" line="263"><f a="inEvent:inStack:?touchInfo">
	<c path="nme.events.MouseEvent"/>
	<c path="Array"><c path="nme.display.InteractiveObject"/></c>
	<c path="nme.display.TouchInfo"/>
	<x path="Bool"/>
</f></nmeCheckInOuts>
		<addPrerenderListener public="1" set="method" line="314"><f a="listener">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></addPrerenderListener>
		<removePrerenderListener public="1" set="method" line="322"><f a="listener">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></removePrerenderListener>
		<onText public="1" set="method" line="331"><f a="inEvent:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onText>
		<onKey public="1" set="method" line="361"><f a="inEvent:type">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onKey>
		<onMouse public="1" set="method" line="409"><f a="inEvent:inType:inFromMouse">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></onMouse>
		<onUnhandledException public="1" set="method" line="500"><f a="exception:stack">
	<d/>
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Void"/>
</f></onUnhandledException>
		<onTouch public="1" set="method" line="513"><f a="inEvent:inType">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onTouch>
		<onResize public="1" set="method" line="533"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<onRender public="1" set="method" line="539"><f a="inFrameDue">
	<x path="Bool"/>
	<x path="Void"/>
</f></onRender>
		<onDisplayObjectFocus public="1" set="method" line="645"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDisplayObjectFocus>
		<onInputFocus public="1" set="method" line="673"><f a="acquired">
	<x path="Bool"/>
	<x path="Void"/>
</f></onInputFocus>
		<onRotateRequest public="1" set="method" line="679"><f a="inDirection">
	<x path="Int"/>
	<x path="Bool"/>
</f></onRotateRequest>
		<onChange public="1" set="method" line="684"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onChange>
		<onScroll public="1" set="method" line="691"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onScroll>
		<onDrop public="1" set="method" line="698"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDrop>
		<onDpiChanged public="1" set="method" line="735"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onDpiChanged>
		<onActive public="1" set="method" line="740"><f a="inActive">
	<x path="Bool"/>
	<x path="Void"/>
</f></onActive>
		<axismap get="inline" set="null" line="756"><f a="code">
	<x path="Int"/>
	<x path="Int"/>
</f></axismap>
		<buttonmap get="inline" set="null" line="768"><f a="code">
	<x path="Int"/>
	<x path="Int"/>
</f></buttonmap>
		<onJoystick public="1" set="method" line="784"><f a="inEvent:inType">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<x path="Void"/>
</f></onJoystick>
		<onSysMessage public="1" set="method" line="867"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onSysMessage>
		<onAppLink public="1" set="method" line="873"><f a="inEvent">
	<x path="nme.app.AppEvent"/>
	<x path="Void"/>
</f></onAppLink>
		<onContextLost public="1" set="method" line="880"><f a=""><x path="Void"/></f></onContextLost>
		<nmeDrag set="method" line="890"><f a="inMouse">
	<c path="nme.geom.Point"/>
	<x path="Void"/>
</f></nmeDrag>
		<set_opaqueBackground set="method" line="929" override="1"><f a="inBG">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_opaqueBackground>
		<set_color set="method" line="940"><f a="inColor">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<get_color set="method" line="947"><f a=""><x path="Int"/></f></get_color>
		<nmeOnTouch set="method" line="955"><f a="inEvent:inType:touchInfo">
	<x path="nme.app.AppEvent"/>
	<c path="String"/>
	<c path="nme.display.TouchInfo"/>
	<x path="Void"/>
</f></nmeOnTouch>
		<onPoll public="1" set="method" line="996"><f a="inTimestamp">
	<x path="Float"/>
	<x path="Void"/>
</f></onPoll>
		<getNextWake public="1" set="method" line="1003"><f a="inDefaultWake:inTimestamp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getNextWake>
		<nmeStartDrag public="1" set="method" line="1021">
			<f a="sprite:lockCenter:bounds">
				<c path="nme.display.Sprite"/>
				<x path="Bool"/>
				<c path="nme.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeStartDrag>
		<nmeStopDrag public="1" set="method" line="1045"><f a="sprite">
	<c path="nme.display.Sprite"/>
	<x path="Void"/>
</f></nmeStopDrag>
		<setPreemtiveGcFrequency public="1" set="method" line="1051"><f a="inFrames">
	<x path="Int"/>
	<x path="Void"/>
</f></setPreemtiveGcFrequency>
		<setSmartPreemtiveGc public="1" set="method" line="1073"><f a=""><x path="Void"/></f></setSmartPreemtiveGc>
		<showCursor public="1" set="method" line="1087"><f a="inShow">
	<x path="Bool"/>
	<x path="Void"/>
</f></showCursor>
		<get_focus set="method" line="1093"><f a=""><c path="nme.display.InteractiveObject"/></f></get_focus>
		<set_focus set="method" line="1100"><f a="inObject">
	<c path="nme.display.InteractiveObject"/>
	<c path="nme.display.InteractiveObject"/>
</f></set_focus>
		<set_frameRate set="method" line="1109"><f a="inRate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<get_frameRate set="method" line="1117"><f a=""><x path="Float"/></f></get_frameRate>
		<get_stage set="method" line="1120" override="1"><f a=""><c path="nme.display.Stage"/></f></get_stage>
		<setMouseFilter public="1" set="method" line="1127"><f a="inHandler">
	<f a="">
		<c path="nme.events.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setMouseFilter>
		<resize public="1" set="method" line="1134"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<get_stageFocusRect set="method" line="1136"><f a=""><x path="Bool"/></f></get_stageFocusRect>
		<set_stageFocusRect set="method" line="1137"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stageFocusRect>
		<get_active set="method" line="1142"><f a=""><x path="Bool"/></f></get_active>
		<get_align set="method" line="1143"><f a=""><e path="nme.display.StageAlign"/></f></get_align>
		<set_align set="method" line="1144"><f a="inMode">
	<e path="nme.display.StageAlign"/>
	<e path="nme.display.StageAlign"/>
</f></set_align>
		<get_displayState set="method" line="1145"><f a=""><e path="nme.display.StageDisplayState"/></f></get_displayState>
		<set_displayState set="method" line="1146"><f a="inState">
	<e path="nme.display.StageDisplayState"/>
	<e path="nme.display.StageDisplayState"/>
</f></set_displayState>
		<get_dpiScale set="method" line="1147"><f a=""><x path="Float"/></f></get_dpiScale>
		<get_quality set="method" line="1148"><f a=""><e path="nme.display.StageQuality"/></f></get_quality>
		<set_quality set="method" line="1149"><f a="inQuality">
	<e path="nme.display.StageQuality"/>
	<e path="nme.display.StageQuality"/>
</f></set_quality>
		<get_scaleMode set="method" line="1150"><f a=""><e path="nme.display.StageScaleMode"/></f></get_scaleMode>
		<set_scaleMode set="method" line="1151"><f a="inMode">
	<e path="nme.display.StageScaleMode"/>
	<e path="nme.display.StageScaleMode"/>
</f></set_scaleMode>
		<get_stageHeight set="method" line="1152"><f a=""><x path="Int"/></f></get_stageHeight>
		<get_stageWidth set="method" line="1153"><f a=""><x path="Int"/></f></get_stageWidth>
		<get_isOpenGL set="method" line="1154"><f a=""><x path="Bool"/></f></get_isOpenGL>
		<get_renderRequest set="method" line="1155"><f a=""><f a=""><x path="Bool"/></f></f></get_renderRequest>
		<set_renderRequest set="method" line="1156"><f a="f">
	<f a=""><x path="Bool"/></f>
	<f a=""><x path="Bool"/></f>
</f></set_renderRequest>
		<new public="1" set="method" line="155"><f a="inWindow">
	<c path="nme.app.Window"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.ManagedStage" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/ManagedStage.hx">
		<extends path="nme.display.Stage"/>
		<etUnknown public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</etUnknown>
		<etKeyDown public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</etKeyDown>
		<etChar public="1" get="inline" set="null" expr="2" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</etChar>
		<etKeyUp public="1" get="inline" set="null" expr="3" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</etKeyUp>
		<etMouseMove public="1" get="inline" set="null" expr="4" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</etMouseMove>
		<etMouseDown public="1" get="inline" set="null" expr="5" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</etMouseDown>
		<etMouseClick public="1" get="inline" set="null" expr="6" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</etMouseClick>
		<etMouseUp public="1" get="inline" set="null" expr="7" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</etMouseUp>
		<etResize public="1" get="inline" set="null" expr="8" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</etResize>
		<etPoll public="1" get="inline" set="null" expr="9" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</etPoll>
		<etQuit public="1" get="inline" set="null" expr="10" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</etQuit>
		<etFocus public="1" get="inline" set="null" expr="11" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</etFocus>
		<etShouldRotate public="1" get="inline" set="null" expr="12" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</etShouldRotate>
		<etDestroyHandler public="1" get="inline" set="null" expr="13" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</etDestroyHandler>
		<etRedraw public="1" get="inline" set="null" expr="14" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</etRedraw>
		<etTouchBegin public="1" get="inline" set="null" expr="15" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</etTouchBegin>
		<etTouchMove public="1" get="inline" set="null" expr="16" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</etTouchMove>
		<etTouchEnd public="1" get="inline" set="null" expr="17" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</etTouchEnd>
		<etTouchTap public="1" get="inline" set="null" expr="18" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</etTouchTap>
		<etChange public="1" get="inline" set="null" expr="19" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</etChange>
		<efLeftDown public="1" get="inline" set="null" expr="0x0001" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</efLeftDown>
		<efShiftDown public="1" get="inline" set="null" expr="0x0002" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</efShiftDown>
		<efCtrlDown public="1" get="inline" set="null" expr="0x0004" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</efCtrlDown>
		<efAltDown public="1" get="inline" set="null" expr="0x0008" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</efAltDown>
		<efCommandDown public="1" get="inline" set="null" expr="0x0010" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</efCommandDown>
		<efMiddleDown public="1" get="inline" set="null" expr="0x0020" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</efMiddleDown>
		<efRightDown public="1" get="inline" set="null" expr="0x0040" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</efRightDown>
		<efLocationRight public="1" get="inline" set="null" expr="0x4000" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x4000</e></m></meta>
		</efLocationRight>
		<efPrimaryTouch public="1" get="inline" set="null" expr="0x8000" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8000</e></m></meta>
		</efPrimaryTouch>
		<initSdlAudio public="1" set="method" line="88" static="1"><f a=""><x path="Void"/></f></initSdlAudio>
		<nme_managed_stage_create expr="PrimeLoader.load(&quot;nme_managed_stage_create&quot;, &quot;iiio&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_managed_stage_create", "iiio")</e></m></meta>
		</nme_managed_stage_create>
		<nme_managed_stage_pump_event expr="PrimeLoader.load(&quot;nme_managed_stage_pump_event&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_managed_stage_pump_event", "oov")</e></m></meta>
		</nme_managed_stage_pump_event>
		<nme_init_sdl_audio expr="PrimeLoader.load(&quot;nme_init_sdl_audio&quot;, &quot;v&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><c path="cpp.Void"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_init_sdl_audio", "v")</e></m></meta>
		</nme_init_sdl_audio>
		<pumpEvent public="1" set="method" line="61"><f a="inEvent">
	<d/>
	<x path="Void"/>
</f></pumpEvent>
		<onWindowSize public="1" set="method" line="66"><f a="inWidth:inHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onWindowSize>
		<sendQuit public="1" set="method" line="71"><f a=""><x path="Void"/></f></sendQuit>
		<setNextWake public="1" set="dynamic" line="76"><f a="inDelay">
	<x path="Float"/>
	<x path="Void"/>
</f></setNextWake>
		<invalidate public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="40">
			<f a="inWidth:inHeight:?inFlags" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inFlags : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.display.MovieClip" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/MovieClip.hx">
		<extends path="nme.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null"><x path="Int"/></currentFrame>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" get="accessor" set="null"><x path="Int"/></framesLoaded>
		<totalFrames public="1" get="accessor" set="null"><x path="Int"/></totalFrames>
		<mCurrentFrame><x path="Int"/></mCurrentFrame>
		<mTotalFrames><x path="Int"/></mTotalFrames>
		<__currentFrame get="accessor" set="accessor"><x path="Int"/></__currentFrame>
		<get___currentFrame set="method" line="21"><f a=""><x path="Int"/></f></get___currentFrame>
		<set___currentFrame set="method" line="22"><f a="f">
	<x path="Int"/>
	<x path="Int"/>
</f></set___currentFrame>
		<__totalFrames get="accessor" set="accessor"><x path="Int"/></__totalFrames>
		<get___totalFrames set="method" line="24"><f a=""><x path="Int"/></f></get___totalFrames>
		<set___totalFrames set="method" line="25"><f a="f">
	<x path="Int"/>
	<x path="Int"/>
</f></set___totalFrames>
		<__frameScripts><t path="Map">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
</t></__frameScripts>
		<__currentLabels><c path="Array"><c path="nme.display.FrameLabel"/></c></__currentLabels>
		<__currentFrameLabel><c path="String"/></__currentFrameLabel>
		<__currentLabel><c path="String"/></__currentLabel>
		<gotoAndPlay public="1" set="method" line="43"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method" line="47"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method" line="51"><f a=""><x path="Void"/></f></nextFrame>
		<nmeGetType set="method" line="55" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetType>
		<play public="1" set="method" line="59"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method" line="63"><f a=""><x path="Void"/></f></prevFrame>
		<stop public="1" set="method" line="67"><f a=""><x path="Void"/></f></stop>
		<get_currentFrame set="method" line="72">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_currentFrame>
		<get_framesLoaded set="method" line="73">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_framesLoaded>
		<get_totalFrames set="method" line="74">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_totalFrames>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<enum path="nme.display.PixelSnapping" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.display.Shape" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Shape.hx">
		<extends path="nme.display.DisplayObject"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<enum path="nme.display.SpreadMethod" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/SpreadMethod.hx">
		<PAD/>
		<REPEAT/>
		<REFLECT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.display.TouchInfo" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Stage.hx" module="nme.display.Stage">
		<touchOverObjects public="1"><c path="Array"><c path="nme.display.InteractiveObject"/></c></touchOverObjects>
		<new public="1" set="method" line="1183"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="nme.display.StageAlign" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<CENTRE/>
		<GAME/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="nme.display.StageDisplayState" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="nme.display.StageQuality" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/StageQuality.hx">
		<LOW/>
		<MEDIUM/>
		<HIGH/>
		<BEST/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="nme.display.StageScaleMode" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.display.Tilesheet" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" expr="0x0001" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" expr="0x0002" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" expr="0x0004" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" expr="0x0008" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" expr="0x0010" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" expr="0x0020" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" expr="0x0040" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</TILE_ORIGIN>
		<TILE_NO_ID public="1" get="inline" set="null" expr="0x0080" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</TILE_NO_ID>
		<TILE_MOUSE_ENABLE public="1" get="inline" set="null" expr="0x0100" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
		</TILE_MOUSE_ENABLE>
		<TILE_FIXED_SIZE public="1" get="inline" set="null" expr="0x0200" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</TILE_FIXED_SIZE>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" expr="0x00000000" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" expr="0x00010000" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00010000</e></m></meta>
		</TILE_BLEND_ADD>
		<TILE_BLEND_SCREEN public="1" get="inline" set="null" expr="0x00000000" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_SCREEN>
		<TILE_BLEND_MULTIPLY public="1" get="inline" set="null" expr="0x00000000" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_MULTIPLY>
		<TILE_BLEND_SUBTRACT public="1" get="inline" set="null" expr="0x00000000" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_SUBTRACT>
		<nme_tilesheet_create expr="PrimeLoader.load(&quot;nme_tilesheet_create&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_tilesheet_create", "oo")</e></m></meta>
		</nme_tilesheet_create>
		<nme_tilesheet_add_rect expr="PrimeLoader.load(&quot;nme_tilesheet_add_rect&quot;, &quot;oooi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_tilesheet_add_rect", "oooi")</e></m></meta>
		</nme_tilesheet_add_rect>
		<nme_tilesheet_get_rect expr="PrimeLoader.load(&quot;nme_tilesheet_get_rect&quot;, &quot;oiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_tilesheet_get_rect", "oiov")</e></m></meta>
		</nme_tilesheet_get_rect>
		<nmeBitmap public="1"><c path="nme.display.BitmapData"/></nmeBitmap>
		<tileCount public="1" set="null"><x path="Int"/></tileCount>
		<nmeHandle public="1"><t path="nme.NativeHandle"/></nmeHandle>
		<addTileRect public="1" set="method" line="46">
			<f a="rectangle:?centerPoint" v=":null">
				<c path="nme.geom.Rectangle"/>
				<c path="nme.geom.Point"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ centerPoint : null }</e></m></meta>
		</addTileRect>
		<getTileRect public="1" set="method" line="54"><f a="index:?result">
	<x path="Int"/>
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></getTileRect>
		<drawTiles public="1" set="method" line="69">
			<f a="graphics:tileData:?smooth:?flags:?count" v="::false:0:-1">
				<c path="nme.display.Graphics"/>
				<x path="nme.utils.Floats3264"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ count : -1, flags : 0, smooth : false }</e></m></meta>
		</drawTiles>
		<getRect public="1" get="inline" set="null" line="116"><f a="index">
	<x path="Int"/>
	<c path="nme.geom.Rectangle"/>
</f></getRect>
		<addRect public="1" get="inline" set="null" line="118"><f a="rectangle">
	<c path="nme.geom.Rectangle"/>
	<x path="Int"/>
</f></addRect>
		<new public="1" set="method" line="36"><f a="inImage:?rects:?inPoint">
	<c path="nme.display.BitmapData"/>
	<c path="Array"><c path="nme.geom.Rectangle"/></c>
	<c path="nme.geom.Point"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<enum path="nme.display.TriangleCulling" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.errors.Error" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/errors/Error.hx">
		<errorID public="1"><x path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace set="method" line="17"><f a=""><c path="String"/></f></getStackTrace>
		<toString public="1" set="method" line="22"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="11">
			<f a="?inMessage:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.errors.ArgumentError" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/errors/ArgumentError.hx">
		<extends path="nme.errors.Error"/>
		<new public="1" set="method" line="4"><f a="?inMessage:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="nme.errors.EOFError" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/errors/EOFError.hx">
		<extends path="nme.errors.Error"/>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="nme.errors.RangeError" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/errors/RangeError.hx">
		<extends path="nme.errors.Error"/>
		<new public="1" set="method" line="7">
			<f a="?inMessage" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inMessage : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.Event" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/Event.hx">
		<ACTIVATE public="1" get="inline" set="null" expr="&quot;activate&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"activate"</e></m></meta>
		</ACTIVATE>
		<ADDED public="1" get="inline" set="null" expr="&quot;added&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"added"</e></m></meta>
		</ADDED>
		<ADDED_TO_STAGE public="1" get="inline" set="null" expr="&quot;addedToStage&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"addedToStage"</e></m></meta>
		</ADDED_TO_STAGE>
		<CANCEL public="1" get="inline" set="null" expr="&quot;cancel&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"cancel"</e></m></meta>
		</CANCEL>
		<CHANGE public="1" get="inline" set="null" expr="&quot;change&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"change"</e></m></meta>
		</CHANGE>
		<CLOSE public="1" get="inline" set="null" expr="&quot;close&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"close"</e></m></meta>
		</CLOSE>
		<COMPLETE public="1" get="inline" set="null" expr="&quot;complete&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"complete"</e></m></meta>
		</COMPLETE>
		<CONNECT public="1" get="inline" set="null" expr="&quot;connect&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"connect"</e></m></meta>
		</CONNECT>
		<CONTEXT3D_CREATE public="1" get="inline" set="null" expr="&quot;context3DCreate&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"context3DCreate"</e></m></meta>
		</CONTEXT3D_CREATE>
		<CONTEXT3D_LOST public="1" get="inline" set="null" expr="&quot;context3DLost&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"context3DLost"</e></m></meta>
		</CONTEXT3D_LOST>
		<DEACTIVATE public="1" get="inline" set="null" expr="&quot;deactivate&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deactivate"</e></m></meta>
		</DEACTIVATE>
		<ENTER_FRAME public="1" get="inline" set="null" expr="&quot;enterFrame&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"enterFrame"</e></m></meta>
		</ENTER_FRAME>
		<ID3 public="1" get="inline" set="null" expr="&quot;id3&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"id3"</e></m></meta>
		</ID3>
		<INIT public="1" get="inline" set="null" expr="&quot;init&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"init"</e></m></meta>
		</INIT>
		<MOUSE_LEAVE public="1" get="inline" set="null" expr="&quot;mouseLeave&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseLeave"</e></m></meta>
		</MOUSE_LEAVE>
		<OPEN public="1" get="inline" set="null" expr="&quot;open&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"open"</e></m></meta>
		</OPEN>
		<REMOVED public="1" get="inline" set="null" expr="&quot;removed&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"removed"</e></m></meta>
		</REMOVED>
		<REMOVED_FROM_STAGE public="1" get="inline" set="null" expr="&quot;removedFromStage&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"removedFromStage"</e></m></meta>
		</REMOVED_FROM_STAGE>
		<RENDER public="1" get="inline" set="null" expr="&quot;render&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"render"</e></m></meta>
		</RENDER>
		<RESIZE public="1" get="inline" set="null" expr="&quot;resize&quot;" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"resize"</e></m></meta>
		</RESIZE>
		<SCROLL public="1" get="inline" set="null" expr="&quot;scroll&quot;" line="27" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"scroll"</e></m></meta>
		</SCROLL>
		<SELECT public="1" get="inline" set="null" expr="&quot;select&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"select"</e></m></meta>
		</SELECT>
		<SOUND_COMPLETE public="1" get="inline" set="null" expr="&quot;soundComplete&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"soundComplete"</e></m></meta>
		</SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" get="inline" set="null" expr="&quot;tabChildrenChange&quot;" line="30" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabChildrenChange"</e></m></meta>
		</TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" get="inline" set="null" expr="&quot;tabEnabledChange&quot;" line="31" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabEnabledChange"</e></m></meta>
		</TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" get="inline" set="null" expr="&quot;tabIndexChange&quot;" line="32" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabIndexChange"</e></m></meta>
		</TAB_INDEX_CHANGE>
		<UNLOAD public="1" get="inline" set="null" expr="&quot;unload&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"unload"</e></m></meta>
		</UNLOAD>
		<VIDEO_FRAME public="1" get="inline" set="null" expr="&quot;videoFrame&quot;" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"videoFrame"</e></m></meta>
		</VIDEO_FRAME>
		<DPI_CHANGED public="1" get="inline" set="null" expr="&quot;dpiChanged&quot;" line="35" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"dpiChanged"</e></m></meta>
		</DPI_CHANGED>
		<DROP_FILES public="1" get="inline" set="null" expr="&quot;dropFiles&quot;" line="36" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"dropFiles"</e></m></meta>
		</DROP_FILES>
		<bubbles public="1" get="accessor" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" get="accessor" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" get="accessor" set="accessor"><d/></currentTarget>
		<eventPhase public="1" get="accessor" set="null"><x path="Int"/></eventPhase>
		<target public="1" get="accessor" set="accessor"><d/></target>
		<type public="1" get="accessor" set="null"><c path="String"/></type>
		<_bubbles><x path="Bool"/></_bubbles>
		<_cancelable><x path="Bool"/></_cancelable>
		<_currentTarget><d/></_currentTarget>
		<_eventPhase><x path="Int"/></_eventPhase>
		<_target><d/></_target>
		<_type><c path="String"/></_type>
		<nmeIsCancelled><x path="Bool"/></nmeIsCancelled>
		<nmeIsCancelledNow><x path="Bool"/></nmeIsCancelledNow>
		<clickCancelled public="1"><x path="Bool"/></clickCancelled>
		<clone public="1" set="method" line="70"><f a=""><c path="nme.events.Event"/></f></clone>
		<nmeGetIsCancelled public="1" set="method" line="75">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetIsCancelled>
		<nmeGetIsCancelledNow public="1" set="method" line="79">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetIsCancelledNow>
		<nmeSetPhase public="1" set="method" line="83">
			<f a="inPhase">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetPhase>
		<stopImmediatePropagation public="1" set="method" line="88"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method" line="94"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method" line="100"><f a=""><c path="String"/></f></toString>
		<get_bubbles set="method" line="106"><f a=""><x path="Bool"/></f></get_bubbles>
		<get_cancelable set="method" line="107"><f a=""><x path="Bool"/></f></get_cancelable>
		<get_currentTarget set="method" line="108"><f a=""><d/></f></get_currentTarget>
		<set_currentTarget set="method" line="109"><f a="v">
	<d/>
	<d/>
</f></set_currentTarget>
		<get_eventPhase set="method" line="110"><f a=""><x path="Int"/></f></get_eventPhase>
		<get_target set="method" line="111"><f a=""><d/></f></get_target>
		<set_target set="method" line="112"><f a="v">
	<d/>
	<d/>
</f></set_target>
		<get_type set="method" line="113"><f a=""><c path="String"/></f></get_type>
		<new public="1" set="method" line="57">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.AppLinkEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/AppLinkEvent.hx">
		<extends path="nme.events.Event"/>
		<APP_LINK public="1" expr="&quot;appLink&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"appLink"</e></m></meta>
		</APP_LINK>
		<url public="1"><c path="String"/></url>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.MouseEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/MouseEvent.hx">
		<extends path="nme.events.Event"/>
		<DOUBLE_CLICK public="1" get="inline" set="null" expr="&quot;doubleClick&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"doubleClick"</e></m></meta>
		</DOUBLE_CLICK>
		<CLICK public="1" get="inline" set="null" expr="&quot;click&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"click"</e></m></meta>
		</CLICK>
		<MIDDLE_CLICK public="1" get="inline" set="null" expr="&quot;middleClick&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleClick"</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;middleMouseDown&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleMouseDown"</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" get="inline" set="null" expr="&quot;middleMouseUp&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleMouseUp"</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;mouseDown&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseDown"</e></m></meta>
		</MOUSE_DOWN>
		<MOUSE_MOVE public="1" get="inline" set="null" expr="&quot;mouseMove&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseMove"</e></m></meta>
		</MOUSE_MOVE>
		<MOUSE_OUT public="1" get="inline" set="null" expr="&quot;mouseOut&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseOut"</e></m></meta>
		</MOUSE_OUT>
		<MOUSE_OVER public="1" get="inline" set="null" expr="&quot;mouseOver&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseOver"</e></m></meta>
		</MOUSE_OVER>
		<MOUSE_UP public="1" get="inline" set="null" expr="&quot;mouseUp&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseUp"</e></m></meta>
		</MOUSE_UP>
		<MOUSE_WHEEL public="1" get="inline" set="null" expr="&quot;mouseWheel&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseWheel"</e></m></meta>
		</MOUSE_WHEEL>
		<RIGHT_CLICK public="1" get="inline" set="null" expr="&quot;rightClick&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightClick"</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;rightMouseDown&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightMouseDown"</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" get="inline" set="null" expr="&quot;rightMouseUp&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightMouseUp"</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" get="inline" set="null" expr="&quot;rollOut&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rollOut"</e></m></meta>
		</ROLL_OUT>
		<ROLL_OVER public="1" get="inline" set="null" expr="&quot;rollOver&quot;" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rollOver"</e></m></meta>
		</ROLL_OVER>
		<efLeftDown expr="0x0001" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</efLeftDown>
		<efShiftDown expr="0x0002" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</efShiftDown>
		<efCtrlDown expr="0x0004" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</efCtrlDown>
		<efAltDown expr="0x0008" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</efAltDown>
		<efCommandDown expr="0x0010" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</efCommandDown>
		<nmeCreate public="1" set="method" line="68" static="1">
			<f a="inType:inEvent:inLocal:inTarget">
				<c path="String"/>
				<x path="nme.app.AppEvent"/>
				<c path="nme.geom.Point"/>
				<c path="nme.display.InteractiveObject"/>
				<c path="nme.events.MouseEvent"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCreate>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<clickCount public="1"><x path="Int"/></clickCount>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<relatedObject public="1"><c path="nme.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<clone public="1" set="method" line="63" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<nmeCreateSimilar public="1" set="method" line="77">
			<f a="inType:?related:?targ">
				<c path="String"/>
				<c path="nme.display.InteractiveObject"/>
				<c path="nme.display.InteractiveObject"/>
				<c path="nme.events.MouseEvent"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCreateSimilar>
		<toString public="1" set="method" line="89" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="94"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="47">
			<f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:null:false:false:false:false:0:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nme.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clickCount : 0, commandKey : false, delta : 0, buttonDown : false, shiftKey : false, altKey : false, ctrlKey : false, relatedObject : null, localY : 0, localX : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.DropEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/DropEvent.hx">
		<extends path="nme.events.MouseEvent"/>
		<DROP_FILES public="1" expr="&quot;dropFiles&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"dropFiles"</e></m></meta>
		</DROP_FILES>
		<nmeCreate public="1" set="method" line="16" static="1"><f a="inType:inEvent:inLocal:inTarget:inItems">
	<c path="String"/>
	<x path="nme.app.AppEvent"/>
	<c path="nme.geom.Point"/>
	<c path="nme.display.InteractiveObject"/>
	<c path="Array"><c path="String"/></c>
	<c path="nme.events.DropEvent"/>
</f></nmeCreate>
		<items public="1"><c path="Array"><c path="String"/></c></items>
		<clone public="1" set="method" line="32" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nme.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.TextEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/TextEvent.hx">
		<extends path="nme.events.Event"/>
		<LINK public="1" get="inline" set="null" expr="&quot;link&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"link"</e></m></meta>
		</LINK>
		<TEXT_INPUT public="1" get="inline" set="null" expr="&quot;textInput&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"textInput"</e></m></meta>
		</TEXT_INPUT>
		<text public="1" set="null"><c path="String"/></text>
		<clone public="1" set="method" line="19" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable:?text" v=":false:false:&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "", cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.ErrorEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/ErrorEvent.hx">
		<extends path="nme.events.TextEvent"/>
		<ERROR public="1" expr="&quot;error&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"error"</e></m></meta>
		</ERROR>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="11">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:&quot;&quot;:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, text : "", cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.Listener" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/EventDispatcher.hx" module="nme.events.EventDispatcher">
		<sIDs expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</sIDs>
		<mID public="1"><x path="Int"/></mID>
		<mListner public="1"><c path="nme.utils.WeakRef"><t path="nme.events.Function"/></c></mListner>
		<mPriority public="1"><x path="Int"/></mPriority>
		<mUseCapture public="1"><x path="Bool"/></mUseCapture>
		<dispatchEvent public="1" set="method" line="28"><f a="event">
	<c path="nme.events.Event"/>
	<x path="Void"/>
</f></dispatchEvent>
		<Is public="1" set="method" line="35"><f a="inListener:inCapture">
	<t path="nme.events.Function"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></Is>
		<new public="1" set="method" line="20"><f a="inListener:inUseCapture:inPriority:inUseWeakRef">
	<t path="nme.events.Function"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<typedef path="nme.events.ListenerList" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/EventDispatcher.hx" module="nme.events.EventDispatcher"><c path="Array"><c path="nme.events.Listener"/></c></typedef>
	<typedef path="nme.events.EventMap" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/EventDispatcher.hx" module="nme.events.EventDispatcher"><c path="haxe.ds.StringMap"><t path="nme.events.ListenerList"/></c></typedef>
	<class path="nme.events.EventPhase" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/EventPhase.hx">
		<CAPTURING_PHASE public="1" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CAPTURING_PHASE>
		<AT_TARGET public="1" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" expr="2" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BUBBLING_PHASE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.FocusEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/FocusEvent.hx">
		<extends path="nme.events.Event"/>
		<FOCUS_IN public="1" get="inline" set="null" expr="&quot;focusIn&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"focusIn"</e></m></meta>
		</FOCUS_IN>
		<FOCUS_OUT public="1" get="inline" set="null" expr="&quot;focusOut&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"focusOut"</e></m></meta>
		</FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" get="inline" set="null" expr="&quot;keyFocusChange&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyFocusChange"</e></m></meta>
		</KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" get="inline" set="null" expr="&quot;mouseFocusChange&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseFocusChange"</e></m></meta>
		</MOUSE_FOCUS_CHANGE>
		<keyCode public="1" set="null"><x path="Int"/></keyCode>
		<relatedObject public="1" set="null"><c path="nme.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1" set="null"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="27" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="32" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18">
			<f a="inType:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode:?direction" v=":true:false:null:false:0:&quot;none&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nme.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ direction : "none", keyCode : 0, shiftKey : false, relatedObject : null, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.GameInputEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/GameInputEvent.hx">
		<extends path="nme.events.Event"/>
		<DEVICE_ADDED public="1" get="inline" set="null" expr="&quot;deviceAdded&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceAdded"</e></m></meta>
		</DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" expr="&quot;deviceRemoved&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceRemoved"</e></m></meta>
		</DEVICE_REMOVED>
		<DEVICE_UNUSABLE public="1" get="inline" set="null" expr="&quot;deviceUnusable&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceUnusable"</e></m></meta>
		</DEVICE_UNUSABLE>
		<device public="1" set="null"><c path="nme.ui.GameInputDevice"/></device>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<new public="1" set="method" line="16">
			<f a="type:?bubbles:?cancelable:?inDevice" v=":true:false:null">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nme.ui.GameInputDevice"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inDevice : null, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="nme.events.HTTPStatusEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/HTTPStatusEvent.hx">
		<extends path="nme.events.Event"/>
		<HTTP_STATUS public="1" get="inline" set="null" expr="&quot;httpStatus&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"httpStatus"</e></m></meta>
		</HTTP_STATUS>
		<status public="1"><x path="Int"/></status>
		<responseHeaders public="1"><c path="Array"><c path="nme.net.URLRequestHeader"/></c></responseHeaders>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14">
			<f a="inType:?bubbles:?cancelable:?status" v=":false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ status : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<typedef path="nme.events.Function" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/IEventDispatcher.hx" module="nme.events.IEventDispatcher"><f a="">
	<d/>
	<x path="Void"/>
</f></typedef>
	<class path="nme.events.IOErrorEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/IOErrorEvent.hx">
		<extends path="nme.events.ErrorEvent"/>
		<IO_ERROR public="1" get="inline" set="null" expr="&quot;ioError&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ioError"</e></m></meta>
		</IO_ERROR>
		<clone public="1" set="method" line="14" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="19" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9">
			<f a="inType:?bubbles:?cancelable:?text:?id" v=":true:false:&quot;&quot;:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, text : "", cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.JoystickEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/JoystickEvent.hx">
		<extends path="nme.events.Event"/>
		<AXIS_MOVE public="1" get="inline" set="null" expr="&quot;axisMove&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"axisMove"</e></m></meta>
		</AXIS_MOVE>
		<BALL_MOVE public="1" get="inline" set="null" expr="&quot;ballMove&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ballMove"</e></m></meta>
		</BALL_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" expr="&quot;buttonDown&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"buttonDown"</e></m></meta>
		</BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" expr="&quot;buttonUp&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"buttonUp"</e></m></meta>
		</BUTTON_UP>
		<HAT_MOVE public="1" get="inline" set="null" expr="&quot;hatMove&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"hatMove"</e></m></meta>
		</HAT_MOVE>
		<DEVICE_ADDED public="1" get="inline" set="null" expr="&quot;deviceAdded&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceAdded"</e></m></meta>
		</DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" expr="&quot;deviceRemoved&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceRemoved"</e></m></meta>
		</DEVICE_REMOVED>
		<axis public="1" set="null"><c path="Array"><x path="Float"/></c></axis>
		<device public="1"><x path="Int"/></device>
		<id public="1"><x path="Int"/></id>
		<user public="1"><x path="Int"/></user>
		<isGamePad public="1"><x path="Bool"/></isGamePad>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1" get="accessor" set="null"><x path="Float"/></z>
		<w public="1" get="accessor" set="null"><x path="Float"/></w>
		<get_z set="method" line="28"><f a=""><x path="Float"/></f></get_z>
		<get_w set="method" line="32"><f a=""><x path="Float"/></f></get_w>
		<clone public="1" set="method" line="51" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="56" override="1"><f a=""><c path="String"/></f></toString>
		<idLabel public="1" set="method" line="69"><f a=""><c path="String"/></f></idLabel>
		<new public="1" set="method" line="37">
			<f a="type:?bubbles:?cancelable:?device:?id:?userId:?x:?y:?axis:?isGamePad" v=":false:false:0:0:0:0:0:null:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isGamePad : false, axis : null, y : 0, x : 0, userId : 0, id : 0, device : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.KeyboardEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/KeyboardEvent.hx">
		<extends path="nme.events.Event"/>
		<KEY_DOWN public="1" get="inline" set="null" expr="&quot;keyDown&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyDown"</e></m></meta>
		</KEY_DOWN>
		<KEY_UP public="1" get="inline" set="null" expr="&quot;keyUp&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyUp"</e></m></meta>
		</KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="Int"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<controlKey public="1"><x path="Bool"/></controlKey>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<keyCode public="1"><x path="Int"/></keyCode>
		<keyLocation public="1"><x path="Int"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="34" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="19">
			<f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue:?controlKeyValue:?commandKeyValue" v=":false:false:0:0:0:false:false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ commandKeyValue : false, controlKeyValue : false, shiftKeyValue : false, altKeyValue : false, ctrlKeyValue : false, keyLocationValue : 0, keyCodeValue : 0, charCodeValue : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.NetStatusEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/NetStatusEvent.hx">
		<extends path="nme.events.Event"/>
		<NET_STATUS public="1" get="inline" set="null" expr="&quot;netStatus&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"netStatus"</e></m></meta>
		</NET_STATUS>
		<info public="1"><d/></info>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable:?inInfo" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.ProgressEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/ProgressEvent.hx">
		<extends path="nme.events.Event"/>
		<PROGRESS public="1" get="inline" set="null" expr="&quot;progress&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"progress"</e></m></meta>
		</PROGRESS>
		<SOCKET_DATA public="1" get="inline" set="null" expr="&quot;socketData&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"socketData"</e></m></meta>
		</SOCKET_DATA>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="26" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13">
			<f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bytesTotal : 0, bytesLoaded : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.SampleDataEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/SampleDataEvent.hx">
		<extends path="nme.events.Event"/>
		<SAMPLE_DATA public="1" get="inline" set="null" expr="&quot;sampleData&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"sampleData"</e></m></meta>
		</SAMPLE_DATA>
		<data public="1"><c path="nme.utils.ByteArray"/></data>
		<position public="1"><x path="Float"/></position>
		<clone public="1" set="method" line="23" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.StageVideoAvailabilityEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/StageVideoAvailabilityEvent.hx">
		<extends path="nme.events.Event"/>
		<STAGE_VIDEO_AVAILABILITY public="1" get="inline" set="null" expr="&quot;stageVideoAvailability&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"stageVideoAvailability"</e></m></meta>
		</STAGE_VIDEO_AVAILABILITY>
		<availability public="1" set="null"><c path="String"/></availability>
		<new public="1" set="method" line="9">
			<f a="type:?bubbles:?cancelable:?inAvailability" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.SystemEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/SystemEvent.hx">
		<extends path="nme.events.Event"/>
		<SYSTEM public="1" get="inline" set="null" expr="&quot;system&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"system"</e></m></meta>
		</SYSTEM>
		<data public="1" set="null"><x path="Int"/></data>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="nme.events.Event"/></f></clone>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="11">
			<f a="type:?bubbles:?cancelable:?data" v=":false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ data : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.events.TouchEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/events/TouchEvent.hx">
		<extends path="nme.events.MouseEvent"/>
		<TOUCH_BEGIN public="1" get="inline" set="null" expr="&quot;touchBegin&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchBegin"</e></m></meta>
		</TOUCH_BEGIN>
		<TOUCH_END public="1" get="inline" set="null" expr="&quot;touchEnd&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchEnd"</e></m></meta>
		</TOUCH_END>
		<TOUCH_MOVE public="1" get="inline" set="null" expr="&quot;touchMove&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchMove"</e></m></meta>
		</TOUCH_MOVE>
		<TOUCH_OUT public="1" get="inline" set="null" expr="&quot;touchOut&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchOut"</e></m></meta>
		</TOUCH_OUT>
		<TOUCH_OVER public="1" get="inline" set="null" expr="&quot;touchOver&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchOver"</e></m></meta>
		</TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" get="inline" set="null" expr="&quot;touchRollOut&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchRollOut"</e></m></meta>
		</TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" get="inline" set="null" expr="&quot;touchRollOver&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchRollOver"</e></m></meta>
		</TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" get="inline" set="null" expr="&quot;touchTap&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchTap"</e></m></meta>
		</TOUCH_TAP>
		<nmeCreate public="1" set="method" line="36" static="1"><f a="inType:inEvent:inLocal:inTarget:sizeX:sizeY">
	<c path="String"/>
	<x path="nme.app.AppEvent"/>
	<c path="nme.geom.Point"/>
	<c path="nme.display.InteractiveObject"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nme.events.TouchEvent"/>
</f></nmeCreate>
		<isPrimaryTouchPoint public="1"><x path="Bool"/></isPrimaryTouchPoint>
		<touchPointID public="1"><x path="Int"/></touchPointID>
		<sizeX public="1"><x path="Float"/></sizeX>
		<sizeY public="1"><x path="Float"/></sizeY>
		<nmeCreateSimilar public="1" set="method" line="46" override="1"><f a="inType:?related:?targ">
	<c path="String"/>
	<c path="nme.display.InteractiveObject"/>
	<c path="nme.display.InteractiveObject"/>
	<c path="nme.events.MouseEvent"/>
</f></nmeCreateSimilar>
		<new public="1" set="method" line="26">
			<f a="type:?bubbles:?cancelable:?in_localX:?in_localY:?in_sizeX:?in_sizeY:?in_relatedObject:?in_ctrlKey:?in_altKey:?in_shiftKey:?in_buttonDown:?in_delta:?in_commandKey:?in_clickCount" v=":true:false:0:0:1:1:null:false:false:false:false:0:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nme.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ in_clickCount : 0, in_commandKey : false, in_delta : 0, in_buttonDown : false, in_shiftKey : false, in_altKey : false, in_ctrlKey : false, in_relatedObject : null, in_sizeY : 1, in_sizeX : 1, in_localY : 0, in_localX : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.filters.BitmapFilter" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/filters/BitmapFilter.hx">
		<type>
			<c path="String"/>
			<haxe_doc>@private</haxe_doc>
		</type>
		<clone public="1" set="method" line="13"><f a=""><c path="nme.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="8"><f a="inType">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.geom.ColorTransform" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/ColorTransform.hx">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method" line="29"><f a="second">
	<c path="nme.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<get_color set="method" line="38"><f a=""><x path="Int"/></f></get_color>
		<set_color set="method" line="43"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<new public="1" set="method" line="17">
			<f a="?inRedMultiplier:?inGreenMultiplier:?inBlueMultiplier:?inAlphaMultiplier:?inRedOffset:?inGreenOffset:?inBlueOffset:?inAlphaOffset" v="1.0:1.0:1.0:1.0:0.0:0.0:0.0:0.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inAlphaOffset : 0.0, inBlueOffset : 0.0, inGreenOffset : 0.0, inRedOffset : 0.0, inAlphaMultiplier : 1.0, inBlueMultiplier : 1.0, inGreenMultiplier : 1.0, inRedMultiplier : 1.0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.geom.Matrix" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/Matrix.hx">
		<implements path="cpp.rtti.FieldNumericIntegerLookup"/>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<copyFrom public="1" set="method" line="31"><f a="src">
	<c path="nme.geom.Matrix"/>
	<x path="Void"/>
</f></copyFrom>
		<clone public="1" set="method" line="41"><f a=""><c path="nme.geom.Matrix"/></f></clone>
		<concat public="1" set="method" line="58"><f a="m">
	<c path="nme.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<createBox public="1" set="method" line="74"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method" line="83"><f a="in_width:in_height:?rotation:?in_tx:?in_ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method" line="107"><f a="point">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method" line="112"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="122"><f a=""><c path="nme.geom.Matrix"/></f></invert>
		<mult public="1" set="method" line="149"><f a="m">
	<c path="nme.geom.Matrix"/>
	<c path="nme.geom.Matrix"/>
</f></mult>
		<rotate public="1" set="method" line="176"><f a="inTheta">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="201"><f a="inSX:inSY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation public="1" set="method" line="213"><f a="inTheta:?inScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<setTo public="1" set="method" line="222"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<transformPoint public="1" set="method" line="233"><f a="inPos">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method" line="238"><f a="inDX:inDY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<toString public="1" set="method" line="243"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="21"><f a="?in_a:?in_b:?in_c:?in_d:?in_tx:?in_ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.geom.Point" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/Point.hx">
		<distance public="1" set="method" line="53" static="1"><f a="pt1:pt2">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="65" static="1"><f a="pt1:pt2:f">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
	<x path="Float"/>
	<c path="nme.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" line="90" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nme.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="17"><f a="v">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></add>
		<clone public="1" set="method" line="22"><f a=""><c path="nme.geom.Point"/></f></clone>
		<setTo public="1" set="method" line="26"><f a="inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nme.geom.Point"/>
</f></setTo>
		<copyFrom public="1" set="method" line="33"><f a="sourcePoint">
	<c path="nme.geom.Point"/>
	<x path="Void"/>
</f></copyFrom>
		<dist public="1" set="method" line="39"><f a="pt2">
	<c path="nme.geom.Point"/>
	<x path="Float"/>
</f></dist>
		<dist2 public="1" set="method" line="46"><f a="pt2">
	<c path="nme.geom.Point"/>
	<x path="Float"/>
</f></dist2>
		<equals public="1" set="method" line="60"><f a="toCompare">
	<c path="nme.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="70"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="84"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<subtract public="1" set="method" line="95"><f a="v">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></subtract>
		<toString public="1" set="method" line="100"><f a=""><c path="String"/></f></toString>
		<get_length set="method" line="106"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="11">
			<f a="?inX:?inY" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inY : 0, inX : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.geom.Rectangle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></topLeft>
		<centre public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></centre>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method" line="30"><f a="inX:inY:inWidth:inHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<clone public="1" set="method" line="38"><f a=""><c path="nme.geom.Rectangle"/></f></clone>
		<contains public="1" set="method" line="43"><f a="inX:inY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="48"><f a="point">
	<c path="nme.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="53"><f a="rect">
	<c path="nme.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<equals public="1" set="method" line="58"><f a="toCompare">
	<c path="nme.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<extendBounds public="1" set="method" line="63"><f a="r">
	<c path="nme.geom.Rectangle"/>
	<x path="Void"/>
</f></extendBounds>
		<inflate public="1" set="method" line="86"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="92"><f a="point">
	<c path="nme.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="97"><f a="toIntersect">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="112"><f a="toIntersect">
	<c path="nme.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="124"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="129"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="135"><f a="point">
	<c path="nme.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="141"><f a=""><x path="Void"/></f></setEmpty>
		<transform public="1" set="method" line="146"><f a="m">
	<c path="nme.geom.Matrix"/>
	<c path="nme.geom.Rectangle"/>
</f></transform>
		<union public="1" set="method" line="177"><f a="toUnion">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></union>
		<copyFrom public="1" set="method" line="186"><f a="sourceRect">
	<c path="nme.geom.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<get_bottom set="method" line="195"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom set="method" line="196"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_bottomRight set="method" line="197"><f a=""><c path="nme.geom.Point"/></f></get_bottomRight>
		<set_bottomRight set="method" line="198"><f a="p">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_bottomRight>
		<get_left set="method" line="199"><f a=""><x path="Float"/></f></get_left>
		<set_left set="method" line="200"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right set="method" line="201"><f a=""><x path="Float"/></f></get_right>
		<set_right set="method" line="202"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_size set="method" line="203"><f a=""><c path="nme.geom.Point"/></f></get_size>
		<set_size set="method" line="204"><f a="p">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_size>
		<get_top set="method" line="205"><f a=""><x path="Float"/></f></get_top>
		<set_top set="method" line="206"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_topLeft set="method" line="207"><f a=""><c path="nme.geom.Point"/></f></get_topLeft>
		<set_topLeft set="method" line="208"><f a="p">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_topLeft>
		<get_centre set="method" line="209"><f a=""><c path="nme.geom.Point"/></f></get_centre>
		<set_centre set="method" line="210"><f a="p">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_centre>
		<new public="1" set="method" line="20"><f a="?inX:?inY:?inWidth:?inHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.geom.Transform" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/geom/Transform.hx">
		<colorTransform public="1" get="accessor" set="accessor"><c path="nme.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" get="accessor" set="null"><c path="nme.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" get="accessor" set="null"><c path="nme.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor"><c path="nme.geom.Matrix"/></matrix>
		<pixelBounds public="1" get="accessor" set="null"><c path="nme.geom.Rectangle"/></pixelBounds>
		<nmeObj>
			<c path="nme.display.DisplayObject"/>
			<haxe_doc>@private</haxe_doc>
		</nmeObj>
		<get_colorTransform set="method" line="22"><f a=""><c path="nme.geom.ColorTransform"/></f></get_colorTransform>
		<set_colorTransform set="method" line="23"><f a="inTrans">
	<c path="nme.geom.ColorTransform"/>
	<c path="nme.geom.ColorTransform"/>
</f></set_colorTransform>
		<get_concatenatedColorTransform set="method" line="24"><f a=""><c path="nme.geom.ColorTransform"/></f></get_concatenatedColorTransform>
		<get_concatenatedMatrix set="method" line="25"><f a=""><c path="nme.geom.Matrix"/></f></get_concatenatedMatrix>
		<get_matrix set="method" line="26"><f a=""><c path="nme.geom.Matrix"/></f></get_matrix>
		<set_matrix set="method" line="27"><f a="inMatrix">
	<c path="nme.geom.Matrix"/>
	<c path="nme.geom.Matrix"/>
</f></set_matrix>
		<get_pixelBounds set="method" line="28"><f a=""><c path="nme.geom.Rectangle"/></f></get_pixelBounds>
		<new public="1" set="method" line="16"><f a="inParent">
	<c path="nme.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.image.PixelFormat" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/image/PixelFormat.hx">
		<pfNone public="1" get="inline" set="null" expr="-1" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</pfNone>
		<pfRGB public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pfRGB>
		<pfBGRA public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pfBGRA>
		<pfBGRPremA public="1" get="inline" set="null" expr="2" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</pfBGRPremA>
		<pfAlpha public="1" get="inline" set="null" expr="3" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</pfAlpha>
		<pfRenderToCount public="1" get="inline" set="null" expr="4" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</pfRenderToCount>
		<pfLuma public="1" get="inline" set="null" expr="4" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</pfLuma>
		<pfLumaAlpha public="1" get="inline" set="null" expr="5" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</pfLumaAlpha>
		<pfRGB32f public="1" get="inline" set="null" expr="6" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</pfRGB32f>
		<pfRGBA32f public="1" get="inline" set="null" expr="7" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</pfRGBA32f>
		<pfRGBPremA public="1" get="inline" set="null" expr="8" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</pfRGBPremA>
		<pfRGBA public="1" get="inline" set="null" expr="9" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</pfRGBA>
		<pfUInt16 public="1" get="inline" set="null" expr="10" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</pfUInt16>
		<pfUInt32 public="1" get="inline" set="null" expr="11" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</pfUInt32>
		<channelCount public="1" set="method" line="36" static="1"><f a="inFormat">
	<x path="Int"/>
	<x path="Int"/>
</f></channelCount>
	</class>
	<class path="nme.macros.Prime" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/macros/Prime.hx">
		<_loadPrime public="1" set="method" line="47" static="1">
			<f a="lib:prim:signature:?quietFail" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ quietFail : false }</e></m>
			</meta>
		</_loadPrime>
		<load public="1" set="method" static="1"><f a="inModule:inName:inSig:inAllowFail">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></load>
		<meta><m n=":noPackageRestrict"/></meta>
	</class>
	<enum path="nme.media.AudioSampleFormat" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/AudioSampleFormat.hx">
		<UInt8/>
		<SInt16/>
		<Float32/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.media.ID3Info" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/ID3Info.hx">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<enum path="nme.media.SampleRate" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/SampleRate.hx">
		<Rate11025/>
		<Rate22050/>
		<Rate44100/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.media.Sound" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/Sound.hx">
		<extends path="nme.events.EventDispatcher"/>
		<nme_sound_from_file expr="Loader.load(&quot;nme_sound_from_file&quot;, 3)" line="254" static="1">
			<f a="::">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Null"><c path="String"/></x>
				<t path="nme.NativeHandle"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sound_from_file", 3)</e></m></meta>
		</nme_sound_from_file>
		<nme_sound_from_data expr="Loader.load(&quot;nme_sound_from_data&quot;, 4)" line="255" static="1">
			<f a=":::">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="String"/></x>
				<t path="nme.NativeHandle"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sound_from_data", 4)</e></m></meta>
		</nme_sound_from_data>
		<nme_sound_get_id3 expr="nme.PrimeLoader.load(&quot;nme_sound_get_id3&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_sound_get_id3", "oov")</e></m></meta>
		</nme_sound_get_id3>
		<nme_sound_get_length expr="nme.PrimeLoader.load(&quot;nme_sound_get_length&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_sound_get_length", "od")</e></m></meta>
		</nme_sound_get_length>
		<nme_sound_close expr="nme.PrimeLoader.load(&quot;nme_sound_close&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_sound_close", "ov")</e></m></meta>
		</nme_sound_close>
		<nme_sound_get_status expr="nme.PrimeLoader.load(&quot;nme_sound_get_status&quot;, &quot;oo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_sound_get_status", "oo")</e></m></meta>
		</nme_sound_get_status>
		<nme_sound_get_engine expr="Loader.load(&quot;nme_sound_get_engine&quot;, 1)" line="260" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sound_get_engine", 1)</e></m></meta>
		</nme_sound_get_engine>
		<nme_sound_channel_create_dynamic expr="nme.PrimeLoader.load(&quot;nme_sound_channel_create_dynamic&quot;, &quot;ooo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>nme.PrimeLoader.load("nme_sound_channel_create_dynamic", "ooo")</e></m></meta>
		</nme_sound_channel_create_dynamic>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" get="accessor" set="null"><c path="nme.media.ID3Info"/></id3>
		<isBuffering public="1" get="accessor" set="null"><x path="Bool"/></isBuffering>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<nmeHandle public="1"><t path="nme.NativeHandle"/></nmeHandle>
		<nmeLoading><x path="Bool"/></nmeLoading>
		<nmeDynamicSound><x path="Bool"/></nmeDynamicSound>
		<getEngine public="1" set="method" line="51"><f a=""><unknown/></f></getEngine>
		<addEventListener public="1" set="method" line="57" override="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<t path="nme.events.Function"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<close public="1" set="method" line="71"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="81">
			<f a="stream:?context:?forcePlayAsMusic:?inEngine" v="::false:">
				<c path="nme.net.URLRequest"/>
				<c path="nme.media.SoundLoaderContext"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forcePlayAsMusic : false }</e></m></meta>
		</load>
		<loadCompressedDataFromByteArray public="1" set="method" line="100">
			<f a="bytes:length:?forcePlayAsMusic:?inEngine" v="::false:">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forcePlayAsMusic : false }</e></m></meta>
		</loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="115">
			<f a="Bytes:samples:?format:?stereo:?sampleRate:?inEngine" v="::&quot;float&quot;:true:44100.0:">
				<c path="nme.utils.ByteArray"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sampleRate : 44100.0, stereo : true, format : "float" }</e></m></meta>
		</loadPCMFromByteArray>
		<nmeCheckLoading set="method" line="160"><f a=""><x path="Void"/></f></nmeCheckLoading>
		<nmeOnError set="method" line="181"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></nmeOnError>
		<play public="1" set="method" line="187">
			<f a="?startTime:?loops:?sndTransform" v="0:0:">
				<x path="Float"/>
				<x path="Int"/>
				<c path="nme.media.SoundTransform"/>
				<c path="nme.media.SoundChannel"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<get_id3 set="method" line="227"><f a=""><c path="nme.media.ID3Info"/></f></get_id3>
		<get_isBuffering set="method" line="239"><f a=""><x path="Bool"/></f></get_isBuffering>
		<get_length set="method" line="245"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="30">
			<f a="?stream:?context:?forcePlayAsMusic:?inEngine" v="::false:">
				<c path="nme.net.URLRequest"/>
				<c path="nme.media.SoundLoaderContext"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forcePlayAsMusic : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
			<m n=":autoBuild"><e>nme.macros.Embed.embedAsset("NME_sound_", ":sound")</e></m>
		</meta>
	</class>
	<class path="nme.media.SoundChannel" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/SoundChannel.hx">
		<extends path="nme.events.EventDispatcher"/>
		<nmeDynamicSoundCount public="1" expr="0" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>@private</haxe_doc>
		</nmeDynamicSoundCount>
		<nmeIncompleteList expr="new Array&lt;SoundChannel&gt;()" line="21" static="1">
			<c path="Array"><c path="nme.media.SoundChannel"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<SoundChannel>()]]></e></m></meta>
		</nmeIncompleteList>
		<nmeIsPolling expr="false" line="22" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</nmeIsPolling>
		<createAsync public="1" set="method" line="52" static="1"><f a="inRate:inIsStereo:sampleFormat:asyncDataRequired:?inEngine">
	<e path="nme.media.SampleRate"/>
	<x path="Bool"/>
	<e path="nme.media.AudioSampleFormat"/>
	<f a=""><x path="Void"/></f>
	<c path="String"/>
	<c path="nme.media.SoundChannel"/>
</f></createAsync>
		<createDynamic public="1" set="method" line="62" static="1"><f a="inSoundHandle:sndTransform:dataProvider">
	<t path="nme.NativeHandle"/>
	<c path="nme.media.SoundTransform"/>
	<c path="nme.events.EventDispatcher"/>
	<c path="nme.media.SoundChannel"/>
</f></createDynamic>
		<nmeCompletePending public="1" set="method" line="109" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCompletePending>
		<nmePollComplete public="1" set="method" line="120" static="1"><f a=""><x path="Void"/></f></nmePollComplete>
		<nme_sound_channel_is_complete expr="PrimeLoader.load(&quot;nme_sound_channel_is_complete&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_is_complete", "ob")</e></m></meta>
		</nme_sound_channel_is_complete>
		<nme_sound_channel_get_left expr="PrimeLoader.load(&quot;nme_sound_channel_get_left&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_get_left", "od")</e></m></meta>
		</nme_sound_channel_get_left>
		<nme_sound_channel_get_right expr="PrimeLoader.load(&quot;nme_sound_channel_get_right&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_get_right", "od")</e></m></meta>
		</nme_sound_channel_get_right>
		<nme_sound_channel_get_position expr="PrimeLoader.load(&quot;nme_sound_channel_get_position&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_get_position", "od")</e></m></meta>
		</nme_sound_channel_get_position>
		<nme_sound_channel_set_position expr="PrimeLoader.load(&quot;nme_sound_channel_set_position&quot;, &quot;odv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_set_position", "odv")</e></m></meta>
		</nme_sound_channel_set_position>
		<nme_sound_channel_get_data_position expr="PrimeLoader.load(&quot;nme_sound_channel_get_data_position&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_get_data_position", "od")</e></m></meta>
		</nme_sound_channel_get_data_position>
		<nme_sound_channel_stop expr="PrimeLoader.load(&quot;nme_sound_channel_stop&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_stop", "ov")</e></m></meta>
		</nme_sound_channel_stop>
		<nme_sound_channel_create expr="PrimeLoader.load(&quot;nme_sound_channel_create&quot;, &quot;odioo&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Float"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_create", "odioo")</e></m></meta>
		</nme_sound_channel_create>
		<nme_sound_channel_set_transform expr="PrimeLoader.load(&quot;nme_sound_channel_set_transform&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_set_transform", "oov")</e></m></meta>
		</nme_sound_channel_set_transform>
		<nme_sound_channel_needs_data expr="PrimeLoader.load(&quot;nme_sound_channel_needs_data&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_needs_data", "ob")</e></m></meta>
		</nme_sound_channel_needs_data>
		<nme_sound_channel_add_data expr="PrimeLoader.load(&quot;nme_sound_channel_add_data&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_add_data", "oov")</e></m></meta>
		</nme_sound_channel_add_data>
		<nme_sound_channel_create_async expr="nme.Loader.load(&quot;nme_sound_channel_create_async&quot;, 5)" line="196" static="1">
			<f a="::::">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<x path="Null"><c path="String"/></x>
				<t path="nme.NativeHandle"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_sound_channel_create_async", 5)</e></m></meta>
		</nme_sound_channel_create_async>
		<nme_sound_channel_post_buffer expr="PrimeLoader.load(&quot;nme_sound_channel_post_buffer&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_sound_channel_post_buffer", "oov")</e></m></meta>
		</nme_sound_channel_post_buffer>
		<leftPeak public="1" get="accessor" set="null"><x path="Float"/></leftPeak>
		<rightPeak public="1" get="accessor" set="null"><x path="Float"/></rightPeak>
		<position public="1" get="accessor" set="accessor"><x path="Float"/></position>
		<soundTransform public="1" get="accessor" set="accessor"><c path="nme.media.SoundTransform"/></soundTransform>
		<pitch public="1"><x path="Float"/></pitch>
		<nmeStopped><x path="Bool"/></nmeStopped>
		<nmeHandle public="1">
			<t path="nme.NativeHandle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<nmeTransform>
			<c path="nme.media.SoundTransform"/>
			<haxe_doc>@private</haxe_doc>
		</nmeTransform>
		<nmeDataProvider public="1">
			<c path="nme.events.EventDispatcher"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDataProvider>
		<postBuffer public="1" set="method" line="74"><f a="inData">
	<c path="nme.utils.ByteArray"/>
	<x path="Void"/>
</f></postBuffer>
		<nmeCheckComplete set="method" line="80">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckComplete>
		<dispatchComplete set="method" line="113"><f a=""><x path="Void"/></f></dispatchComplete>
		<stop public="1" set="method" line="151"><f a=""><x path="Void"/></f></stop>
		<get_leftPeak set="method" line="160"><f a=""><x path="Float"/></f></get_leftPeak>
		<get_rightPeak set="method" line="161"><f a=""><x path="Float"/></f></get_rightPeak>
		<get_position set="method" line="162"><f a=""><x path="Float"/></f></get_position>
		<set_position set="method" line="163"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<get_soundTransform set="method" line="165"><f a=""><c path="nme.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="175"><f a="inTransform">
	<c path="nme.media.SoundTransform"/>
	<c path="nme.media.SoundTransform"/>
</f></set_soundTransform>
		<new public="1" set="method" line="30"><f a="inSoundHandle:startTime:loops:sndTransform">
	<t path="nme.NativeHandle"/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="nme.media.SoundTransform"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.media.SoundLoaderContext" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/SoundLoaderContext.hx"><new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new></class>
	<class path="nme.media.SoundTransform" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/SoundTransform.hx">
		<pan public="1"><x path="Float"/></pan>
		<volume public="1"><x path="Float"/></volume>
		<clone public="1" set="method" line="16"><f a=""><c path="nme.media.SoundTransform"/></f></clone>
		<new public="1" set="method" line="10">
			<f a="?vol:?panning" v="1.0:0.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ panning : 0.0, vol : 1.0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.media.StageVideo" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/media/StageVideo.hx">
		<extends path="nme.events.EventDispatcher"/>
		<playComplete get="inline" set="null" expr="&quot;NetStream.Play.Complete&quot;" line="27" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.Complete"</e></m></meta>
		</playComplete>
		<playSwitch get="inline" set="null" expr="&quot;NetStream.Play.Switch&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.Switch"</e></m></meta>
		</playSwitch>
		<playTransitionComplete get="inline" set="null" expr="&quot;NetStream.Play.TransitionComplete&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.TransitionComplete"</e></m></meta>
		</playTransitionComplete>
		<playStart get="inline" set="null" expr="&quot;NetStream.Play.Start&quot;" line="30" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.Start"</e></m></meta>
		</playStart>
		<playStop get="inline" set="null" expr="&quot;NetStream.Play.Stop&quot;" line="31" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.Stop"</e></m></meta>
		</playStop>
		<playStreamNotFound get="inline" set="null" expr="&quot;NetStream.Play.StreamNotFound&quot;" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.StreamNotFound"</e></m></meta>
		</playStreamNotFound>
		<playFailed get="inline" set="null" expr="&quot;NetStream.Play.Failed&quot;" line="35" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Play.Failed"</e></m></meta>
		</playFailed>
		<seekFailed get="inline" set="null" expr="&quot;NetStream.Seek.Failed&quot;" line="37" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Seek.Failed"</e></m></meta>
		</seekFailed>
		<seekNotify get="inline" set="null" expr="&quot;NetStream.Seek.Notify&quot;" line="38" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Seek.Notify"</e></m></meta>
		</seekNotify>
		<seekInvalidTime get="inline" set="null" expr="&quot;NetStream.Seek.InvalidTime&quot;" line="39" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Seek.InvalidTime"</e></m></meta>
		</seekInvalidTime>
		<failed get="inline" set="null" expr="&quot;NetStream.Failed&quot;" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NetStream.Failed"</e></m></meta>
		</failed>
		<PAUSE get="inline" set="null" expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</PAUSE>
		<RESUME get="inline" set="null" expr="1" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</RESUME>
		<TOGGLE get="inline" set="null" expr="2" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</TOGGLE>
		<PAUSE_LEN get="inline" set="null" expr="-3" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</PAUSE_LEN>
		<ALL_LEN get="inline" set="null" expr="-1" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</ALL_LEN>
		<PLAY_STATUS_COMPLETE get="inline" set="null" expr="0" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</PLAY_STATUS_COMPLETE>
		<PLAY_STATUS_SWITCH get="inline" set="null" expr="1" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</PLAY_STATUS_SWITCH>
		<PLAY_STATUS_TRANSITION get="inline" set="null" expr="2" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</PLAY_STATUS_TRANSITION>
		<PLAY_STATUS_ERROR get="inline" set="null" expr="3" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</PLAY_STATUS_ERROR>
		<PLAY_STATUS_NOT_STARTED get="inline" set="null" expr="4" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</PLAY_STATUS_NOT_STARTED>
		<PLAY_STATUS_STARTED get="inline" set="null" expr="5" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</PLAY_STATUS_STARTED>
		<PLAY_STATUS_STOPPED get="inline" set="null" expr="6" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</PLAY_STATUS_STOPPED>
		<SEEK_FINISHED_OK get="inline" set="null" expr="0" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</SEEK_FINISHED_OK>
		<SEEK_FINISHED_EARLY get="inline" set="null" expr="1" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</SEEK_FINISHED_EARLY>
		<SEEK_FINISHED_ERROR get="inline" set="null" expr="2" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</SEEK_FINISHED_ERROR>
		<nme_sv_create expr="Loader.load(&quot;nme_sv_create&quot;, 2)" line="350" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<c path="nme.media.StageVideo"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_create", 2)</e></m></meta>
		</nme_sv_create>
		<nme_sv_destroy expr="Loader.load(&quot;nme_sv_destroy&quot;, 1)" line="351" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_destroy", 1)</e></m></meta>
		</nme_sv_destroy>
		<nme_sv_action expr="Loader.load(&quot;nme_sv_action&quot;, 2)" line="352" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_action", 2)</e></m></meta>
		</nme_sv_action>
		<nme_sv_play expr="Loader.load(&quot;nme_sv_play&quot;, 4)" line="353" static="1">
			<f a=":::">
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_play", 4)</e></m></meta>
		</nme_sv_play>
		<nme_sv_seek expr="Loader.load(&quot;nme_sv_seek&quot;, 2)" line="354" static="1">
			<f a=":">
				<d/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_seek", 2)</e></m></meta>
		</nme_sv_seek>
		<nme_sv_get_time expr="Loader.load(&quot;nme_sv_get_time&quot;, 1)" line="355" static="1">
			<f a="">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_get_time", 1)</e></m></meta>
		</nme_sv_get_time>
		<nme_sv_get_buffered_percent expr="Loader.load(&quot;nme_sv_get_buffered_percent&quot;, 1)" line="356" static="1">
			<f a="">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_get_buffered_percent", 1)</e></m></meta>
		</nme_sv_get_buffered_percent>
		<nme_sv_viewport expr="Loader.load(&quot;nme_sv_viewport&quot;, 5)" line="357" static="1">
			<f a="::::">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_viewport", 5)</e></m></meta>
		</nme_sv_viewport>
		<nme_sv_pan expr="Loader.load(&quot;nme_sv_pan&quot;, 3)" line="358" static="1">
			<f a="::">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_pan", 3)</e></m></meta>
		</nme_sv_pan>
		<nme_sv_zoom expr="Loader.load(&quot;nme_sv_zoom&quot;, 3)" line="359" static="1">
			<f a="::">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_zoom", 3)</e></m></meta>
		</nme_sv_zoom>
		<nme_sv_set_sound_transform expr="Loader.load(&quot;nme_sv_set_sound_transform&quot;, 3)" line="360" static="1">
			<f a="::">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_sv_set_sound_transform", 3)</e></m></meta>
		</nme_sv_set_sound_transform>
		<colorSpaces public="1" get="accessor" set="null"><x path="nme.Vector"><c path="String"/></x></colorSpaces>
		<depth public="1"><x path="Int"/></depth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<duration public="1" set="null"><x path="Float"/></duration>
		<viewPort public="1" get="accessor" set="accessor"><c path="nme.geom.Rectangle"/></viewPort>
		<pan public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></pan>
		<zoom public="1" get="accessor" set="accessor"><c path="nme.geom.Point"/></zoom>
		<seekFrom><x path="Float"/></seekFrom>
		<seekCode><x path="Int"/></seekCode>
		<nmeHandle><d/></nmeHandle>
		<nmePan><c path="nme.geom.Point"/></nmePan>
		<nmeZoom><c path="nme.geom.Point"/></nmeZoom>
		<nmeViewport><c path="nme.geom.Rectangle"/></nmeViewport>
		<nmeNetStream><c path="nme.net.NetStream"/></nmeNetStream>
		<nmeStage><c path="nme.display.Stage"/></nmeStage>
		<get_colorSpaces set="method" line="86"><f a=""><x path="nme.Vector"><c path="String"/></x></f></get_colorSpaces>
		<attachNetStream public="1" set="method" line="95"><f a="inNetStream">
	<c path="nme.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<get_pan set="method" line="114"><f a=""><c path="nme.geom.Point"/></f></get_pan>
		<set_pan set="method" line="115"><f a="inPan">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_pan>
		<get_zoom set="method" line="124"><f a=""><c path="nme.geom.Point"/></f></get_zoom>
		<set_zoom set="method" line="125"><f a="inZoom">
	<c path="nme.geom.Point"/>
	<c path="nme.geom.Point"/>
</f></set_zoom>
		<get_viewPort set="method" line="135"><f a=""><c path="nme.geom.Rectangle"/></f></get_viewPort>
		<set_viewPort set="method" line="136"><f a="inVp">
	<c path="nme.geom.Rectangle"/>
	<c path="nme.geom.Rectangle"/>
</f></set_viewPort>
		<nmeCreate public="1" set="method" line="147"><f a=""><x path="Bool"/></f></nmeCreate>
		<nmeDestroy public="1" set="method" line="159"><f a=""><x path="Void"/></f></nmeDestroy>
		<nmeGetTime public="1" set="method" line="171"><f a=""><x path="Float"/></f></nmeGetTime>
		<nmeSeek public="1" set="method" line="178"><f a="inTime">
	<x path="Float"/>
	<x path="Void"/>
</f></nmeSeek>
		<nmePlay public="1" set="method" line="185">
			<f a="inUrl:?inStart:?inLength" v=":0:-1">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inLength : -1, inStart : 0 }</e></m></meta>
		</nmePlay>
		<nmePause public="1" set="method" line="196"><f a=""><x path="Void"/></f></nmePause>
		<nmeTogglePause public="1" set="method" line="202"><f a=""><x path="Void"/></f></nmeTogglePause>
		<nmeResume public="1" set="method" line="208"><f a=""><x path="Void"/></f></nmeResume>
		<nmeSetVolume public="1" set="method" line="215"><f a="inVolume">
	<x path="Float"/>
	<x path="Void"/>
</f></nmeSetVolume>
		<nmeGetBytesTotal public="1" set="method" line="221"><f a=""><x path="Int"/></f></nmeGetBytesTotal>
		<nmeGetDecodedFrames public="1" set="method" line="229"><f a=""><x path="Int"/></f></nmeGetDecodedFrames>
		<nmeGetBytesLoaded public="1" set="method" line="236"><f a=""><x path="Int"/></f></nmeGetBytesLoaded>
		<nmeSetSoundTransform public="1" set="method" line="248"><f a="inVolume:inRightness">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></nmeSetSoundTransform>
		<_native_meta_data set="method" line="255">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</_native_meta_data>
		<_native_set_data set="method" line="265">
			<f a="inWidth:inHeight:inDuration">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</_native_set_data>
		<_native_play_status set="method" line="273">
			<f a="inStatus">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</_native_play_status>
		<_native_on_seek set="method" line="318">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</_native_on_seek>
		<_native_on_seek_data set="method" line="341">
			<f a="inCode:inWhen">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</_native_on_seek_data>
		<new public="1" set="method" line="73"><f a="inStage">
	<c path="nme.display.Stage"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.native.Include" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/native/Include.hx"><meta>
	<m n=":buildXml"><e><![CDATA["\r\n   <files id='haxe'>\r\n      <compilerflag value='-I${haxelib:nme}/include'/>\r\n      <compilerflag value='-I${haxelib:nme}/../include'/>\r\n      <compilerflag value='-DHX_UNDEFINE_H'/>\r\n   </files>\r\n"]]></e></m>
	<m n=":keep"/>
</meta></class>
	<class path="nme.native.NativeEvent" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/native/NativeEvent.hx" extern="1">
		<type public="1"><x path="Int"/></type>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<value public="1"><x path="Int"/></value>
		<code public="1"><x path="Int"/></code>
		<id public="1"><x path="Int"/></id>
		<flags public="1"><x path="Int"/></flags>
		<result public="1"><x path="Int"/></result>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<deltaX public="1"><x path="Float"/></deltaX>
		<deltaY public="1"><x path="Float"/></deltaY>
		<pollTime public="1"><x path="Float"/></pollTime>
		<utf8Text public="1"><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></utf8Text>
		<utf8Length public="1"><x path="Int"/></utf8Length>
		<meta>
			<m n=":structAccess"/>
			<m n=":include"><e>"nme/Event.h"</e></m>
			<m n=":native"><e>"nme::Event"</e></m>
		</meta>
	</class>
	<class path="nme.net.NetConnection" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/NetConnection.hx">
		<extends path="nme.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" get="accessor" set="null"><x path="Bool"/></connected>
		<objectEncoding public="1" set="null"><x path="Int"/></objectEncoding>
		<uri public="1" set="null"><c path="String"/></uri>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<proxyType public="1" get="accessor" set="accessor"><c path="String"/></proxyType>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<connect public="1" set="method" line="27"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<close public="1" set="method" line="34"><f a=""><x path="Void"/></f></close>
		<get_connected set="method" line="37"><f a=""><x path="Bool"/></f></get_connected>
		<get_proxyType set="method" line="38"><f a=""><c path="String"/></f></get_proxyType>
		<set_proxyType set="method" line="39"><f a="inType">
	<c path="String"/>
	<c path="String"/>
</f></set_proxyType>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.net.NetStream" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/NetStream.hx">
		<extends path="nme.events.EventDispatcher"/>
		<CONNECT_TO_FMS get="inline" set="null" expr="&quot;connectToFMS&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"connectToFMS"</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS get="inline" set="null" expr="&quot;directConnections&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"directConnections"</e></m></meta>
		</DIRECT_CONNECTIONS>
		<bytesTotal public="1" get="accessor" set="null"><x path="Int"/></bytesTotal>
		<bytesLoaded public="1" get="accessor" set="null"><x path="Int"/></bytesLoaded>
		<decodedFrames public="1" get="accessor" set="null"><x path="Int"/></decodedFrames>
		<client public="1"><d/></client>
		<objectEncoding public="1" set="null"><x path="Int"/></objectEncoding>
		<peerStreams public="1" get="accessor" set="null"><c path="Array"><d/></c></peerStreams>
		<time public="1" get="accessor" set="null"><x path="Float"/></time>
		<soundTransform public="1" get="accessor" set="accessor"><c path="nme.media.SoundTransform"/></soundTransform>
		<nmeConnection public="1"><c path="nme.net.NetConnection"/></nmeConnection>
		<nmeReceiveAudio public="1"><x path="Bool"/></nmeReceiveAudio>
		<nmeReceiveVideo public="1"><x path="Bool"/></nmeReceiveVideo>
		<nmeVolume public="1"><x path="Float"/></nmeVolume>
		<nmeSoundPan public="1"><x path="Float"/></nmeSoundPan>
		<nmeFilename public="1"><c path="String"/></nmeFilename>
		<nmePaused public="1"><x path="Bool"/></nmePaused>
		<nmeSeek public="1"><x path="Float"/></nmeSeek>
		<nmeAttachedVideo public="1"><c path="nme.media.StageVideo"/></nmeAttachedVideo>
		<attach public="1" set="method" line="48"><f a="inConnection">
	<c path="nme.net.NetConnection"/>
	<x path="Void"/>
</f></attach>
		<get_time public="1" set="method" line="52"><f a=""><x path="Float"/></f></get_time>
		<seek public="1" set="method" line="58"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<close public="1" set="method" line="64"><f a=""><x path="Void"/></f></close>
		<dispose public="1" set="method" line="71"><f a=""><x path="Void"/></f></dispose>
		<play public="1" set="method" line="73">
			<f a="?inFilename:?startSeconds:?lenSeconds:?p4:?p5" v=":0.0:-1::">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lenSeconds : -1, startSeconds : 0.0 }</e></m></meta>
		</play>
		<pause public="1" set="method" line="82"><f a=""><x path="Void"/></f></pause>
		<togglePause public="1" set="method" line="88"><f a=""><x path="Void"/></f></togglePause>
		<resume public="1" set="method" line="94"><f a=""><x path="Void"/></f></resume>
		<receiveAudio public="1" set="method" line="100"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method" line="104"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<onPeerConnect public="1" set="method" line="109"><f a="subscriber">
	<c path="nme.net.NetStream"/>
	<x path="Bool"/>
</f></onPeerConnect>
		<get_bytesTotal set="method" line="111"><f a=""><x path="Int"/></f></get_bytesTotal>
		<get_bytesLoaded set="method" line="117"><f a=""><x path="Int"/></f></get_bytesLoaded>
		<get_decodedFrames set="method" line="123"><f a=""><x path="Int"/></f></get_decodedFrames>
		<get_peerStreams set="method" line="129"><f a=""><c path="Array"><d/></c></f></get_peerStreams>
		<get_soundTransform set="method" line="131"><f a=""><c path="nme.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="137"><f a="inTransform">
	<c path="nme.media.SoundTransform"/>
	<c path="nme.media.SoundTransform"/>
</f></set_soundTransform>
		<new public="1" set="method" line="35"><f a="?inConnection:?peerID">
	<c path="nme.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<typedef path="nme.net.HttpHandle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLLoader.hx" module="nme.net.URLLoader"><t path="nme.NativeHandle"/></typedef>
	<enum path="nme.net.URLLoaderDataFormat" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLLoaderDataFormat.hx">
		<BINARY/>
		<TEXT/>
		<VARIABLES/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.net.URLRequest" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLRequest.hx">
		<AUTH_BASIC public="1" get="inline" set="null" expr="0x0001" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</AUTH_BASIC>
		<AUTH_DIGEST public="1" get="inline" set="null" expr="0x0002" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</AUTH_DIGEST>
		<AUTH_GSSNEGOTIATE public="1" get="inline" set="null" expr="0x0004" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</AUTH_GSSNEGOTIATE>
		<AUTH_NTLM public="1" get="inline" set="null" expr="0x0008" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</AUTH_NTLM>
		<AUTH_DIGEST_IE public="1" get="inline" set="null" expr="0x0010" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</AUTH_DIGEST_IE>
		<AUTH_DIGEST_ANY public="1" get="inline" set="null" expr="0x000f" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x000f</e></m></meta>
		</AUTH_DIGEST_ANY>
		<nme_get_url expr="Loader.load(&quot;nme_get_url&quot;, 1)" line="114" static="1">
			<f a="">
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Loader.load("nme_get_url", 1)</e></m></meta>
		</nme_get_url>
		<url public="1"><c path="String"/></url>
		<userAgent public="1"><c path="String"/></userAgent>
		<requestHeaders public="1"><c path="Array"><c path="nme.net.URLRequestHeader"/></c></requestHeaders>
		<authType public="1"><x path="Int"/></authType>
		<cookieString public="1"><c path="String"/></cookieString>
		<verbose public="1"><x path="Bool"/></verbose>
		<method public="1"><c path="String"/></method>
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<credentials public="1"><c path="String"/></credentials>
		<followRedirects public="1"><x path="Bool"/></followRedirects>
		<__bytes public="1">
			<c path="nme.utils.ByteArray"/>
			<haxe_doc>@private</haxe_doc>
		</__bytes>
		<nmeBytes public="1" get="accessor" set="accessor">
			<c path="nme.utils.ByteArray"/>
			<haxe_doc>@private</haxe_doc>
		</nmeBytes>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<launchBrowser public="1" set="method" line="50"><f a=""><x path="Void"/></f></launchBrowser>
		<basicAuth public="1" set="method" line="56"><f a="inUser:inPasswd">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></basicAuth>
		<digestAuth public="1" set="method" line="62"><f a="inUser:inPasswd">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></digestAuth>
		<nmePrepare public="1" set="method" line="68">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmePrepare>
		<get_nmeBytes set="method" line="111"><f a=""><c path="nme.utils.ByteArray"/></f></get_nmeBytes>
		<set_nmeBytes set="method" line="112"><f a="value">
	<c path="nme.utils.ByteArray"/>
	<c path="nme.utils.ByteArray"/>
</f></set_nmeBytes>
		<new public="1" set="method" line="32"><f a="?inURL">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.net.URLRequestHeader" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="10"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.net.URLRequestMethod" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLRequestMethod.hx">
		<DELETE public="1" get="inline" set="null" expr="&quot;DELETE&quot;" line="6" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"DELETE"</e></m></meta>
		</DELETE>
		<GET public="1" get="inline" set="null" expr="&quot;GET&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"GET"</e></m></meta>
		</GET>
		<HEAD public="1" get="inline" set="null" expr="&quot;HEAD&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"HEAD"</e></m></meta>
		</HEAD>
		<OPTIONS public="1" get="inline" set="null" expr="&quot;OPTIONS&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"OPTIONS"</e></m></meta>
		</OPTIONS>
		<POST public="1" get="inline" set="null" expr="&quot;POST&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"POST"</e></m></meta>
		</POST>
		<PUT public="1" get="inline" set="null" expr="&quot;PUT&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"PUT"</e></m></meta>
		</PUT>
	</class>
	<class path="nme.net.URLVariablesBase" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLVariables.hx" module="nme.net.URLVariables">
		<fields><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></fields>
		<decode public="1" set="method" line="60"><f a="inVars">
	<c path="String"/>
	<x path="Void"/>
</f></decode>
		<set public="1" set="method" line="77"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></set>
		<get public="1" set="method" line="83"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<toString public="1" set="method" line="88"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="52"><f a="?inEncoded">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="nme.net.URLVariables" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLVariables.hx">
		<this><c path="nme.net.URLVariablesBase"/></this>
		<meta><m n=":forward">
	<e>decode</e>
	<e>toString</e>
</m></meta>
		<impl><class path="nme.net._URLVariables.URLVariables_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLVariables.hx" private="1" module="nme.net.URLVariables" final="1">
	<_new public="1" set="method" line="102" static="1">
		<f a="?inEncoded">
			<c path="String"/>
			<x path="nme.net.URLVariables"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<set public="1" set="method" line="107" static="1">
		<f a="this:name:value">
			<c path="nme.net.URLVariablesBase"/>
			<c path="String"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":resolve"/>
		</meta>
	</set>
	<get public="1" set="method" line="113" static="1">
		<f a="this:name">
			<c path="nme.net.URLVariablesBase"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":resolve"/>
		</meta>
	</get>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="nme.net._URLVariables.URLVariables_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/net/URLVariables.hx" private="1" module="nme.net.URLVariables" final="1">
		<_new public="1" set="method" line="102" static="1">
			<f a="?inEncoded">
				<c path="String"/>
				<x path="nme.net.URLVariables"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<set public="1" set="method" line="107" static="1">
			<f a="this:name:value">
				<c path="nme.net.URLVariablesBase"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":resolve"/>
			</meta>
		</set>
		<get public="1" set="method" line="113" static="1">
			<f a="this:name">
				<c path="nme.net.URLVariablesBase"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":resolve"/>
			</meta>
		</get>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="nme.system.ApplicationDomain" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/system/ApplicationDomain.hx">
		<currentDomain public="1" set="null" expr="new ApplicationDomain(null)" line="7" static="1">
			<c path="nme.system.ApplicationDomain"/>
			<meta><m n=":value"><e>new ApplicationDomain(null)</e></m></meta>
		</currentDomain>
		<parentDomain public="1" set="null"><c path="nme.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method" line="22"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method" line="10">
			<f a="?parentDomain" v="null">
				<c path="nme.system.ApplicationDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ parentDomain : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.system.LoaderContext" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/system/LoaderContext.hx">
		<allowCodeImport public="1"><x path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><x path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="nme.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="nme.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method" line="13">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false:null:null">
				<x path="Bool"/>
				<c path="nme.system.ApplicationDomain"/>
				<c path="nme.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ securityDomain : null, applicationDomain : null, checkPolicyFile : false }</e></m></meta>
		</new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.system.SecurityDomain" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/system/SecurityDomain.hx">
		<currentDomain public="1" set="null" expr="new SecurityDomain()" line="7" static="1">
			<c path="nme.system.SecurityDomain"/>
			<meta><m n=":value"><e>new SecurityDomain()</e></m></meta>
		</currentDomain>
		<new set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<enum path="nme.text.AntiAliasType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="nme.text.Font" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/Font.hx">
		<useNative public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></useNative>
		<nmeRegisteredFonts expr="new Map&lt;String,Font&gt;()" line="20" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="nme.text.Font"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Font>()]]></e></m></meta>
		</nmeRegisteredFonts>
		<nmeDeviceFonts static="1"><c path="Array"><c path="nme.text.Font"/></c></nmeDeviceFonts>
		<enumerateFonts public="1" set="method" line="103" static="1">
			<f a="?enumerateDeviceFonts" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="nme.text.Font"/></c>
			</f>
			<meta><m n=":value"><e>{ enumerateDeviceFonts : false }</e></m></meta>
		</enumerateFonts>
		<load public="1" set="method" line="122" static="1"><f a="inFilename">
	<c path="String"/>
	<t path="nme.text.NativeFontData"/>
</f></load>
		<loadBytes public="1" set="method" line="128" static="1"><f a="inBytes">
	<c path="nme.utils.ByteArray"/>
	<t path="nme.text.NativeFontData"/>
</f></loadBytes>
		<registerFontData public="1" set="method" line="135" static="1"><f a="instance:inBytes">
	<c path="nme.text.Font"/>
	<c path="nme.utils.ByteArray"/>
	<x path="Void"/>
</f></registerFontData>
		<registerFont public="1" set="method" line="145" static="1"><f a="font">
	<x path="Class"><c path="nme.text.Font"/></x>
	<x path="Void"/>
</f></registerFont>
		<get_useNative set="method" line="161" static="1"><f a=""><x path="Bool"/></f></get_useNative>
		<set_useNative set="method" line="162" static="1"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useNative>
		<nme_font_set_use_native expr="PrimeLoader.load(&quot;nme_font_set_use_native&quot;, &quot;bv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_font_set_use_native", "bv")</e></m></meta>
		</nme_font_set_use_native>
		<nme_font_get_use_native expr="PrimeLoader.load(&quot;nme_font_get_use_native&quot;, &quot;b&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><x path="Bool"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_font_get_use_native", "b")</e></m></meta>
		</nme_font_get_use_native>
		<freetype_import_font expr="nme.Loader.load(&quot;freetype_import_font&quot;, 4)" line="171" static="1">
			<f a=":::">
				<c path="String"/>
				<unknown/>
				<x path="Int"/>
				<c path="nme.utils.ByteArray"/>
				<t path="nme.text.NativeFontData"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("freetype_import_font", 4)</e></m></meta>
		</freetype_import_font>
		<nme_font_register_font expr="nme.Loader.load(&quot;nme_font_register_font&quot;, 2)" line="172" static="1">
			<f a=":">
				<c path="String"/>
				<c path="nme.utils.ByteArray"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_font_register_font", 2)</e></m></meta>
		</nme_font_register_font>
		<nme_font_iterate_device_fonts expr="PrimeLoader.load(&quot;nme_font_iterate_device_fonts&quot;, &quot;ov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_font_iterate_device_fonts", "ov")</e></m></meta>
		</nme_font_iterate_device_fonts>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<fontStyle public="1" get="accessor" set="null"><x path="nme.text.FontStyle"/></fontStyle>
		<fontType public="1" set="null"><x path="nme.text.FontType"/></fontType>
		<knownFontStyle><x path="nme.text.FontStyle"/></knownFontStyle>
		<get_fontStyle public="1" set="method" line="70"><f a=""><x path="nme.text.FontStyle"/></f></get_fontStyle>
		<toString public="1" set="method" line="98"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="23">
			<f a="?inFilename:?inStyle:?inType:?resourceName:?id" v="&quot;&quot;::::">
				<c path="String"/>
				<x path="nme.text.FontStyle"/>
				<x path="nme.text.FontType"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inFilename : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
			<m n=":autoBuild"><e>nme.macros.Embed.embedAsset("NME_font_", ":font")</e></m>
		</meta>
	</class>
	<typedef path="nme.text.NativeFontData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/Font.hx" module="nme.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="nme.text.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="nme.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="nme.text.NativeGlyphData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/Font.hx" module="nme.text.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="nme.text.NativeKerningData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/Font.hx" module="nme.text.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<abstract path="nme.text.FontStyle" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontStyle.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"><e>String</e></m></meta>
		<impl><class path="nme.text._FontStyle.FontStyle_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontStyle.hx" private="1" module="nme.text.FontStyle" extern="1" final="1">
	<BOLD public="1" get="inline" set="null" expr="cast &quot;BOLD&quot;" line="7" static="1">
		<x path="nme.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast "BOLD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOLD>
	<BOLD_ITALIC public="1" get="inline" set="null" expr="cast &quot;BOLD_ITALIC&quot;" line="8" static="1">
		<x path="nme.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast "BOLD_ITALIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOLD_ITALIC>
	<ITALIC public="1" get="inline" set="null" expr="cast &quot;ITALIC&quot;" line="9" static="1">
		<x path="nme.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast "ITALIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ITALIC>
	<REGULAR public="1" get="inline" set="null" expr="cast &quot;REGULAR&quot;" line="10" static="1">
		<x path="nme.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast "REGULAR"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REGULAR>
	<meta><m n=":enum"><e>String</e></m></meta>
</class></impl>
	</abstract>
	<class path="nme.text._FontStyle.FontStyle_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontStyle.hx" private="1" module="nme.text.FontStyle" extern="1" final="1">
		<BOLD public="1" get="inline" set="null" expr="cast &quot;BOLD&quot;" line="7" static="1">
			<x path="nme.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast "BOLD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOLD>
		<BOLD_ITALIC public="1" get="inline" set="null" expr="cast &quot;BOLD_ITALIC&quot;" line="8" static="1">
			<x path="nme.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast "BOLD_ITALIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOLD_ITALIC>
		<ITALIC public="1" get="inline" set="null" expr="cast &quot;ITALIC&quot;" line="9" static="1">
			<x path="nme.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast "ITALIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ITALIC>
		<REGULAR public="1" get="inline" set="null" expr="cast &quot;REGULAR&quot;" line="10" static="1">
			<x path="nme.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast "REGULAR"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REGULAR>
		<meta><m n=":enum"><e>String</e></m></meta>
	</class>
	<abstract path="nme.text.FontType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="nme.text._FontType.FontType_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontType.hx" private="1" module="nme.text.FontType" extern="1" final="1">
	<DEVICE public="1" get="inline" set="null" expr="cast &quot;DEVICE&quot;" line="7" static="1">
		<x path="nme.text.FontType"/>
		<meta>
			<m n=":value"><e>cast "DEVICE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVICE>
	<EMBEDDED public="1" get="inline" set="null" expr="cast &quot;EMBEDDED&quot;" line="8" static="1">
		<x path="nme.text.FontType"/>
		<meta>
			<m n=":value"><e>cast "EMBEDDED"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMBEDDED>
	<EMBEDDED_CFF public="1" get="inline" set="null" expr="cast &quot;EMBEDDED_CFF&quot;" line="9" static="1">
		<x path="nme.text.FontType"/>
		<meta>
			<m n=":value"><e>cast "EMBEDDED_CFF"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMBEDDED_CFF>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="nme.text._FontType.FontType_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/FontType.hx" private="1" module="nme.text.FontType" extern="1" final="1">
		<DEVICE public="1" get="inline" set="null" expr="cast &quot;DEVICE&quot;" line="7" static="1">
			<x path="nme.text.FontType"/>
			<meta>
				<m n=":value"><e>cast "DEVICE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVICE>
		<EMBEDDED public="1" get="inline" set="null" expr="cast &quot;EMBEDDED&quot;" line="8" static="1">
			<x path="nme.text.FontType"/>
			<meta>
				<m n=":value"><e>cast "EMBEDDED"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMBEDDED>
		<EMBEDDED_CFF public="1" get="inline" set="null" expr="cast &quot;EMBEDDED_CFF&quot;" line="9" static="1">
			<x path="nme.text.FontType"/>
			<meta>
				<m n=":value"><e>cast "EMBEDDED_CFF"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMBEDDED_CFF>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="nme.text.GridFitType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.text.TextField" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/TextField.hx">
		<extends path="nme.display.InteractiveObject"/>
		<nme_text_field_create expr="PrimeLoader.load(&quot;nme_text_field_create&quot;, &quot;o&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=""><t path="cpp.Object"/></f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_create", "o")</e></m></meta>
		</nme_text_field_create>
		<nme_text_field_get_text expr="nme.Loader.load(&quot;nme_text_field_get_text&quot;, 1)" line="189" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_text_field_get_text", 1)</e></m></meta>
		</nme_text_field_get_text>
		<nme_text_field_set_text expr="nme.Loader.load(&quot;nme_text_field_set_text&quot;, 2)" line="190" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_text_field_set_text", 2)</e></m></meta>
		</nme_text_field_set_text>
		<nme_text_field_get_html_text expr="nme.Loader.load(&quot;nme_text_field_get_html_text&quot;, 1)" line="191" static="1">
			<f a="">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_text_field_get_html_text", 1)</e></m></meta>
		</nme_text_field_get_html_text>
		<nme_text_field_set_html_text expr="nme.Loader.load(&quot;nme_text_field_set_html_text&quot;, 2)" line="192" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_text_field_set_html_text", 2)</e></m></meta>
		</nme_text_field_set_html_text>
		<nme_text_field_get_text_color expr="PrimeLoader.load(&quot;nme_text_field_get_text_color&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_text_color", "oi")</e></m></meta>
		</nme_text_field_get_text_color>
		<nme_text_field_set_text_color expr="PrimeLoader.load(&quot;nme_text_field_set_text_color&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_text_color", "oiv")</e></m></meta>
		</nme_text_field_set_text_color>
		<nme_text_field_get_selectable expr="PrimeLoader.load(&quot;nme_text_field_get_selectable&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_selectable", "ob")</e></m></meta>
		</nme_text_field_get_selectable>
		<nme_text_field_set_selectable expr="PrimeLoader.load(&quot;nme_text_field_set_selectable&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_selectable", "obv")</e></m></meta>
		</nme_text_field_set_selectable>
		<nme_text_field_get_display_as_password expr="PrimeLoader.load(&quot;nme_text_field_get_display_as_password&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_display_as_password", "ob")</e></m></meta>
		</nme_text_field_get_display_as_password>
		<nme_text_field_set_display_as_password expr="PrimeLoader.load(&quot;nme_text_field_set_display_as_password&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_display_as_password", "obv")</e></m></meta>
		</nme_text_field_set_display_as_password>
		<nme_text_field_get_def_text_format expr="PrimeLoader.load(&quot;nme_text_field_get_def_text_format&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_def_text_format", "oov")</e></m></meta>
		</nme_text_field_get_def_text_format>
		<nme_text_field_set_def_text_format expr="PrimeLoader.load(&quot;nme_text_field_set_def_text_format&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_def_text_format", "oov")</e></m></meta>
		</nme_text_field_set_def_text_format>
		<nme_text_field_get_auto_size expr="PrimeLoader.load(&quot;nme_text_field_get_auto_size&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_auto_size", "oi")</e></m></meta>
		</nme_text_field_get_auto_size>
		<nme_text_field_set_auto_size expr="PrimeLoader.load(&quot;nme_text_field_set_auto_size&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_auto_size", "oiv")</e></m></meta>
		</nme_text_field_set_auto_size>
		<nme_text_field_get_type expr="PrimeLoader.load(&quot;nme_text_field_get_type&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_type", "ob")</e></m></meta>
		</nme_text_field_get_type>
		<nme_text_field_set_type expr="PrimeLoader.load(&quot;nme_text_field_set_type&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_type", "obv")</e></m></meta>
		</nme_text_field_set_type>
		<nme_text_field_get_multiline expr="PrimeLoader.load(&quot;nme_text_field_get_multiline&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_multiline", "ob")</e></m></meta>
		</nme_text_field_get_multiline>
		<nme_text_field_set_multiline expr="PrimeLoader.load(&quot;nme_text_field_set_multiline&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_multiline", "obv")</e></m></meta>
		</nme_text_field_set_multiline>
		<nme_text_field_get_word_wrap expr="PrimeLoader.load(&quot;nme_text_field_get_word_wrap&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_word_wrap", "ob")</e></m></meta>
		</nme_text_field_get_word_wrap>
		<nme_text_field_set_word_wrap expr="PrimeLoader.load(&quot;nme_text_field_set_word_wrap&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_word_wrap", "obv")</e></m></meta>
		</nme_text_field_set_word_wrap>
		<nme_text_field_get_border expr="PrimeLoader.load(&quot;nme_text_field_get_border&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_border", "ob")</e></m></meta>
		</nme_text_field_get_border>
		<nme_text_field_set_border expr="PrimeLoader.load(&quot;nme_text_field_set_border&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_border", "obv")</e></m></meta>
		</nme_text_field_set_border>
		<nme_text_field_get_border_color expr="PrimeLoader.load(&quot;nme_text_field_get_border_color&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_border_color", "oi")</e></m></meta>
		</nme_text_field_get_border_color>
		<nme_text_field_set_border_color expr="PrimeLoader.load(&quot;nme_text_field_set_border_color&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_border_color", "oiv")</e></m></meta>
		</nme_text_field_set_border_color>
		<nme_text_field_get_background expr="PrimeLoader.load(&quot;nme_text_field_get_background&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_background", "ob")</e></m></meta>
		</nme_text_field_get_background>
		<nme_text_field_set_background expr="PrimeLoader.load(&quot;nme_text_field_set_background&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_background", "obv")</e></m></meta>
		</nme_text_field_set_background>
		<nme_text_field_get_background_color expr="PrimeLoader.load(&quot;nme_text_field_get_background_color&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_background_color", "oi")</e></m></meta>
		</nme_text_field_get_background_color>
		<nme_text_field_set_background_color expr="PrimeLoader.load(&quot;nme_text_field_set_background_color&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_background_color", "oiv")</e></m></meta>
		</nme_text_field_set_background_color>
		<nme_text_field_get_text_width expr="PrimeLoader.load(&quot;nme_text_field_get_text_width&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_text_width", "od")</e></m></meta>
		</nme_text_field_get_text_width>
		<nme_text_field_get_text_height expr="PrimeLoader.load(&quot;nme_text_field_get_text_height&quot;, &quot;od&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_text_height", "od")</e></m></meta>
		</nme_text_field_get_text_height>
		<nme_text_field_get_text_format expr="PrimeLoader.load(&quot;nme_text_field_get_text_format&quot;, &quot;ooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_text_format", "ooiiv")</e></m></meta>
		</nme_text_field_get_text_format>
		<nme_text_field_set_text_format expr="PrimeLoader.load(&quot;nme_text_field_set_text_format&quot;, &quot;ooiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_text_format", "ooiiv")</e></m></meta>
		</nme_text_field_set_text_format>
		<nme_text_field_get_max_scroll_v expr="PrimeLoader.load(&quot;nme_text_field_get_max_scroll_v&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_max_scroll_v", "oi")</e></m></meta>
		</nme_text_field_get_max_scroll_v>
		<nme_text_field_get_max_scroll_h expr="PrimeLoader.load(&quot;nme_text_field_get_max_scroll_h&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_max_scroll_h", "oi")</e></m></meta>
		</nme_text_field_get_max_scroll_h>
		<nme_text_field_get_bottom_scroll_v expr="PrimeLoader.load(&quot;nme_text_field_get_bottom_scroll_v&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_bottom_scroll_v", "oi")</e></m></meta>
		</nme_text_field_get_bottom_scroll_v>
		<nme_text_field_get_scroll_h expr="PrimeLoader.load(&quot;nme_text_field_get_scroll_h&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_scroll_h", "oi")</e></m></meta>
		</nme_text_field_get_scroll_h>
		<nme_text_field_set_scroll_h expr="PrimeLoader.load(&quot;nme_text_field_set_scroll_h&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_scroll_h", "oiv")</e></m></meta>
		</nme_text_field_set_scroll_h>
		<nme_text_field_get_scroll_v expr="PrimeLoader.load(&quot;nme_text_field_get_scroll_v&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_scroll_v", "oi")</e></m></meta>
		</nme_text_field_get_scroll_v>
		<nme_text_field_set_scroll_v expr="PrimeLoader.load(&quot;nme_text_field_set_scroll_v&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_scroll_v", "oiv")</e></m></meta>
		</nme_text_field_set_scroll_v>
		<nme_text_field_get_num_lines expr="PrimeLoader.load(&quot;nme_text_field_get_num_lines&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_num_lines", "oi")</e></m></meta>
		</nme_text_field_get_num_lines>
		<nme_text_field_get_max_chars expr="PrimeLoader.load(&quot;nme_text_field_get_max_chars&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_max_chars", "oi")</e></m></meta>
		</nme_text_field_get_max_chars>
		<nme_text_field_set_max_chars expr="PrimeLoader.load(&quot;nme_text_field_set_max_chars&quot;, &quot;oiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_max_chars", "oiv")</e></m></meta>
		</nme_text_field_set_max_chars>
		<nme_text_field_get_line_text expr="nme.Loader.load(&quot;nme_text_field_get_line_text&quot;, 2)" line="231" static="1">
			<f a=":">
				<t path="nme.NativeHandle"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>nme.Loader.load("nme_text_field_get_line_text", 2)</e></m></meta>
		</nme_text_field_get_line_text>
		<nme_text_field_get_line_metrics expr="PrimeLoader.load(&quot;nme_text_field_get_line_metrics&quot;, &quot;oiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_line_metrics", "oiov")</e></m></meta>
		</nme_text_field_get_line_metrics>
		<nme_text_field_get_line_offset expr="PrimeLoader.load(&quot;nme_text_field_get_line_offset&quot;, &quot;oii&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_line_offset", "oii")</e></m></meta>
		</nme_text_field_get_line_offset>
		<nme_text_field_get_embed_fonts expr="PrimeLoader.load(&quot;nme_text_field_get_embed_fonts&quot;, &quot;ob&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_embed_fonts", "ob")</e></m></meta>
		</nme_text_field_get_embed_fonts>
		<nme_text_field_set_embed_fonts expr="PrimeLoader.load(&quot;nme_text_field_set_embed_fonts&quot;, &quot;obv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Bool"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_embed_fonts", "obv")</e></m></meta>
		</nme_text_field_set_embed_fonts>
		<nme_text_field_get_char_boundaries expr="PrimeLoader.load(&quot;nme_text_field_get_char_boundaries&quot;, &quot;oiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_char_boundaries", "oiov")</e></m></meta>
		</nme_text_field_get_char_boundaries>
		<nme_text_field_get_selection_begin_index expr="PrimeLoader.load(&quot;nme_text_field_get_selection_begin_index&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_selection_begin_index", "oi")</e></m></meta>
		</nme_text_field_get_selection_begin_index>
		<nme_text_field_get_selection_end_index expr="PrimeLoader.load(&quot;nme_text_field_get_selection_end_index&quot;, &quot;oi&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="">
	<t path="cpp.Object"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_selection_end_index", "oi")</e></m></meta>
		</nme_text_field_get_selection_end_index>
		<nme_text_field_set_selection expr="PrimeLoader.load(&quot;nme_text_field_set_selection&quot;, &quot;oiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_set_selection", "oiiv")</e></m></meta>
		</nme_text_field_set_selection>
		<nme_text_field_get_line_positions expr="PrimeLoader.load(&quot;nme_text_field_get_line_positions&quot;, &quot;oiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a="::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_line_positions", "oiov")</e></m></meta>
		</nme_text_field_get_line_positions>
		<nme_text_field_get_line_for_char expr="PrimeLoader.load(&quot;nme_text_field_get_line_for_char&quot;, &quot;oii&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_get_line_for_char", "oii")</e></m></meta>
		</nme_text_field_get_line_for_char>
		<nme_text_field_replace_selected_text expr="PrimeLoader.load(&quot;nme_text_field_replace_selected_text&quot;, &quot;oov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":">
	<t path="cpp.Object"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_replace_selected_text", "oov")</e></m></meta>
		</nme_text_field_replace_selected_text>
		<nme_text_field_replace_text expr="PrimeLoader.load(&quot;nme_text_field_replace_text&quot;, &quot;oiiov&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="cpp.Object"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_replace_text", "oiiov")</e></m></meta>
		</nme_text_field_replace_text>
		<nme_text_field_send_key expr="PrimeLoader.load(&quot;nme_text_field_send_key&quot;, &quot;oiiiv&quot;)" line="9" static="1">
			<x path="cpp.Callable"><f a=":::">
	<t path="cpp.Object"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cpp.Void"/>
</f></x>
			<meta><m n=":value"><e>PrimeLoader.load("nme_text_field_send_key", "oiiiv")</e></m></meta>
		</nme_text_field_send_key>
		<antiAliasType public="1"><e path="nme.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1" get="accessor" set="accessor"><e path="nme.text.TextFieldAutoSize"/></autoSize>
		<background public="1" get="accessor" set="accessor"><x path="Bool"/></background>
		<backgroundColor public="1" get="accessor" set="accessor"><x path="Int"/></backgroundColor>
		<border public="1" get="accessor" set="accessor"><x path="Bool"/></border>
		<borderColor public="1" get="accessor" set="accessor"><x path="Int"/></borderColor>
		<bottomScrollV public="1" get="accessor" set="null"><x path="Int"/></bottomScrollV>
		<defaultTextFormat public="1" get="accessor" set="accessor"><c path="nme.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1" get="accessor" set="accessor"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1" get="accessor" set="accessor"><x path="Bool"/></embedFonts>
		<forceFreeType public="1" get="accessor" set="accessor"><x path="Bool"/></forceFreeType>
		<gridFitType public="1"><e path="nme.text.GridFitType"/></gridFitType>
		<htmlText public="1" get="accessor" set="accessor"><c path="String"/></htmlText>
		<maxChars public="1" get="accessor" set="accessor"><x path="Int"/></maxChars>
		<maxScrollH public="1" get="accessor" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" get="accessor" set="null"><x path="Int"/></maxScrollV>
		<selectionBeginIndex public="1" get="accessor" set="null"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" get="accessor" set="null"><x path="Int"/></selectionEndIndex>
		<multiline public="1" get="accessor" set="accessor"><x path="Bool"/></multiline>
		<numLines public="1" get="accessor" set="null"><x path="Int"/></numLines>
		<scrollH public="1" get="accessor" set="accessor"><x path="Int"/></scrollH>
		<scrollV public="1" get="accessor" set="accessor"><x path="Int"/></scrollV>
		<selectable public="1" get="accessor" set="accessor"><x path="Bool"/></selectable>
		<sharpness public="1"><x path="Float"/></sharpness>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<textColor public="1" get="accessor" set="accessor"><x path="Int"/></textColor>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<type public="1" get="accessor" set="accessor"><e path="nme.text.TextFieldType"/></type>
		<wordWrap public="1" get="accessor" set="accessor"><x path="Bool"/></wordWrap>
		<appendText public="1" set="method" line="50"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<getLineOffset public="1" set="method" line="55"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineIndexOfChar public="1" set="method" line="60"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLinePositions public="1" set="method" line="66"><f a="startLine:endLine">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getLinePositions>
		<getLineText public="1" set="method" line="78"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineMetrics public="1" set="method" line="83"><f a="lineIndex">
	<x path="Int"/>
	<c path="nme.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getTextFormat public="1" set="method" line="90">
			<f a="?beginIndex:?endIndex" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</getTextFormat>
		<getCharBoundaries public="1" set="method" line="97"><f a="charIndex">
	<x path="Int"/>
	<c path="nme.geom.Rectangle"/>
</f></getCharBoundaries>
		<setSelection public="1" set="method" line="104"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method" line="109">
			<f a="format:?beginIndex:?endIndex" v=":-1:-1">
				<c path="nme.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</setTextFormat>
		<replaceSelectedText public="1" set="method" line="114"><f a="inNewText">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method" line="119"><f a="c0:c1:inNewText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<sendKey public="1" set="method" line="124"><f a="charCode:keyId:shift:ctrl:alt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sendKey>
		<sendCopy public="1" set="method" line="133"><f a=""><x path="Void"/></f></sendCopy>
		<sendPaste public="1" set="method" line="134"><f a=""><x path="Void"/></f></sendPaste>
		<get_autoSize set="method" line="139"><f a=""><e path="nme.text.TextFieldAutoSize"/></f></get_autoSize>
		<set_autoSize set="method" line="140"><f a="inVal">
	<e path="nme.text.TextFieldAutoSize"/>
	<e path="nme.text.TextFieldAutoSize"/>
</f></set_autoSize>
		<get_background set="method" line="141"><f a=""><x path="Bool"/></f></get_background>
		<set_background set="method" line="142"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<get_backgroundColor set="method" line="143"><f a=""><x path="Int"/></f></get_backgroundColor>
		<set_backgroundColor set="method" line="144"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_backgroundColor>
		<get_border set="method" line="145"><f a=""><x path="Bool"/></f></get_border>
		<set_border set="method" line="146"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_border>
		<get_borderColor set="method" line="147"><f a=""><x path="Int"/></f></get_borderColor>
		<set_borderColor set="method" line="148"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderColor>
		<get_bottomScrollV set="method" line="149"><f a=""><x path="Int"/></f></get_bottomScrollV>
		<get_defaultTextFormat set="method" line="150"><f a=""><c path="nme.text.TextFormat"/></f></get_defaultTextFormat>
		<set_defaultTextFormat set="method" line="151"><f a="inFormat">
	<c path="nme.text.TextFormat"/>
	<c path="nme.text.TextFormat"/>
</f></set_defaultTextFormat>
		<get_displayAsPassword set="method" line="152"><f a=""><x path="Bool"/></f></get_displayAsPassword>
		<set_displayAsPassword set="method" line="153"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_displayAsPassword>
		<get_embedFonts set="method" line="154"><f a=""><x path="Bool"/></f></get_embedFonts>
		<set_embedFonts set="method" line="155"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_embedFonts>
		<get_forceFreeType set="method" line="156"><f a=""><x path="Bool"/></f></get_forceFreeType>
		<set_forceFreeType set="method" line="157"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_forceFreeType>
		<get_htmlText set="method" line="159"><f a=""><c path="String"/></f></get_htmlText>
		<set_htmlText set="method" line="160"><f a="inText">
	<c path="String"/>
	<c path="String"/>
</f></set_htmlText>
		<get_maxChars set="method" line="161"><f a=""><x path="Int"/></f></get_maxChars>
		<set_maxChars set="method" line="162"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxChars>
		<get_maxScrollH set="method" line="163"><f a=""><x path="Int"/></f></get_maxScrollH>
		<get_maxScrollV set="method" line="164"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_multiline set="method" line="165"><f a=""><x path="Bool"/></f></get_multiline>
		<set_multiline set="method" line="166"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<get_numLines set="method" line="167"><f a=""><x path="Int"/></f></get_numLines>
		<get_scrollH set="method" line="168"><f a=""><x path="Int"/></f></get_scrollH>
		<set_scrollH set="method" line="169"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollH>
		<get_scrollV set="method" line="170"><f a=""><x path="Int"/></f></get_scrollV>
		<set_scrollV set="method" line="171"><f a="inVal">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollV>
		<get_selectable set="method" line="172"><f a=""><x path="Bool"/></f></get_selectable>
		<set_selectable set="method" line="173"><f a="inSel">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectable>
		<get_selectionBeginIndex set="method" line="174"><f a=""><x path="Int"/></f></get_selectionBeginIndex>
		<get_selectionEndIndex set="method" line="175"><f a=""><x path="Int"/></f></get_selectionEndIndex>
		<get_text set="method" line="176"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="177"><f a="inText">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<get_textColor set="method" line="178"><f a=""><x path="Int"/></f></get_textColor>
		<set_textColor set="method" line="179"><f a="inCol">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<get_textWidth set="method" line="180"><f a=""><x path="Float"/></f></get_textWidth>
		<get_textHeight set="method" line="181"><f a=""><x path="Float"/></f></get_textHeight>
		<get_type set="method" line="182"><f a=""><e path="nme.text.TextFieldType"/></f></get_type>
		<set_type set="method" line="183"><f a="inType">
	<e path="nme.text.TextFieldType"/>
	<e path="nme.text.TextFieldType"/>
</f></set_type>
		<get_wordWrap set="method" line="184"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="185"><f a="inVal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<enum path="nme.text.TextFieldAutoSize" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="nme.text.TextFieldType" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.text.TextFormat" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/TextFormat.hx">
		<OUTLINE_END_SQUARE public="1" get="inline" set="null" expr="0x10" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x10</e></m></meta>
		</OUTLINE_END_SQUARE>
		<OUTLINE_EDGE_BEVEL public="1" get="inline" set="null" expr="0x20" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20</e></m></meta>
		</OUTLINE_EDGE_BEVEL>
		<OUTLINE_EDGE_MITER public="1" get="inline" set="null" expr="0x40" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x40</e></m></meta>
		</OUTLINE_EDGE_MITER>
		<align public="1"><c path="String"/></align>
		<blockIndent public="1"><d/></blockIndent>
		<bold public="1"><d/></bold>
		<bullet public="1"><d/></bullet>
		<color public="1"><d/></color>
		<display public="1"><c path="String"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><d/></indent>
		<italic public="1"><d/></italic>
		<kerning public="1"><d/></kerning>
		<leading public="1"><d/></leading>
		<leftMargin public="1"><d/></leftMargin>
		<letterSpacing public="1"><d/></letterSpacing>
		<rightMargin public="1"><d/></rightMargin>
		<size public="1"><d/></size>
		<outline public="1"><x path="Null"><x path="Float"/></x></outline>
		<outlineFlags public="1"><x path="Null"><x path="Int"/></x></outlineFlags>
		<outlineMiterLimit public="1"><x path="Null"><x path="Float"/></x></outlineMiterLimit>
		<tabStops public="1"><c path="Array"><x path="Int"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><d/></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method" line="35"><f a="?in_font:?in_size:?in_color:?in_bold:?in_italic:?in_underline:?in_url:?in_target:?in_align:?in_leftMargin:?in_rightMargin:?in_indent:?in_leading">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.text.TextLineMetrics" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/text/TextLineMetrics.hx">
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<leading public="1"><x path="Float"/></leading>
		<new public="1" set="method" line="14"><f a="?in_x:?in_width:?in_height:?in_ascent:?in_descent:?in_leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.ui.GameInput" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/GameInput.hx">
		<extends path="nme.events.EventDispatcher"/>
		<isSupported public="1" set="null" expr="true" line="13" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isSupported>
		<numDevices public="1" set="null" expr="0" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numDevices>
		<nmeDevices expr="new Array&lt;GameInputDevice&gt;()" line="16" static="1">
			<c path="Array"><c path="nme.ui.GameInputDevice"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<GameInputDevice>()]]></e></m></meta>
		</nmeDevices>
		<nmeInstances expr="[]" line="17" static="1">
			<c path="Array"><c path="nme.ui.GameInput"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</nmeInstances>
		<nmeKeyboardDevices expr="new Array&lt;KeyboardInputDevice&gt;()" line="18" static="1">
			<c path="Array"><c path="nme.ui.KeyboardInputDevice"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<KeyboardInputDevice>()]]></e></m></meta>
		</nmeKeyboardDevices>
		<hasInstances set="method" line="60" static="1"><f a=""><x path="Bool"/></f></hasInstances>
		<getBest public="1" set="method" line="84" static="1"><f a=""><c path="nme.ui.GameInputDevice"/></f></getBest>
		<getDeviceAt public="1" set="method" line="95" static="1"><f a="index">
	<x path="Int"/>
	<c path="nme.ui.GameInputDevice"/>
</f></getDeviceAt>
		<getGamepadGuid set="method" line="107" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getGamepadGuid>
		<getGamepadName set="method" line="114" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getGamepadName>
		<__getDevice set="method" line="120" static="1"><f a="index">
	<x path="Int"/>
	<c path="nme.ui.GameInputDevice"/>
</f></__getDevice>
		<nmeGamepadConnect set="method" line="139" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></nmeGamepadConnect>
		<nmeGamepadDisconnect set="method" line="151" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></nmeGamepadDisconnect>
		<nmeGamepadAxisMove set="method" line="174" static="1"><f a="index:axis:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></nmeGamepadAxisMove>
		<nmeGamepadButton public="1" set="method" line="194" static="1"><f a="index:button:down">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></nmeGamepadButton>
		<addKeyboardDevice0 public="1" set="method" line="37"><f a=""><c path="nme.ui.GameInputDevice"/></f></addKeyboardDevice0>
		<addEventListener public="1" set="method" line="66" override="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>nme.ui.GameInputControl</e></m>
			<m n=":access"><e>nme.ui.GameInputDevice</e></m>
			<m n=":allow"><e>nme.display.Stage</e></m>
		</meta>
	</class>
	<class path="nme.ui.GameInputControl" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/GameInputControl.hx">
		<extends path="nme.events.EventDispatcher"/>
		<device public="1" set="null"><c path="nme.ui.GameInputDevice"/></device>
		<id public="1" set="null"><c path="String"/></id>
		<maxValue public="1" set="null"><x path="Float"/></maxValue>
		<minValue public="1" set="null"><x path="Float"/></minValue>
		<value public="1" set="null"><x path="Float"/></value>
		<hasListeners public="1"><x path="Bool"/></hasListeners>
		<setButtonState set="method" line="29">
			<f a="down">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>nme.ui.KeyboardInputDevice</e></m></meta>
		</setButtonState>
		<new set="method" line="17">
			<f a="inDevice:inId:inMinValue:inMaxValue:?inValue" v="::::0">
				<c path="nme.ui.GameInputDevice"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inValue : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="nme.ui.GameInputDevice" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/GameInputDevice.hx">
		<MAX_BUFFER_SIZE public="1" expr="32000" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32000</e></m></meta>
		</MAX_BUFFER_SIZE>
		<enabled public="1"><x path="Bool"/></enabled>
		<id public="1" set="null"><c path="String"/></id>
		<name public="1" set="null"><c path="String"/></name>
		<numControls public="1" get="accessor" set="null"><x path="Int"/></numControls>
		<sampleInterval public="1"><x path="Int"/></sampleInterval>
		<nmeAxis expr="new Map&lt;Int,GameInputControl&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="nme.ui.GameInputControl"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,GameInputControl>()]]></e></m></meta>
		</nmeAxis>
		<nmeButton expr="new Map&lt;Int,GameInputControl&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="nme.ui.GameInputControl"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,GameInputControl>()]]></e></m></meta>
		</nmeButton>
		<nmeControls expr="new Array&lt;GameInputControl&gt;()">
			<c path="Array"><c path="nme.ui.GameInputControl"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<GameInputControl>()]]></e></m></meta>
		</nmeControls>
		<nmeHandle><d/></nmeHandle>
		<toString public="1" set="method" line="44"><f a=""><c path="String"/></f></toString>
		<getButtonAt public="1" set="method" line="46"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="nme.ui.GameInputControl"/></x>
</f></getButtonAt>
		<getAxisAt public="1" set="method" line="48"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="nme.ui.GameInputControl"/></x>
</f></getAxisAt>
		<getCachedSamples public="1" set="method" line="50">
			<f a="data:?append" v=":false">
				<c path="nme.utils.ByteArray"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ append : false }</e></m></meta>
		</getCachedSamples>
		<isButtonDown public="1" set="method" line="52"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></isButtonDown>
		<readDPadUp public="1" set="method" line="59"><f a=""><x path="Bool"/></f></readDPadUp>
		<readDPadDown public="1" set="method" line="60"><f a=""><x path="Bool"/></f></readDPadDown>
		<readDPadLeft public="1" set="method" line="61"><f a=""><x path="Bool"/></f></readDPadLeft>
		<readDPadRight public="1" set="method" line="62"><f a=""><x path="Bool"/></f></readDPadRight>
		<getX0 public="1" set="method" line="64"><f a=""><x path="Float"/></f></getX0>
		<getY0 public="1" set="method" line="65"><f a=""><x path="Float"/></f></getY0>
		<isLeft public="1" set="method" line="67"><f a=""><x path="Bool"/></f></isLeft>
		<isRight public="1" set="method" line="68"><f a=""><x path="Bool"/></f></isRight>
		<isUp public="1" set="method" line="69"><f a=""><x path="Bool"/></f></isUp>
		<isDown public="1" set="method" line="70"><f a=""><x path="Bool"/></f></isDown>
		<getDx public="1" set="method" line="72"><f a=""><x path="Int"/></f></getDx>
		<getDy public="1" set="method" line="73"><f a=""><x path="Int"/></f></getDy>
		<getControlAt public="1" set="method" line="75"><f a="i">
	<x path="Int"/>
	<c path="nme.ui.GameInputControl"/>
</f></getControlAt>
		<startCachingSamples public="1" set="method" line="82"><f a="numSamples:controls">
	<x path="Int"/>
	<x path="nme.Vector"><c path="String"/></x>
	<x path="Void"/>
</f></startCachingSamples>
		<stopCachingSamples public="1" set="method" line="86"><f a=""><x path="Void"/></f></stopCachingSamples>
		<get_numControls set="method" line="90"><f a=""><x path="Int"/></f></get_numControls>
		<new set="method" line="24"><f a="id:name">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>nme.ui.GameInputControl</e></m>
		</meta>
	</class>
	<class path="nme.ui.GamepadAxis" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/GamepadAxis.hx">
		<LEFT public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="2" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</RIGHT>
		<TRIGGER public="1" get="inline" set="null" expr="4" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</TRIGGER>
		<toString public="1" set="method" line="12" static="1"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.ui.GamepadButton" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/GamepadButton.hx">
		<A public="1" get="inline" set="null" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</B>
		<X public="1" get="inline" set="null" expr="2" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="3" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</Y>
		<BACK public="1" get="inline" set="null" expr="4" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BACK>
		<GUIDE public="1" get="inline" set="null" expr="5" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</GUIDE>
		<START public="1" get="inline" set="null" expr="6" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</START>
		<LEFT_STICK public="1" get="inline" set="null" expr="7" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</LEFT_STICK>
		<RIGHT_STICK public="1" get="inline" set="null" expr="8" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</RIGHT_STICK>
		<LEFT_SHOULDER public="1" get="inline" set="null" expr="9" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="inline" set="null" expr="10" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</RIGHT_SHOULDER>
		<DPAD_UP public="1" get="inline" set="null" expr="11" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="12" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="13" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="14" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</DPAD_RIGHT>
		<toString public="1" set="method" line="33" static="1"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.ui.Keyboard" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/Keyboard.hx">
		<A public="1" get="inline" set="null" expr="65" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="66" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>66</e></m></meta>
		</B>
		<C public="1" get="inline" set="null" expr="67" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>67</e></m></meta>
		</C>
		<D public="1" get="inline" set="null" expr="68" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>68</e></m></meta>
		</D>
		<E public="1" get="inline" set="null" expr="69" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>69</e></m></meta>
		</E>
		<F public="1" get="inline" set="null" expr="70" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>70</e></m></meta>
		</F>
		<G public="1" get="inline" set="null" expr="71" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>71</e></m></meta>
		</G>
		<H public="1" get="inline" set="null" expr="72" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>72</e></m></meta>
		</H>
		<I public="1" get="inline" set="null" expr="73" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>73</e></m></meta>
		</I>
		<J public="1" get="inline" set="null" expr="74" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>74</e></m></meta>
		</J>
		<K public="1" get="inline" set="null" expr="75" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>75</e></m></meta>
		</K>
		<L public="1" get="inline" set="null" expr="76" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>76</e></m></meta>
		</L>
		<M public="1" get="inline" set="null" expr="77" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>77</e></m></meta>
		</M>
		<N public="1" get="inline" set="null" expr="78" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>78</e></m></meta>
		</N>
		<O public="1" get="inline" set="null" expr="79" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>79</e></m></meta>
		</O>
		<P public="1" get="inline" set="null" expr="80" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
		</P>
		<Q public="1" get="inline" set="null" expr="81" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>81</e></m></meta>
		</Q>
		<R public="1" get="inline" set="null" expr="82" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>82</e></m></meta>
		</R>
		<S public="1" get="inline" set="null" expr="83" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>83</e></m></meta>
		</S>
		<T public="1" get="inline" set="null" expr="84" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>84</e></m></meta>
		</T>
		<U public="1" get="inline" set="null" expr="85" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>85</e></m></meta>
		</U>
		<V public="1" get="inline" set="null" expr="86" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>86</e></m></meta>
		</V>
		<W public="1" get="inline" set="null" expr="87" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>87</e></m></meta>
		</W>
		<X public="1" get="inline" set="null" expr="88" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>88</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="89" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>89</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="90" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>90</e></m></meta>
		</Z>
		<ALTERNATE public="1" get="inline" set="null" expr="18" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ALTERNATE>
		<BACKQUOTE public="1" get="inline" set="null" expr="192" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>192</e></m></meta>
		</BACKQUOTE>
		<BACKSLASH public="1" get="inline" set="null" expr="220" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>220</e></m></meta>
		</BACKSLASH>
		<BACKSPACE public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BACKSPACE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="20" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</CAPS_LOCK>
		<COMMA public="1" get="inline" set="null" expr="188" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>188</e></m></meta>
		</COMMA>
		<COMMAND public="1" get="inline" set="null" expr="15" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</COMMAND>
		<CONTROL public="1" get="inline" set="null" expr="17" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CONTROL>
		<DELETE public="1" get="inline" set="null" expr="46" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>46</e></m></meta>
		</DELETE>
		<DOWN public="1" get="inline" set="null" expr="40" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>40</e></m></meta>
		</DOWN>
		<END public="1" get="inline" set="null" expr="35" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35</e></m></meta>
		</END>
		<ENTER public="1" get="inline" set="null" expr="13" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</ENTER>
		<EQUAL public="1" get="inline" set="null" expr="187" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>187</e></m></meta>
		</EQUAL>
		<ESCAPE public="1" get="inline" set="null" expr="27" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</ESCAPE>
		<F1 public="1" get="inline" set="null" expr="112" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>112</e></m></meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="113" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>113</e></m></meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="114" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>114</e></m></meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="115" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>115</e></m></meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="116" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>116</e></m></meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="117" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>117</e></m></meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="118" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>118</e></m></meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="119" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>119</e></m></meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="120" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="121" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>121</e></m></meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="122" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>122</e></m></meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="123" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>123</e></m></meta>
		</F12>
		<F13 public="1" get="inline" set="null" expr="124" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>124</e></m></meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="125" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>125</e></m></meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="126" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>126</e></m></meta>
		</F15>
		<HOME public="1" get="inline" set="null" expr="36" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36</e></m></meta>
		</HOME>
		<INSERT public="1" get="inline" set="null" expr="45" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>45</e></m></meta>
		</INSERT>
		<LEFT public="1" get="inline" set="null" expr="37" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37</e></m></meta>
		</LEFT>
		<LEFTBRACKET public="1" get="inline" set="null" expr="219" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>219</e></m></meta>
		</LEFTBRACKET>
		<MINUS public="1" get="inline" set="null" expr="189" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>189</e></m></meta>
		</MINUS>
		<NUMBER_0 public="1" get="inline" set="null" expr="48" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>48</e></m></meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="49" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>49</e></m></meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="50" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>50</e></m></meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="51" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>51</e></m></meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="52" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>52</e></m></meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="53" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>53</e></m></meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="54" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>54</e></m></meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="55" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>55</e></m></meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="56" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="57" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>57</e></m></meta>
		</NUMBER_9>
		<NUMPAD public="1" get="inline" set="null" expr="21" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</NUMPAD>
		<NUMPAD_0 public="1" get="inline" set="null" expr="96" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>96</e></m></meta>
		</NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" expr="97" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>97</e></m></meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="98" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>98</e></m></meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="99" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>99</e></m></meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="100" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="101" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>101</e></m></meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="102" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>102</e></m></meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="103" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>103</e></m></meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="104" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="105" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>105</e></m></meta>
		</NUMPAD_9>
		<NUMPAD_ADD public="1" get="inline" set="null" expr="107" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>107</e></m></meta>
		</NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="110" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>110</e></m></meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="111" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="108" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>108</e></m></meta>
		</NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="106" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>106</e></m></meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" get="inline" set="null" expr="109" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</NUMPAD_SUBTRACT>
		<PAGE_DOWN public="1" get="inline" set="null" expr="34" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
		</PAGE_DOWN>
		<PAGE_UP public="1" get="inline" set="null" expr="33" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33</e></m></meta>
		</PAGE_UP>
		<PERIOD public="1" get="inline" set="null" expr="190" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>190</e></m></meta>
		</PERIOD>
		<QUOTE public="1" get="inline" set="null" expr="222" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>222</e></m></meta>
		</QUOTE>
		<RIGHT public="1" get="inline" set="null" expr="39" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>39</e></m></meta>
		</RIGHT>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="221" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>221</e></m></meta>
		</RIGHTBRACKET>
		<SEMICOLON public="1" get="inline" set="null" expr="186" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>186</e></m></meta>
		</SEMICOLON>
		<SHIFT public="1" get="inline" set="null" expr="16" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHIFT>
		<SLASH public="1" get="inline" set="null" expr="191" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>191</e></m></meta>
		</SLASH>
		<SPACE public="1" get="inline" set="null" expr="32" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SPACE>
		<TAB public="1" get="inline" set="null" expr="9" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TAB>
		<UP public="1" get="inline" set="null" expr="38" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>38</e></m></meta>
		</UP>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<class path="nme.ui.KeyboardInputDevice" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/ui/KeyboardInputDevice.hx">
		<extends path="nme.ui.GameInputDevice"/>
		<allDevices expr="null" line="7" static="1">
			<c path="Array"><c path="nme.ui.KeyboardInputDevice"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</allDevices>
		<keyDown set="method" line="36" static="1"><f a="ev">
	<c path="nme.events.KeyboardEvent"/>
	<x path="Void"/>
</f></keyDown>
		<keyUp set="method" line="44" static="1"><f a="ev">
	<c path="nme.events.KeyboardEvent"/>
	<x path="Void"/>
</f></keyUp>
		<buttonKeys><c path="Array"><x path="Int"/></c></buttonKeys>
		<onKey set="method" line="25"><f a="code:isDown">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></onKey>
		<new public="1" set="method" line="10"><f a="id:name:inButtonKeys">
	<c path="String"/>
	<c path="String"/>
	<t path="Map">
		<x path="Int"/>
		<x path="Int"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="nme.utils.ArrayBuffer" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/ArrayBuffer.hx"><c path="nme.utils.ByteArray"/></typedef>
	<class path="nme.utils.ArrayBufferView" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/ArrayBufferView.hx">
		<implements path="nme.utils.IMemoryRange"/>
		<invalidDataIndex expr="&quot;Invalid data index&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Invalid data index"</e></m></meta>
		</invalidDataIndex>
		<buffer public="1" set="null"><c path="nme.utils.ByteArray"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<bytes><t path="haxe.io.BytesData"/></bytes>
		<toBytes public="1" set="method" line="67"><f a=""><c path="haxe.io.Bytes"/></f></toBytes>
		<setData public="1" set="method" line="70"><f a="byteData:inOffset">
	<c path="nme.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setData>
		<getByteBuffer public="1" set="method" line="80"><f a=""><c path="nme.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method" line="81"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method" line="82"><f a=""><x path="Int"/></f></getLength>
		<getFloat32 public="1" get="inline" set="null" line="84">
			<f a="bytePos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getFloat32>
		<setFloat32 public="1" get="inline" set="null" line="98">
			<f a="bytePos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFloat32>
		<getUInt8 public="1" get="inline" set="null" line="112">
			<f a="bytePos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getUInt8>
		<setUInt8 public="1" get="inline" set="null" line="126">
			<f a="bytePos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setUInt8>
		<getInt16 public="1" get="inline" set="null" line="140">
			<f a="bytePos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getInt16>
		<getUInt16 public="1" get="inline" set="null" line="151">
			<f a="bytePos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getUInt16>
		<setInt16 public="1" get="inline" set="null" line="161">
			<f a="bytePos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setInt16>
		<setUInt16 public="1" get="inline" set="null" line="172">
			<f a="bytePos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="182">
			<f a="bytePos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getInt32>
		<setInt32 public="1" get="inline" set="null" line="192">
			<f a="bytePos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setInt32>
		<new set="method" line="21">
			<f a="inLengthOrBuffer:?inByteOffset:?inLength" v=":0:">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inByteOffset : 0 }</e></m></meta>
		</new>
		<meta><m n=":nativeProperty"/></meta>
	</class>
	<typedef path="nme.utils.ByteArrayData" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/ByteArray.hx" module="nme.utils.ByteArray"><c path="nme.utils.ByteArray"/></typedef>
	<enum path="nme.utils.CompressionAlgorithm" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<ZLIB/>
		<LZMA/>
		<GZIP/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="nme.utils.Endian" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" expr="&quot;bigEndian&quot;" line="6" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"bigEndian"</e></m></meta>
		</BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" expr="&quot;littleEndian&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"littleEndian"</e></m></meta>
		</LITTLE_ENDIAN>
	</class>
	<class path="nme.utils.Float32Buffer" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Float32Buffer.hx">
		<extends path="nme.utils.ByteArray"/>
		<hxcppSetFloat set="method" static="1">
			<f a="b:pos:val">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_memory_set_float"</e></m></meta>
		</hxcppSetFloat>
		<hxcppGetFloat set="method" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_memory_get_float"</e></m></meta>
		</hxcppGetFloat>
		<count public="1" set="null"><x path="Int"/></count>
		<resize public="1" set="method" line="50"><f a="inSize">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setF32 public="1" get="inline" set="null" line="73"><f a="index:val">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setF32>
		<getF32 public="1" get="inline" set="null" line="101"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getF32>
		<setF32q public="1" get="inline" set="null" line="119"><f a="index:val">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setF32q>
		<new public="1" set="method" line="21">
			<f a="?inCount:?inWriteOnly" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inWriteOnly : false, inCount : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<abstract path="nme.utils.Floats3264" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Floats3264.hx">
		<from>
			<icast field="fromArrayFloat"><c path="Array"><x path="Float"/></c></icast>
			<icast field="fromArrayFloat32Buffer"><c path="nme.utils.Float32Buffer"/></icast>
			<icast field="fromArray32Float"><c path="Array"><x path="cpp.Float32"/></c></icast>
		</from>
		<this><d/></this>
		<to><icast field="toDynamic"><unknown/></icast></to>
		<impl><class path="nme.utils._Floats3264.Floats3264_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Floats3264.hx" private="1" module="nme.utils.Floats3264" final="1">
	<_new public="1" get="inline" set="null" line="6" static="1">
		<f a="d">
			<d/>
			<x path="nme.utils.Floats3264"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toDynamic get="inline" set="null" line="7" static="1">
		<f a="this">
			<d/>
			<unknown/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toDynamic>
	<fromArrayFloat get="inline" set="null" line="8" static="1">
		<f a="f">
			<c path="Array"><x path="Float"/></c>
			<x path="nme.utils.Floats3264"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArrayFloat>
	<fromArrayFloat32Buffer get="inline" set="null" line="10" static="1">
		<f a="f">
			<c path="nme.utils.Float32Buffer"/>
			<x path="nme.utils.Floats3264"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArrayFloat32Buffer>
	<fromArray32Float get="inline" set="null" line="13" static="1">
		<f a="f">
			<c path="Array"><x path="cpp.Float32"/></c>
			<x path="nme.utils.Floats3264"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray32Float>
</class></impl>
	</abstract>
	<class path="nme.utils._Floats3264.Floats3264_Impl_" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Floats3264.hx" private="1" module="nme.utils.Floats3264" final="1">
		<_new public="1" get="inline" set="null" line="6" static="1">
			<f a="d">
				<d/>
				<x path="nme.utils.Floats3264"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toDynamic get="inline" set="null" line="7" static="1">
			<f a="this">
				<d/>
				<unknown/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toDynamic>
		<fromArrayFloat get="inline" set="null" line="8" static="1">
			<f a="f">
				<c path="Array"><x path="Float"/></c>
				<x path="nme.utils.Floats3264"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArrayFloat>
		<fromArrayFloat32Buffer get="inline" set="null" line="10" static="1">
			<f a="f">
				<c path="nme.utils.Float32Buffer"/>
				<x path="nme.utils.Floats3264"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArrayFloat32Buffer>
		<fromArray32Float get="inline" set="null" line="13" static="1">
			<f a="f">
				<c path="Array"><x path="cpp.Float32"/></c>
				<x path="nme.utils.Floats3264"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray32Float>
	</class>
	<typedef path="nme.utils.SmallFloats" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/Floats3264.hx" module="nme.utils.Floats3264"><c path="Array"><x path="cpp.Float32"/></c></typedef>
	<class path="nme.utils.UInt8Array" params="" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/UInt8Array.hx">
		<extends path="nme.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</SBYTES_PER_ELEMENT>
		<fromBytes public="1" set="method" line="53" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<subarray public="1" set="method" line="56">
			<f a="?start:?end" v="0:">
				<x path="Int"/>
				<x path="Int"/>
				<c path="nme.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ start : 0 }</e></m></meta>
		</subarray>
		<__get public="1" get="inline" set="null" line="64">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__get>
		<__set public="1" get="inline" set="null" line="67">
			<f a="index:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__set>
		<new public="1" set="method" line="15">
			<f a="?inBufferOrArray:?inStart:?inElements" v=":0:">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ inStart : 0 }</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeProperty"/>
		</meta>
	</class>
	<class path="nme.utils.WeakRef" params="T" file="/usr/local/lib/haxeLibrary/nme/6,0,123/src/nme/utils/WeakRef.hx">
		<hardRef>
			<c path="nme.utils.WeakRef.T"/>
			<haxe_doc>@private</haxe_doc>
		</hardRef>
		<weakRef>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</weakRef>
		<get public="1" set="method" line="39">
			<f a=""><c path="nme.utils.WeakRef.T"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get>
		<toString public="1" set="method" line="61"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="17">
			<f a="inObject:?inMakeWeak" v=":true">
				<c path="nme.utils.WeakRef.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ inMakeWeak : true }</e></m>
			</meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.Vector" params="T" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx">
		<from>
			<icast field="fromBoolVector"><c path="openfl._Vector.BoolVector"/></icast>
			<icast field="fromIntVector"><c path="openfl._Vector.IntVector"/></icast>
			<icast field="fromFloatVector"><c path="openfl._Vector.FloatVector"/></icast>
			<icast field="fromFunctionVector"><c path="openfl._Vector.FunctionVector"/></icast>
			<icast field="fromObjectVector"><c path="openfl._Vector.ObjectVector"><c path="fromObjectVector.T"/></c></icast>
		</from>
		<this><c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c></this>
		<to>
			<icast field="toBoolVector"><c path="openfl._Vector.BoolVector"/></icast>
			<icast field="toIntVector"><c path="openfl._Vector.IntVector"/></icast>
			<icast field="toFloatVector"><c path="openfl._Vector.FloatVector"/></icast>
			<icast field="toFunctionVector"><c path="openfl._Vector.FunctionVector"/></icast>
			<icast field="toObjectVector"><c path="openfl._Vector.ObjectVector"><c path="toObjectVector.T"/></c></icast>
			<icast field="toNullVector"><c path="openfl._Vector.ObjectVector"><c path="toNullVector.T"/></c></icast>
		</to>
		<haxe_doc><![CDATA[The Vector class lets you access and manipulate a vector — an array whose elements
	all have the same data type. The data type of a Vector's elements is known as the
	Vector's base type. The base type can be any class, including built in classes and
	custom classes. The base type is specified when declaring a Vector variable as well
	as when creating an instance by calling the class constructor.

	As with an Array, you can use the array access operator (`[]`) to set or retrieve the
	value of a Vector element. Several Vector methods also provide mechanisms for
	setting and retrieving element values. These include `push()`, `pop()`, `shift()`,
	`unshift()`, and others. The properties and methods of a Vector object are
	similar — in most cases identical — to the properties and methods of an Array. In
	most cases where you would use an Array in which all the elements have the same
	data type, a Vector instance is preferable. However, Vector instances are dense
	arrays, meaning it must have a value (or `null`) in each index. Array instances
	don't have this same restriction.

	The Vector's base type is specified using postfix type parameter syntax. Type
	parameter syntax is a sequence consisting of a dot (`.`), left angle bracket (`<`),
	class name, then a right angle bracket (`>`), as shown in this example:

	In the first line of the example, the variable `v` is declared as a
	Vector.<String> instance. In other words, it represents a Vector (an array) that
	can only hold String instances and from which only String instances can be
	retrieved. The second line constructs an instance of the same Vector type (that is,
	a Vector whose elements are all String objects) and assigns it to `v`.

	```as3
	var v:Vector.<String>;
	v = new Vector.<String>();
	```

	A variable declared with the Vector.<T> data type can only store a Vector instance
	that is constructed with the same base type T. For example, a Vector that's
	constructed by calling `new Vector.<String>()` can't be assigned to a variable that's
	declared with the Vector.<int> data type. The base types must match exactly. For
	example, the following code doesn't compile because the object's base type isn't
	the same as the variable's declared base type (even though Sprite is a subclass of
	DisplayObject):

	```haxe
	// This code doesn't compile even though Sprite is a DisplayObject subclass
	var v:Vector.<DisplayObject> = new Vector.<Sprite>();
	```

	To convert a Vector with base type T to a Vector of a superclass of T, use the
	`Vector()` global function.

	In addition to the data type restriction, the Vector class has other restrictions
	that distinguish it from the Array class:

	* A Vector is a dense array. Unlike an Array, which may have values in indices 0 and 7
	even if there are no values in positions 1 through 6, a Vector must have a value
	(or null) in each index.
	* A Vector can optionally be fixed-length, meaning the number of elements it contains
	can't change.
	* Access to a Vector's elements is bounds-checked. You can never read a value from an
	index greater than the final element (length - 1). You can never set a value with an
	index more than one beyond the current final index (in other words, you can only set
	a value at an existing index or at index [length]).

	As a result of its restrictions, a Vector has three primary benefits over an Array
	instance whose elements are all instances of a single class:

	* Performance: array element access and iteration are much faster when using a
	Vector instance than they are when using an Array.
	* Type safety: in strict mode the compiler can identify data type errors. Examples
	of data type errors include assigning a value of the incorrect data type to a
	Vector or expecting the wrong data type when reading a value from a Vector. Note,
	however, that when using the push() method or unshift() method to add values to a
	Vector, the arguments' data types are not checked at compile time. Instead, they are
	checked at run time.
	* Reliability: runtime range checking (or fixed-length checking) increases
	reliability significantly over Arrays.]]></haxe_doc>
		<meta><m n=":multiType"><e>T</e></m></meta>
		<impl><class path="openfl._Vector.Vector_Impl_" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector" final="1">
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Indicates whether the `length` property of the Vector can be changed. If the
		value is `true`, the `length` property can't be changed. This means the
		following operations are not allowed when `fixed` is `true`:

		* setting the `length` property directly
		* assigning a value to index position length
		* calling a method that changes the `length` property, including:
			* `pop()`
			* `push()`
			* `shift()`
			* `unshift()`
			* `splice()` (if the `splice()` call changes the length of the Vector).</haxe_doc>
	</fixed>
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The range of valid indices available in the Vector. A Vector instance has index
		positions up to but not including the length value.

		Every Vector element always has a value that is either an instance of the base
		type or `null`. When the `length` property is set to a value that's larger than
		its previous value, additional elements are created and populated with the
		default value appropriate to the base type (`null` for reference types).

		When the `length` property is set to a value that's smaller than its previous
		value, all the elements at index positions greater than or equal to the new
		length value are removed from the Vector.</haxe_doc>
	</length>
	<_new public="1" set="method" static="1">
		<f a="?length:?fixed:?array" v="0:false:null">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":value"><e>{ array : null, fixed : false, length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc><![CDATA[Creates a Vector with the specified base type.

		When calling the `Vector.<T>()` constructor, specify the base type using
		type parameter syntax. Type parameter syntax is a sequence consisting of a
		dot (`.`), left angle bracket (`<`), class name, then a right angle bracket (`>`),
		as shown in this example:

		```as3
		var v:Vector.<String> = new Vector.<String>();
		```

		To create a Vector instance from an Array or another Vector (such as one with a
		different base type), use the `Vector()` global function.

		To create a pre-populated Vector instance, use the following syntax instead of
		using the parameters specified below:

		```as3
		// var v:Vector.<T> = new <T>[E0, ..., En-1 ,];
		// For example:
		var v:Vector.<int> = new <int>[0,1,2,];
		```

		The following information applies to this syntax:

		* It is supported in Flash Professional CS5 and later, Flash Builder 4 and later,
		and Flex 4 and later.
		* The trailing comma is optional.
		* Empty items in the array are not supported; a statement such as
		`var v:Vector.<int> = new <int>[0,,2,]` throws a compiler error.
		* You can't specify a default length for the Vector instance. Instead, the length
		is the same as the number of elements in the initialization list.
		* You can't specify whether the Vector instance has a fixed length. Instead, use
		the fixed property.
		* Data loss or errors can occur if items passed as values don't match the
		specified type. For example:

		```as3
		var v:Vector.<int> = new <int>[4.2]; // compiler error when running in strict mode
		trace(v[0]); //returns 4 when not running in strict mode
		```

		@param	length	The initial length (number of elements) of the Vector. If this
		parameter is greater than zero, the specified number of Vector elements are
		created and populated with the default value appropriate to the base type
		(`null` for reference types).
		@param	fixed	Whether the Vector's length is fixed (`true`) or can be changed
		(`false`). This value can also be set using the fixed property.]]></haxe_doc>
	</_new>
	<concat public="1" get="inline" set="null" line="191" static="1">
		<f a="this:?vec" v=":null">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":value"><e>{ vec : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Concatenates the Vectors specified in the parameters list with the elements in
		this Vector and creates a new Vector. The Vectors in the parameters list must
		have the same base type, or subtype, as this Vector. If you do not pass any
		parameters, the returned Vector is a duplicate (shallow clone) of the original
		Vector.

		@param	vec	A Vector of the base type, or subtype, of this Vector.
		@return	A Vector with the same base type as this Vector that contains the
		elements from this Vector followed by elements from the Vector in the
		parameter list.
		@throws	TypeError	If any argument is not a Vector of the base type, or cannot
		be converted to a Vector of the base type.</haxe_doc>
	</concat>
	<copy public="1" get="inline" set="null" line="200" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new shallow clone of the current Vector object
		@return	A new Vector object</haxe_doc>
	</copy>
	<filter public="1" get="inline" set="null" line="212" static="1">
		<f a="this:callback">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<f a="">
				<c path="openfl.Vector.T"/>
				<x path="Bool"/>
			</f>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
		<haxe_doc>Executes a test function on each item in the Vector and returns a new Vector
		containing all items that return true for the specified function. If an item
		returns false, it is not included in the result Vector. The base type of the return
		Vector matches the base type of the Vector on which the method is called.
		@param	callback	The function to run on each item in the Vector.</haxe_doc>
	</filter>
	<get public="1" get="inline" set="null" line="220" static="1">
		<f a="this:index">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Array access</haxe_doc>
	</get>
	<indexOf public="1" get="inline" set="null" line="236" static="1">
		<f a="this:searchElement:?fromIndex" v="::0">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ fromIndex : 0 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Searches for an item in the Vector and returns the index position of the item.
		The item is compared to the Vector elements using strict equality (`===`).
		@param	searchElement	The item to find in the Vector.
		@param	fromIndex	The location in the Vector from which to start searching for
		the item. If this parameter is negative, it is treated as `length + fromIndex`,
		meaning the search starts -fromIndex items from the end and searches from that
		position forward to the end of the Vector.
		@return	A zero-based index position of the item in the Vector. If the
		`searchElement` argument is not found, the return value is -1.</haxe_doc>
	</indexOf>
	<insertAt public="1" get="inline" set="null" line="252" static="1">
		<f a="this:index:element">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Insert a single element into the Vector. This method modifies the Vector without
		making a copy.

		@param	index	An integer that specifies the position in the Vector where the
		element is to be inserted. You can use a negative integer to specify a position
		relative to the end of the Vector (for example, -1 for the last element of the
		Vector).
		@param	element	The value to insert
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
	</insertAt>
	<iterator public="1" get="inline" set="null" line="260" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<t path="Iterator"><c path="openfl.Vector.T"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
		<haxe_doc>Iterator</haxe_doc>
	</iterator>
	<join public="1" get="inline" set="null" line="276" static="1">
		<f a="this:?sep" v=":&quot;,&quot;">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":value"><e>{ sep : "," }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Converts the elements in the Vector to strings, inserts the specified separator
		between the elements, concatenates them, and returns the resulting string. A
		nested Vector is always separated by a comma (`,`), not by the separator passed
		to the `join()` method.

		@param	sep	A character or string that separates Vector elements in the returned
		string. If you omit this parameter, a comma is used as the default separator.
		@return	A string consisting of the elements of the Vector converted to strings
		and separated by the specified string.</haxe_doc>
	</join>
	<lastIndexOf public="1" get="inline" set="null" line="297" static="1">
		<f a="this:searchElement:?fromIndex" v="::null">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ fromIndex : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Searches for an item in the Vector, working backward from the specified index
		position, and returns the index position of the matching item. The item is
		compared to the Vector elements using strict equality (`===`).

		@param	searchElement	The item to find in the Vector.
		@param	fromIndex	The location in the Vector from which to start searching for
		the item. The default is the maximum allowable index value, meaning that the
		search starts at the last item in the Vector.

		If this parameter is negative, it is treated as `length + fromIndex`, meaning the
		search starts -fromIndex items from the end and searches from that position
		backward to index 0.
		@return	A zero-based index position of the item in the Vector. If the
		`searchElement` argument is not found, the return value is -1.</haxe_doc>
	</lastIndexOf>
	<pop public="1" get="inline" set="null" line="308" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Null"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the last element from the Vector and returns that element. The `length`
		property of the Vector is decreased by one when this function is called.
		@return	The value of the last element in the specified Vector.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
	</pop>
	<push public="1" get="inline" set="null" line="328" static="1">
		<f a="this:value">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Adds one or more elements to the end of the Vector and returns the new length of
		the Vector.

		Because this function can accept multiple arguments, the data type of the
		arguments is not checked at compile time even in strict mode. However, if an
		argument is passed that is not an instance of the base type, an exception
		occurs at run time.

		@param	value	A value to append to the Vector.
		@return	The length of the Vector after the new elements are added.
		@throws	TypeError	If any argument is not an instance of the base type T of
		the Vector.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
	</push>
	<removeAt public="1" get="inline" set="null" line="346" static="1">
		<f a="this:index">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Remove a single element from the Vector. This method modifies the Vector without
		making a copy.

		@param	index	An integer that specifies the index of the element in the Vector
		that is to be deleted. You can use a negative integer to specify a position
		relative to the end of the Vector (for example, -1 for the last element of the
		Vector).
		@return	The element that was removed from the original Vector.
		@throws	RangeError	If the index argument specifies an index to be deleted that's
		outside the Vector's bounds.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
	</removeAt>
	<reverse public="1" get="inline" set="null" line="357" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Reverses the order of the elements in the Vector. This method alters the Vector
		on which it is called.

		@return	The Vector with the elements in reverse order.</haxe_doc>
	</reverse>
	<set public="1" get="inline" set="null" line="365" static="1">
		<f a="this:index:value">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
			<c path="openfl.Vector.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Array access</haxe_doc>
	</set>
	<shift public="1" get="inline" set="null" line="377" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Null"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the first element from the Vector and returns that element. The
		remaining Vector elements are moved from their original position, i, to i - 1.

		@return	The first element in the Vector.
		@throws	RangeError	If `fixed` is `true`.</haxe_doc>
	</shift>
	<slice public="1" get="inline" set="null" line="401" static="1">
		<f a="this:?startIndex:?endIndex" v=":0:null">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Returns a new Vector that consists of a range of elements from the original
		Vector, without modifying the original Vector. The returned Vector includes the
		`startIndex` element and all elements up to, but not including, the
		`endIndex` element.

		If you don't pass any parameters, the new Vector is a duplicate (shallow clone) of
		the original Vector. If you pass a value of 0 for both parameters, a new, empty
		Vector is created of the same type as the original Vector.

		@param	startIndex	A number specifying the index of the starting point for the
		slice. If startIndex is a negative number, the starting point begins at the end
		of the Vector, where -1 is the last element.
		@param	endIndex	A number specifying the index of the ending point for the
		slice. If you omit this parameter, the slice includes all elements from the
		starting point to the end of the Vector. If endIndex is a negative number, the
		ending point is specified from the end of the Vector, where -1 is the last element.
		@return	A Vector that consists of a range of elements from the original Vector.</haxe_doc>
	</slice>
	<sort public="1" get="inline" set="null" line="449" static="1">
		<f a="this:sortBehavior">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<f a=":">
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sorts the elements in the Vector object, and also returns a sorted Vector object.
		This method sorts according to the parameter sortBehavior, which is either a
		function that compares two values, or a set of sorting options.

		The method takes one parameter. The parameter is one of the following:

		* a function that takes two arguments of the base type (T) of the Vector and
		returns a Number:

			```as3
			function compare(x:T, y:T):Number {}
			```

			The logic of the function is that, given two elements `x` and `y`, the function
			returns one of the following three values:

			* a negative number, if `x` should appear before `y` in the sorted sequence
			* 0, if `x` equals `y`
			* a positive number, if `x` should appear after `y` in the sorted sequence

		* a number which is a bitwise OR of the following values:
			* 1 or `Array.CASEINSENSITIVE`
			* 2 or `Array.DESCENDING`
			* 4 or `Array.UNIQUESORT`
			* 8 or `Array.RETURNINDEXEDARRAY`
			* 16 or `Array.NUMERIC`

			If the value is 0, the sort works in the following way:

			* Sorting is case-sensitive (Z precedes a).
			* Sorting is ascending (a precedes b).
			* The array is modified to reflect the sort order; multiple elements that
			have identical sort fields are placed consecutively in the sorted array in
			no particular order.
			* All elements, regardless of data type, are sorted as if they were strings,
			so 100 precedes 99, because "1" is a lower string value than "9".

		@param	sortBehavior	A Function or a Number value that determines the
		behavior of the sort. A Function parameter specifies a comparison method. A
		Number value specifies the sorting options.
		@return	A Vector object, with elements in the new order.</haxe_doc>
	</sort>
	<splice public="1" get="inline" set="null" line="474" static="1">
		<f a="this:startIndex:deleteCount">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Adds elements to and removes elements from the Vector. This method modifies the
		Vector without making a copy.

		**Note:** To override this method in a subclass of Vector, use ...args for the
		parameters, as this example shows:

		```as3
		public override function splice(...args) {
		// your statements here
		}
		```

		@param	startIndex:int — An integer that specifies the index of the element in the Vector where the insertion or deletion begins. You can use a negative integer to specify a position relative to the end of the Vector (for example, -1 for the last element of the Vector).
		@param	deleteCount:uint (default = 4294967295) — An integer that specifies the number of elements to be deleted. This number includes the element specified in the startIndex parameter. If the value is 0, no elements are deleted.
		@param	... items — An optional list of one or more comma-separated values to insert into the Vector at the position specified in the startIndex parameter.
		@return	a Vector containing the elements that were removed from the original Vector.
		@throws	RangeError	If the startIndex and deleteCount arguments specify an index to be deleted that's outside the Vector's bounds.
		@throws	RangeError	If this method is called while fixed is true and the splice() operation changes the length of the Vector.</haxe_doc>
	</splice>
	<toString public="1" get="inline" set="null" line="487" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a string that represents the elements in the Vector. Every element in the
		Vector, starting with index 0 and ending with the highest index, is converted to
		a concatenated string and separated by commas. To specify a custom separator,
		use the `Vector.join()` method.

		@return	A string of Vector elements.</haxe_doc>
	</toString>
	<unshift public="1" get="inline" set="null" line="509" static="1">
		<f a="this:value">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Adds one or more elements to the beginning of the Vector and returns the new
		length of the Vector. The other elements in the Vector are moved from their
		original position, i, to i + the number of new elements.

		Because this function can accept multiple arguments, the data type of the
		arguments is not checked at compile time even in strict mode. However, if an
		argument is passed that is not an instance of the base type, an exception occurs
		at run time.

		@param	value	An instance of the base type of the Vector to be inserted at the
		beginning of the Vector.
		@return	An integer representing the new length of the Vector.
		@throws	TypeError	If any argument is not an instance of the base type T of the
		Vector.
		@throws	RangeError	If this method is called while fixed is true.</haxe_doc>
	</unshift>
	<ofArray public="1" params="T" get="inline" set="null" line="519" static="1">
		<f a="array">
			<c path="Array"><c path="ofArray.T"/></c>
			<x path="openfl.Vector"><c path="ofArray.T"/></x>
		</f>
		<meta><m n=":generic"/></meta>
		<haxe_doc>Creates a new Vector object using the values from an Array object
		@param	array	An Array object
		@return	A new Vector object</haxe_doc>
	</ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="536" static="1">
		<f a="vec">
			<c path="openfl._Vector.IVector"><c path="convert.T"/></c>
			<c path="openfl._Vector.IVector"><c path="convert.U"/></c>
		</f>
		<haxe_doc>Attempts to cast a Vector to another Vector object of a similar type
		@param	vec	A Vector object to cast
		@return	The casted Vector object</haxe_doc>
	</convert>
	<toBoolVector params="T" get="inline" set="null" line="542" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toBoolVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toBoolVector.T"/></c>
			<c path="openfl._Vector.BoolVector"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toBoolVector>
	<toIntVector params="T" get="inline" set="null" line="547" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toIntVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toIntVector.T"/></c>
			<c path="openfl._Vector.IntVector"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIntVector>
	<toFloatVector params="T" get="inline" set="null" line="552" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toFloatVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toFloatVector.T"/></c>
			<c path="openfl._Vector.FloatVector"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFloatVector>
	<toFunctionVector params="T" get="inline" set="null" line="558" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toFunctionVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toFunctionVector.T"/></c>
			<c path="openfl._Vector.FunctionVector"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFunctionVector>
	<toObjectVector params="T" get="inline" set="null" line="565" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toObjectVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toObjectVector.T"/></c>
			<c path="openfl._Vector.ObjectVector"><c path="toObjectVector.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toObjectVector>
	<toNullVector params="T" get="inline" set="null" line="570" static="1">
		<f a="t:length:fixed:array">
			<c path="openfl._Vector.IVector"><c path="toNullVector.T"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="toNullVector.T"/></c>
			<c path="openfl._Vector.ObjectVector"><c path="toNullVector.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
			<m n=":to"/>
		</meta>
	</toNullVector>
	<fromBoolVector params="T" get="inline" set="null" line="576" static="1">
		<f a="vector">
			<c path="openfl._Vector.BoolVector"/>
			<x path="openfl.Vector"><c path="fromBoolVector.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromBoolVector>
	<fromIntVector params="T" get="inline" set="null" line="581" static="1">
		<f a="vector">
			<c path="openfl._Vector.IntVector"/>
			<x path="openfl.Vector"><c path="fromIntVector.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntVector>
	<fromFloatVector params="T" get="inline" set="null" line="586" static="1">
		<f a="vector">
			<c path="openfl._Vector.FloatVector"/>
			<x path="openfl.Vector"><c path="fromFloatVector.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloatVector>
	<fromFunctionVector params="T" get="inline" set="null" line="592" static="1">
		<f a="vector">
			<c path="openfl._Vector.FunctionVector"/>
			<x path="openfl.Vector"><c path="fromFunctionVector.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromFunctionVector>
	<fromObjectVector params="T" get="inline" set="null" line="598" static="1">
		<f a="vector">
			<c path="openfl._Vector.ObjectVector"><c path="fromObjectVector.T"/></c>
			<x path="openfl.Vector"><c path="fromObjectVector.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectVector>
	<get_fixed get="inline" set="null" line="605" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_fixed>
	<set_fixed get="inline" set="null" line="610" static="1">
		<f a="this:value">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_fixed>
	<get_length get="inline" set="null" line="615" static="1">
		<f a="this">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_length>
	<set_length get="inline" set="null" line="620" static="1">
		<f a="this:value">
			<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_length>
</class></impl>
	</abstract>
	<class path="openfl._Vector.Vector_Impl_" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector" final="1">
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Indicates whether the `length` property of the Vector can be changed. If the
		value is `true`, the `length` property can't be changed. This means the
		following operations are not allowed when `fixed` is `true`:

		* setting the `length` property directly
		* assigning a value to index position length
		* calling a method that changes the `length` property, including:
			* `pop()`
			* `push()`
			* `shift()`
			* `unshift()`
			* `splice()` (if the `splice()` call changes the length of the Vector).</haxe_doc>
		</fixed>
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The range of valid indices available in the Vector. A Vector instance has index
		positions up to but not including the length value.

		Every Vector element always has a value that is either an instance of the base
		type or `null`. When the `length` property is set to a value that's larger than
		its previous value, additional elements are created and populated with the
		default value appropriate to the base type (`null` for reference types).

		When the `length` property is set to a value that's smaller than its previous
		value, all the elements at index positions greater than or equal to the new
		length value are removed from the Vector.</haxe_doc>
		</length>
		<_new public="1" set="method" static="1">
			<f a="?length:?fixed:?array" v="0:false:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":value"><e>{ array : null, fixed : false, length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc><![CDATA[Creates a Vector with the specified base type.

		When calling the `Vector.<T>()` constructor, specify the base type using
		type parameter syntax. Type parameter syntax is a sequence consisting of a
		dot (`.`), left angle bracket (`<`), class name, then a right angle bracket (`>`),
		as shown in this example:

		```as3
		var v:Vector.<String> = new Vector.<String>();
		```

		To create a Vector instance from an Array or another Vector (such as one with a
		different base type), use the `Vector()` global function.

		To create a pre-populated Vector instance, use the following syntax instead of
		using the parameters specified below:

		```as3
		// var v:Vector.<T> = new <T>[E0, ..., En-1 ,];
		// For example:
		var v:Vector.<int> = new <int>[0,1,2,];
		```

		The following information applies to this syntax:

		* It is supported in Flash Professional CS5 and later, Flash Builder 4 and later,
		and Flex 4 and later.
		* The trailing comma is optional.
		* Empty items in the array are not supported; a statement such as
		`var v:Vector.<int> = new <int>[0,,2,]` throws a compiler error.
		* You can't specify a default length for the Vector instance. Instead, the length
		is the same as the number of elements in the initialization list.
		* You can't specify whether the Vector instance has a fixed length. Instead, use
		the fixed property.
		* Data loss or errors can occur if items passed as values don't match the
		specified type. For example:

		```as3
		var v:Vector.<int> = new <int>[4.2]; // compiler error when running in strict mode
		trace(v[0]); //returns 4 when not running in strict mode
		```

		@param	length	The initial length (number of elements) of the Vector. If this
		parameter is greater than zero, the specified number of Vector elements are
		created and populated with the default value appropriate to the base type
		(`null` for reference types).
		@param	fixed	Whether the Vector's length is fixed (`true`) or can be changed
		(`false`). This value can also be set using the fixed property.]]></haxe_doc>
		</_new>
		<concat public="1" get="inline" set="null" line="191" static="1">
			<f a="this:?vec" v=":null">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":value"><e>{ vec : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Concatenates the Vectors specified in the parameters list with the elements in
		this Vector and creates a new Vector. The Vectors in the parameters list must
		have the same base type, or subtype, as this Vector. If you do not pass any
		parameters, the returned Vector is a duplicate (shallow clone) of the original
		Vector.

		@param	vec	A Vector of the base type, or subtype, of this Vector.
		@return	A Vector with the same base type as this Vector that contains the
		elements from this Vector followed by elements from the Vector in the
		parameter list.
		@throws	TypeError	If any argument is not a Vector of the base type, or cannot
		be converted to a Vector of the base type.</haxe_doc>
		</concat>
		<copy public="1" get="inline" set="null" line="200" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new shallow clone of the current Vector object
		@return	A new Vector object</haxe_doc>
		</copy>
		<filter public="1" get="inline" set="null" line="212" static="1">
			<f a="this:callback">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<f a="">
					<c path="openfl.Vector.T"/>
					<x path="Bool"/>
				</f>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Executes a test function on each item in the Vector and returns a new Vector
		containing all items that return true for the specified function. If an item
		returns false, it is not included in the result Vector. The base type of the return
		Vector matches the base type of the Vector on which the method is called.
		@param	callback	The function to run on each item in the Vector.</haxe_doc>
		</filter>
		<get public="1" get="inline" set="null" line="220" static="1">
			<f a="this:index">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Array access</haxe_doc>
		</get>
		<indexOf public="1" get="inline" set="null" line="236" static="1">
			<f a="this:searchElement:?fromIndex" v="::0">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ fromIndex : 0 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Searches for an item in the Vector and returns the index position of the item.
		The item is compared to the Vector elements using strict equality (`===`).
		@param	searchElement	The item to find in the Vector.
		@param	fromIndex	The location in the Vector from which to start searching for
		the item. If this parameter is negative, it is treated as `length + fromIndex`,
		meaning the search starts -fromIndex items from the end and searches from that
		position forward to the end of the Vector.
		@return	A zero-based index position of the item in the Vector. If the
		`searchElement` argument is not found, the return value is -1.</haxe_doc>
		</indexOf>
		<insertAt public="1" get="inline" set="null" line="252" static="1">
			<f a="this:index:element">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Insert a single element into the Vector. This method modifies the Vector without
		making a copy.

		@param	index	An integer that specifies the position in the Vector where the
		element is to be inserted. You can use a negative integer to specify a position
		relative to the end of the Vector (for example, -1 for the last element of the
		Vector).
		@param	element	The value to insert
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
		</insertAt>
		<iterator public="1" get="inline" set="null" line="260" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<t path="Iterator"><c path="openfl.Vector.T"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Iterator</haxe_doc>
		</iterator>
		<join public="1" get="inline" set="null" line="276" static="1">
			<f a="this:?sep" v=":&quot;,&quot;">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ sep : "," }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Converts the elements in the Vector to strings, inserts the specified separator
		between the elements, concatenates them, and returns the resulting string. A
		nested Vector is always separated by a comma (`,`), not by the separator passed
		to the `join()` method.

		@param	sep	A character or string that separates Vector elements in the returned
		string. If you omit this parameter, a comma is used as the default separator.
		@return	A string consisting of the elements of the Vector converted to strings
		and separated by the specified string.</haxe_doc>
		</join>
		<lastIndexOf public="1" get="inline" set="null" line="297" static="1">
			<f a="this:searchElement:?fromIndex" v="::null">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ fromIndex : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Searches for an item in the Vector, working backward from the specified index
		position, and returns the index position of the matching item. The item is
		compared to the Vector elements using strict equality (`===`).

		@param	searchElement	The item to find in the Vector.
		@param	fromIndex	The location in the Vector from which to start searching for
		the item. The default is the maximum allowable index value, meaning that the
		search starts at the last item in the Vector.

		If this parameter is negative, it is treated as `length + fromIndex`, meaning the
		search starts -fromIndex items from the end and searches from that position
		backward to index 0.
		@return	A zero-based index position of the item in the Vector. If the
		`searchElement` argument is not found, the return value is -1.</haxe_doc>
		</lastIndexOf>
		<pop public="1" get="inline" set="null" line="308" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Null"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the last element from the Vector and returns that element. The `length`
		property of the Vector is decreased by one when this function is called.
		@return	The value of the last element in the specified Vector.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
		</pop>
		<push public="1" get="inline" set="null" line="328" static="1">
			<f a="this:value">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Adds one or more elements to the end of the Vector and returns the new length of
		the Vector.

		Because this function can accept multiple arguments, the data type of the
		arguments is not checked at compile time even in strict mode. However, if an
		argument is passed that is not an instance of the base type, an exception
		occurs at run time.

		@param	value	A value to append to the Vector.
		@return	The length of the Vector after the new elements are added.
		@throws	TypeError	If any argument is not an instance of the base type T of
		the Vector.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
		</push>
		<removeAt public="1" get="inline" set="null" line="346" static="1">
			<f a="this:index">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Remove a single element from the Vector. This method modifies the Vector without
		making a copy.

		@param	index	An integer that specifies the index of the element in the Vector
		that is to be deleted. You can use a negative integer to specify a position
		relative to the end of the Vector (for example, -1 for the last element of the
		Vector).
		@return	The element that was removed from the original Vector.
		@throws	RangeError	If the index argument specifies an index to be deleted that's
		outside the Vector's bounds.
		@throws	RangeError	If this method is called while `fixed` is `true`.</haxe_doc>
		</removeAt>
		<reverse public="1" get="inline" set="null" line="357" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Reverses the order of the elements in the Vector. This method alters the Vector
		on which it is called.

		@return	The Vector with the elements in reverse order.</haxe_doc>
		</reverse>
		<set public="1" get="inline" set="null" line="365" static="1">
			<f a="this:index:value">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Array access</haxe_doc>
		</set>
		<shift public="1" get="inline" set="null" line="377" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Null"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the first element from the Vector and returns that element. The
		remaining Vector elements are moved from their original position, i, to i - 1.

		@return	The first element in the Vector.
		@throws	RangeError	If `fixed` is `true`.</haxe_doc>
		</shift>
		<slice public="1" get="inline" set="null" line="401" static="1">
			<f a="this:?startIndex:?endIndex" v=":0:null">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Returns a new Vector that consists of a range of elements from the original
		Vector, without modifying the original Vector. The returned Vector includes the
		`startIndex` element and all elements up to, but not including, the
		`endIndex` element.

		If you don't pass any parameters, the new Vector is a duplicate (shallow clone) of
		the original Vector. If you pass a value of 0 for both parameters, a new, empty
		Vector is created of the same type as the original Vector.

		@param	startIndex	A number specifying the index of the starting point for the
		slice. If startIndex is a negative number, the starting point begins at the end
		of the Vector, where -1 is the last element.
		@param	endIndex	A number specifying the index of the ending point for the
		slice. If you omit this parameter, the slice includes all elements from the
		starting point to the end of the Vector. If endIndex is a negative number, the
		ending point is specified from the end of the Vector, where -1 is the last element.
		@return	A Vector that consists of a range of elements from the original Vector.</haxe_doc>
		</slice>
		<sort public="1" get="inline" set="null" line="449" static="1">
			<f a="this:sortBehavior">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<f a=":">
					<c path="openfl.Vector.T"/>
					<c path="openfl.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sorts the elements in the Vector object, and also returns a sorted Vector object.
		This method sorts according to the parameter sortBehavior, which is either a
		function that compares two values, or a set of sorting options.

		The method takes one parameter. The parameter is one of the following:

		* a function that takes two arguments of the base type (T) of the Vector and
		returns a Number:

			```as3
			function compare(x:T, y:T):Number {}
			```

			The logic of the function is that, given two elements `x` and `y`, the function
			returns one of the following three values:

			* a negative number, if `x` should appear before `y` in the sorted sequence
			* 0, if `x` equals `y`
			* a positive number, if `x` should appear after `y` in the sorted sequence

		* a number which is a bitwise OR of the following values:
			* 1 or `Array.CASEINSENSITIVE`
			* 2 or `Array.DESCENDING`
			* 4 or `Array.UNIQUESORT`
			* 8 or `Array.RETURNINDEXEDARRAY`
			* 16 or `Array.NUMERIC`

			If the value is 0, the sort works in the following way:

			* Sorting is case-sensitive (Z precedes a).
			* Sorting is ascending (a precedes b).
			* The array is modified to reflect the sort order; multiple elements that
			have identical sort fields are placed consecutively in the sorted array in
			no particular order.
			* All elements, regardless of data type, are sorted as if they were strings,
			so 100 precedes 99, because "1" is a lower string value than "9".

		@param	sortBehavior	A Function or a Number value that determines the
		behavior of the sort. A Function parameter specifies a comparison method. A
		Number value specifies the sorting options.
		@return	A Vector object, with elements in the new order.</haxe_doc>
		</sort>
		<splice public="1" get="inline" set="null" line="474" static="1">
			<f a="this:startIndex:deleteCount">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Adds elements to and removes elements from the Vector. This method modifies the
		Vector without making a copy.

		**Note:** To override this method in a subclass of Vector, use ...args for the
		parameters, as this example shows:

		```as3
		public override function splice(...args) {
		// your statements here
		}
		```

		@param	startIndex:int — An integer that specifies the index of the element in the Vector where the insertion or deletion begins. You can use a negative integer to specify a position relative to the end of the Vector (for example, -1 for the last element of the Vector).
		@param	deleteCount:uint (default = 4294967295) — An integer that specifies the number of elements to be deleted. This number includes the element specified in the startIndex parameter. If the value is 0, no elements are deleted.
		@param	... items — An optional list of one or more comma-separated values to insert into the Vector at the position specified in the startIndex parameter.
		@return	a Vector containing the elements that were removed from the original Vector.
		@throws	RangeError	If the startIndex and deleteCount arguments specify an index to be deleted that's outside the Vector's bounds.
		@throws	RangeError	If this method is called while fixed is true and the splice() operation changes the length of the Vector.</haxe_doc>
		</splice>
		<toString public="1" get="inline" set="null" line="487" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a string that represents the elements in the Vector. Every element in the
		Vector, starting with index 0 and ending with the highest index, is converted to
		a concatenated string and separated by commas. To specify a custom separator,
		use the `Vector.join()` method.

		@return	A string of Vector elements.</haxe_doc>
		</toString>
		<unshift public="1" get="inline" set="null" line="509" static="1">
			<f a="this:value">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Adds one or more elements to the beginning of the Vector and returns the new
		length of the Vector. The other elements in the Vector are moved from their
		original position, i, to i + the number of new elements.

		Because this function can accept multiple arguments, the data type of the
		arguments is not checked at compile time even in strict mode. However, if an
		argument is passed that is not an instance of the base type, an exception occurs
		at run time.

		@param	value	An instance of the base type of the Vector to be inserted at the
		beginning of the Vector.
		@return	An integer representing the new length of the Vector.
		@throws	TypeError	If any argument is not an instance of the base type T of the
		Vector.
		@throws	RangeError	If this method is called while fixed is true.</haxe_doc>
		</unshift>
		<ofArray public="1" params="T" get="inline" set="null" line="519" static="1">
			<f a="array">
				<c path="Array"><c path="ofArray.T"/></c>
				<x path="openfl.Vector"><c path="ofArray.T"/></x>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>Creates a new Vector object using the values from an Array object
		@param	array	An Array object
		@return	A new Vector object</haxe_doc>
		</ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="536" static="1">
			<f a="vec">
				<c path="openfl._Vector.IVector"><c path="convert.T"/></c>
				<c path="openfl._Vector.IVector"><c path="convert.U"/></c>
			</f>
			<haxe_doc>Attempts to cast a Vector to another Vector object of a similar type
		@param	vec	A Vector object to cast
		@return	The casted Vector object</haxe_doc>
		</convert>
		<toBoolVector params="T" get="inline" set="null" line="542" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toBoolVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toBoolVector.T"/></c>
				<c path="openfl._Vector.BoolVector"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toBoolVector>
		<toIntVector params="T" get="inline" set="null" line="547" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toIntVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toIntVector.T"/></c>
				<c path="openfl._Vector.IntVector"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIntVector>
		<toFloatVector params="T" get="inline" set="null" line="552" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toFloatVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toFloatVector.T"/></c>
				<c path="openfl._Vector.FloatVector"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFloatVector>
		<toFunctionVector params="T" get="inline" set="null" line="558" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toFunctionVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toFunctionVector.T"/></c>
				<c path="openfl._Vector.FunctionVector"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFunctionVector>
		<toObjectVector params="T" get="inline" set="null" line="565" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toObjectVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toObjectVector.T"/></c>
				<c path="openfl._Vector.ObjectVector"><c path="toObjectVector.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toObjectVector>
		<toNullVector params="T" get="inline" set="null" line="570" static="1">
			<f a="t:length:fixed:array">
				<c path="openfl._Vector.IVector"><c path="toNullVector.T"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="toNullVector.T"/></c>
				<c path="openfl._Vector.ObjectVector"><c path="toNullVector.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":to"/>
			</meta>
		</toNullVector>
		<fromBoolVector params="T" get="inline" set="null" line="576" static="1">
			<f a="vector">
				<c path="openfl._Vector.BoolVector"/>
				<x path="openfl.Vector"><c path="fromBoolVector.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromBoolVector>
		<fromIntVector params="T" get="inline" set="null" line="581" static="1">
			<f a="vector">
				<c path="openfl._Vector.IntVector"/>
				<x path="openfl.Vector"><c path="fromIntVector.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntVector>
		<fromFloatVector params="T" get="inline" set="null" line="586" static="1">
			<f a="vector">
				<c path="openfl._Vector.FloatVector"/>
				<x path="openfl.Vector"><c path="fromFloatVector.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloatVector>
		<fromFunctionVector params="T" get="inline" set="null" line="592" static="1">
			<f a="vector">
				<c path="openfl._Vector.FunctionVector"/>
				<x path="openfl.Vector"><c path="fromFunctionVector.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromFunctionVector>
		<fromObjectVector params="T" get="inline" set="null" line="598" static="1">
			<f a="vector">
				<c path="openfl._Vector.ObjectVector"><c path="fromObjectVector.T"/></c>
				<x path="openfl.Vector"><c path="fromObjectVector.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectVector>
		<get_fixed get="inline" set="null" line="605" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_fixed>
		<set_fixed get="inline" set="null" line="610" static="1">
			<f a="this:value">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_fixed>
		<get_length get="inline" set="null" line="615" static="1">
			<f a="this">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<set_length get="inline" set="null" line="620" static="1">
			<f a="this:value">
				<c path="openfl._Vector.IVector"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_length>
	</class>
	<class path="openfl._Vector.IVector" params="T" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector" interface="1">
		<get_length public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<set_length public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_length>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<concat public="1" set="method">
			<f a="?vec" v="null">
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c>
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c>
			</f>
			<meta><m n=":value"><e>{ vec : null }</e></m></meta>
		</concat>
		<copy public="1" set="method"><f a=""><c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c></f></copy>
		<filter public="1" set="method"><f a="callback">
	<f a="">
		<c path="openfl._Vector.IVector.T"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c>
</f></filter>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="openfl._Vector.IVector.T"/>
</f></get>
		<indexOf public="1" set="method">
			<f a="x:?from" v=":0">
				<c path="openfl._Vector.IVector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method"><f a="index:element">
	<x path="Int"/>
	<c path="openfl._Vector.IVector.T"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="openfl._Vector.IVector.T"/></t></f></iterator>
		<join public="1" set="method">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method">
			<f a="x:?from" v=":null">
				<c path="openfl._Vector.IVector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method"><f a=""><x path="Null"><c path="openfl._Vector.IVector.T"/></x></f></pop>
		<push public="1" set="method"><f a="value">
	<c path="openfl._Vector.IVector.T"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="openfl._Vector.IVector.T"/>
</f></removeAt>
		<reverse public="1" set="method"><f a=""><c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c></f></reverse>
		<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="openfl._Vector.IVector.T"/>
	<c path="openfl._Vector.IVector.T"/>
</f></set>
		<shift public="1" set="method"><f a=""><x path="Null"><c path="openfl._Vector.IVector.T"/></x></f></shift>
		<slice public="1" set="method">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="openfl._Vector.IVector.T"/>
		<c path="openfl._Vector.IVector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><c path="openfl._Vector.IVector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method"><f a="value">
	<c path="openfl._Vector.IVector.T"/>
	<x path="Void"/>
</f></unshift>
		<meta>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._Vector.BoolVector" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector">
		<implements path="openfl._Vector.IVector"><x path="Bool"/></implements>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<__array>
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<concat public="1" set="method" line="652">
			<f a="?a" v="null">
				<c path="openfl._Vector.IVector"><x path="Bool"/></c>
				<c path="openfl._Vector.IVector"><x path="Bool"/></c>
			</f>
			<meta><m n=":value"><e>{ a : null }</e></m></meta>
		</concat>
		<copy public="1" set="method" line="673"><f a=""><c path="openfl._Vector.IVector"><x path="Bool"/></c></f></copy>
		<filter public="1" set="method" line="678"><f a="callback">
	<f a="">
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><x path="Bool"/></c>
</f></filter>
		<get public="1" set="method" line="683"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></get>
		<indexOf public="1" set="method" line="695">
			<f a="x:?from" v=":0">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method" line="708"><f a="index:element">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method" line="716"><f a=""><t path="Iterator"><x path="Bool"/></t></f></iterator>
		<join public="1" set="method" line="721">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method" line="726">
			<f a="x:?from" v=":null">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method" line="739"><f a=""><x path="Null"><x path="Bool"/></x></f></pop>
		<push public="1" set="method" line="751"><f a="x">
	<x path="Bool"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method" line="763"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></removeAt>
		<reverse public="1" set="method" line="773"><f a=""><c path="openfl._Vector.IVector"><x path="Bool"/></c></f></reverse>
		<set public="1" set="method" line="779"><f a="index:value">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></set>
		<shift public="1" set="method" line="791"><f a=""><x path="Null"><x path="Bool"/></x></f></shift>
		<slice public="1" set="method" line="803">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><x path="Bool"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method" line="809"><f a="f">
	<f a=":">
		<x path="Bool"/>
		<x path="Bool"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method" line="814"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><x path="Bool"/></c>
</f></splice>
		<toJSON set="method" line="820">
			<f a=""><d/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</toJSON>
		<toString public="1" set="method" line="825"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method" line="830"><f a="x">
	<x path="Bool"/>
	<x path="Void"/>
</f></unshift>
		<get_length set="method" line="839">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="844">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<new public="1" set="method" line="639">
			<f a="?length:?fixed:?array" v="0:false:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ array : null, fixed : false, length : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._Vector.FloatVector" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector">
		<implements path="openfl._Vector.IVector"><x path="Float"/></implements>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<__array>
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<concat public="1" set="method" line="910">
			<f a="?a" v="null">
				<c path="openfl._Vector.IVector"><x path="Float"/></c>
				<c path="openfl._Vector.IVector"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ a : null }</e></m></meta>
		</concat>
		<copy public="1" set="method" line="931"><f a=""><c path="openfl._Vector.IVector"><x path="Float"/></c></f></copy>
		<filter public="1" set="method" line="936"><f a="callback">
	<f a="">
		<x path="Float"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><x path="Float"/></c>
</f></filter>
		<get public="1" set="method" line="941"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<indexOf public="1" set="method" line="946">
			<f a="x:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method" line="959"><f a="index:element">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method" line="967"><f a=""><t path="Iterator"><x path="Float"/></t></f></iterator>
		<join public="1" set="method" line="972">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method" line="977">
			<f a="x:?from" v=":null">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method" line="990"><f a=""><x path="Null"><x path="Float"/></x></f></pop>
		<push public="1" set="method" line="1002"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method" line="1014"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></removeAt>
		<reverse public="1" set="method" line="1024"><f a=""><c path="openfl._Vector.IVector"><x path="Float"/></c></f></reverse>
		<set public="1" set="method" line="1030"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<shift public="1" set="method" line="1042"><f a=""><x path="Null"><x path="Float"/></x></f></shift>
		<slice public="1" set="method" line="1054">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method" line="1060"><f a="f">
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method" line="1065"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><x path="Float"/></c>
</f></splice>
		<toJSON set="method" line="1071">
			<f a=""><d/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</toJSON>
		<toString public="1" set="method" line="1076"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method" line="1081"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></unshift>
		<get_length set="method" line="1090">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="1095">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<new public="1" set="method" line="888">
			<f a="?length:?fixed:?array:?forceCopy" v="0:false:null:false">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ forceCopy : false, array : null, fixed : false, length : 0 }</e></m>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._Vector.FunctionVector" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector">
		<implements path="openfl._Vector.IVector"><x path="haxe.Function"/></implements>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<__array>
			<c path="Array"><x path="haxe.Function"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<concat public="1" set="method" line="1159">
			<f a="?a" v="null">
				<c path="openfl._Vector.IVector"><x path="haxe.Function"/></c>
				<c path="openfl._Vector.IVector"><x path="haxe.Function"/></c>
			</f>
			<meta><m n=":value"><e>{ a : null }</e></m></meta>
		</concat>
		<copy public="1" set="method" line="1180"><f a=""><c path="openfl._Vector.IVector"><x path="haxe.Function"/></c></f></copy>
		<filter public="1" set="method" line="1185"><f a="callback">
	<f a="">
		<x path="haxe.Function"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><x path="haxe.Function"/></c>
</f></filter>
		<get public="1" set="method" line="1190"><f a="index">
	<x path="Int"/>
	<x path="haxe.Function"/>
</f></get>
		<indexOf public="1" set="method" line="1202">
			<f a="x:?from" v=":0">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method" line="1215"><f a="index:element">
	<x path="Int"/>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method" line="1223"><f a=""><t path="Iterator"><x path="haxe.Function"/></t></f></iterator>
		<join public="1" set="method" line="1228">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method" line="1233">
			<f a="x:?from" v=":null">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method" line="1246"><f a=""><x path="haxe.Function"/></f></pop>
		<push public="1" set="method" line="1258"><f a="x">
	<x path="haxe.Function"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method" line="1270"><f a="index">
	<x path="Int"/>
	<x path="haxe.Function"/>
</f></removeAt>
		<reverse public="1" set="method" line="1280"><f a=""><c path="openfl._Vector.IVector"><x path="haxe.Function"/></c></f></reverse>
		<set public="1" set="method" line="1286"><f a="index:value">
	<x path="Int"/>
	<x path="haxe.Function"/>
	<x path="haxe.Function"/>
</f></set>
		<shift public="1" set="method" line="1298"><f a=""><x path="haxe.Function"/></f></shift>
		<slice public="1" set="method" line="1310">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><x path="haxe.Function"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method" line="1316"><f a="f">
	<f a=":">
		<x path="haxe.Function"/>
		<x path="haxe.Function"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method" line="1321"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><x path="haxe.Function"/></c>
</f></splice>
		<toJSON set="method" line="1327">
			<f a=""><d/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</toJSON>
		<toString public="1" set="method" line="1332"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method" line="1337"><f a="x">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></unshift>
		<get_length set="method" line="1346">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="1351">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<new public="1" set="method" line="1146">
			<f a="?length:?fixed:?array" v="0:false:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="haxe.Function"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ array : null, fixed : false, length : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._Vector.IntVector" params="" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector">
		<implements path="openfl._Vector.IVector"><x path="Int"/></implements>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<__array>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<concat public="1" set="method" line="1408">
			<f a="?a" v="null">
				<c path="openfl._Vector.IVector"><x path="Int"/></c>
				<c path="openfl._Vector.IVector"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ a : null }</e></m></meta>
		</concat>
		<copy public="1" set="method" line="1429"><f a=""><c path="openfl._Vector.IVector"><x path="Int"/></c></f></copy>
		<filter public="1" set="method" line="1434"><f a="callback">
	<f a="">
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><x path="Int"/></c>
</f></filter>
		<get public="1" set="method" line="1439"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<indexOf public="1" set="method" line="1444">
			<f a="x:?from" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method" line="1457"><f a="index:element">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method" line="1465"><f a=""><t path="Iterator"><x path="Int"/></t></f></iterator>
		<join public="1" set="method" line="1470">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method" line="1475">
			<f a="x:?from" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method" line="1488"><f a=""><x path="Null"><x path="Int"/></x></f></pop>
		<push public="1" set="method" line="1500"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method" line="1512"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></removeAt>
		<reverse public="1" set="method" line="1522"><f a=""><c path="openfl._Vector.IVector"><x path="Int"/></c></f></reverse>
		<set public="1" set="method" line="1528"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set>
		<shift public="1" set="method" line="1540"><f a=""><x path="Null"><x path="Int"/></x></f></shift>
		<slice public="1" set="method" line="1552">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method" line="1558"><f a="f">
	<f a=":">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method" line="1563"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><x path="Int"/></c>
</f></splice>
		<toJSON set="method" line="1569">
			<f a=""><d/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</toJSON>
		<toString public="1" set="method" line="1574"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method" line="1579"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></unshift>
		<get_length set="method" line="1588">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="1593">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<new public="1" set="method" line="1395">
			<f a="?length:?fixed:?array" v="0:false:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ array : null, fixed : false, length : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._Vector.ObjectVector" params="T" file="/projects/May2019/May2020/openfl/src/openfl/Vector.hx" private="1" module="openfl.Vector">
		<implements path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></implements>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<__array>
			<c path="Array"><c path="openfl._Vector.ObjectVector.T"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<concat public="1" set="method" line="1660">
			<f a="?a" v="null">
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c>
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ a : null }</e></m>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
			</meta>
		</concat>
		<copy public="1" set="method" line="1681"><f a=""><c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c></f></copy>
		<filter public="1" set="method" line="1686"><f a="callback">
	<f a="">
		<c path="openfl._Vector.ObjectVector.T"/>
		<x path="Bool"/>
	</f>
	<c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c>
</f></filter>
		<get public="1" set="method" line="1691"><f a="index">
	<x path="Int"/>
	<c path="openfl._Vector.ObjectVector.T"/>
</f></get>
		<indexOf public="1" set="method" line="1696">
			<f a="x:?from" v=":0">
				<c path="openfl._Vector.ObjectVector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</indexOf>
		<insertAt public="1" set="method" line="1709"><f a="index:element">
	<x path="Int"/>
	<c path="openfl._Vector.ObjectVector.T"/>
	<x path="Void"/>
</f></insertAt>
		<iterator public="1" set="method" line="1717"><f a=""><t path="Iterator"><c path="openfl._Vector.ObjectVector.T"/></t></f></iterator>
		<join public="1" set="method" line="1722">
			<f a="?sep" v="&quot;,&quot;">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ sep : "," }</e></m></meta>
		</join>
		<lastIndexOf public="1" set="method" line="1727">
			<f a="x:?from" v=":null">
				<c path="openfl._Vector.ObjectVector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : null }</e></m></meta>
		</lastIndexOf>
		<pop public="1" set="method" line="1740"><f a=""><c path="openfl._Vector.ObjectVector.T"/></f></pop>
		<push public="1" set="method" line="1752"><f a="x">
	<c path="openfl._Vector.ObjectVector.T"/>
	<x path="Int"/>
</f></push>
		<removeAt public="1" set="method" line="1764"><f a="index">
	<x path="Int"/>
	<c path="openfl._Vector.ObjectVector.T"/>
</f></removeAt>
		<reverse public="1" set="method" line="1774"><f a=""><c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c></f></reverse>
		<set public="1" set="method" line="1780"><f a="index:value">
	<x path="Int"/>
	<c path="openfl._Vector.ObjectVector.T"/>
	<c path="openfl._Vector.ObjectVector.T"/>
</f></set>
		<shift public="1" set="method" line="1792"><f a=""><c path="openfl._Vector.ObjectVector.T"/></f></shift>
		<slice public="1" set="method" line="1804">
			<f a="?startIndex:?endIndex" v="0:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : null, startIndex : 0 }</e></m></meta>
		</slice>
		<sort public="1" set="method" line="1810"><f a="f">
	<f a=":">
		<c path="openfl._Vector.ObjectVector.T"/>
		<c path="openfl._Vector.ObjectVector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method" line="1815"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl._Vector.IVector"><c path="openfl._Vector.ObjectVector.T"/></c>
</f></splice>
		<toJSON set="method" line="1821">
			<f a=""><d/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</toJSON>
		<toString public="1" set="method" line="1826"><f a=""><c path="String"/></f></toString>
		<unshift public="1" set="method" line="1831"><f a="x">
	<c path="openfl._Vector.ObjectVector.T"/>
	<x path="Void"/>
</f></unshift>
		<get_length set="method" line="1840">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="1845">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<new public="1" set="method" line="1637">
			<f a="?length:?fixed:?array:?forceCopy" v="0:false:null:false">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ forceCopy : false, array : null, fixed : false, length : 0 }</e></m>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n="SuppressWarnings"><e>"checkstyle:FieldDocComment"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="org.poly2tri.AdvancingFront" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/AdvancingFront.hx">
		<head public="1"><c path="org.poly2tri.Node"/></head>
		<tail public="1"><c path="org.poly2tri.Node"/></tail>
		<search_node public="1"><c path="org.poly2tri.Node"/></search_node>
		<locateNode public="1" set="method" line="15"><f a="x">
	<x path="Float"/>
	<c path="org.poly2tri.Node"/>
</f></locateNode>
		<locatePoint public="1" set="method" line="45"><f a="point">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Node"/>
</f></locatePoint>
		<new public="1" set="method" line="9"><f a="head:tail">
	<c path="org.poly2tri.Node"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Basin" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Basin.hx">
		<left_node public="1"><c path="org.poly2tri.Node"/></left_node>
		<bottom_node public="1"><c path="org.poly2tri.Node"/></bottom_node>
		<right_node public="1"><c path="org.poly2tri.Node"/></right_node>
		<width public="1"><x path="Float"/></width>
		<left_highest public="1"><x path="Bool"/></left_highest>
		<clear public="1" set="method" line="17"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Constants" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Constants.hx">
		<kAlpha public="1" expr="0.3" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.3</e></m></meta>
		</kAlpha>
		<EPSILON public="1" expr="1e-12" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-12</e></m></meta>
		</EPSILON>
		<PI_2 public="1" expr="Math.PI / 2" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.PI / 2</e></m></meta>
		</PI_2>
		<PI_3div4 public="1" expr="3 * Math.PI / 4" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3 * Math.PI / 4</e></m></meta>
		</PI_3div4>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Edge" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Edge.hx">
		<p public="1"><c path="org.poly2tri.Point"/></p>
		<q public="1"><c path="org.poly2tri.Point"/></q>
		<toString public="1" set="method" line="42"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="p1:p2">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.EdgeEvent" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/EdgeEvent.hx">
		<constrained_edge public="1"><c path="org.poly2tri.Edge"/></constrained_edge>
		<right public="1"><x path="Bool"/></right>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Node" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Node.hx">
		<point public="1"><c path="org.poly2tri.Point"/></point>
		<triangle public="1"><c path="org.poly2tri.Triangle"/></triangle>
		<prev public="1"><c path="org.poly2tri.Node"/></prev>
		<next public="1"><c path="org.poly2tri.Node"/></next>
		<value public="1"><x path="Float"/></value>
		<getHoleAngle public="1" set="method" line="26">
			<f a=""><x path="Float"/></f>
			<haxe_doc>*
	 * @param node - middle node
	 * @return the angle between 3 front nodes</haxe_doc>
		</getHoleAngle>
		<getBasinAngle public="1" set="method" line="46"><f a=""><x path="Float"/></f></getBasinAngle>
		<new public="1" set="method" line="13">
			<f a="?point:?triangle" v="null:null">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Triangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null, point : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Orientation" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Orientation.hx">
		<CW public="1" get="inline" set="null" expr="1" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="-1" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW>
		<COLLINEAR public="1" get="inline" set="null" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</COLLINEAR>
		<orient2d public="1" set="method" line="9" static="1"><f a="pa:pb:pc">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Int"/>
</f></orient2d>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Point" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Point.hx">
		<sortPoints public="1" set="method" line="41" static="1"><f a="points">
	<c path="Array"><c path="org.poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" set="method" line="46" static="1"><f a="l:r">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="org.poly2tri.Edge"/></c></edge_list>
		<get_edge_list set="method" line="28"><f a=""><c path="Array"><c path="org.poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" set="method" line="36"><f a="that">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="55"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="17"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Sweep" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Sweep.hx">
		<nextFlipPoint public="1" set="method" line="598" static="1"><f a="ep:eq:ot:op">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
</f></nextFlipPoint>
		<context><c path="org.poly2tri.SweepContext"/></context>
		<triangulate public="1" set="method" line="12"><f a=""><x path="Void"/></f></triangulate>
		<sweepPoints public="1" set="method" line="20"><f a=""><x path="Void"/></f></sweepPoints>
		<finalizationPolygon public="1" set="method" line="35"><f a=""><x path="Void"/></f></finalizationPolygon>
		<pointEvent public="1" set="method" line="51">
			<f a="point">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Node"/>
			</f>
			<haxe_doc>* Find closes node to the left of the new point and
	 * create a new triangle. If needed new holes and basins
	 * will be filled to.</haxe_doc>
		</pointEvent>
		<edgeEventByEdge public="1" set="method" line="66"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></edgeEventByEdge>
		<edgeEventByPoints public="1" set="method" line="81"><f a="ep:eq:triangle:point">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<x path="Void"/>
</f></edgeEventByPoints>
		<newFrontTriangle public="1" set="method" line="112"><f a="point:node">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Node"/>
	<c path="org.poly2tri.Node"/>
</f></newFrontTriangle>
		<fill public="1" set="method" line="139">
			<f a="node">
				<c path="org.poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a triangle to the advancing front to fill a hole.
	 * @param tcx
	 * @param node - middle node, that is the bottom of the hole</haxe_doc>
		</fill>
		<fillAdvancingFront public="1" set="method" line="166">
			<f a="n">
				<c path="org.poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fills holes in the Advancing Front</haxe_doc>
		</fillAdvancingFront>
		<legalize public="1" set="method" line="203">
			<f a="t">
				<c path="org.poly2tri.Triangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if triangle was legalized</haxe_doc>
		</legalize>
		<fillBasin public="1" set="method" line="273">
			<f a="node">
				<c path="org.poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills a basin that has formed on the Advancing Front to the right
	 * of given node.<br>
	 * First we decide a left,bottom and right node that forms the
	 * boundaries of the basin. Then we do a reqursive fill.
	 *
	 * @param tcx
	 * @param node - starting node, this or next node will be left node]]></haxe_doc>
		</fillBasin>
		<fillBasinReq public="1" set="method" line="311">
			<f a="node">
				<c path="org.poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recursive algorithm to fill a Basin with triangles
	 *
	 * @param tcx
	 * @param node - bottom_node</haxe_doc>
		</fillBasinReq>
		<isShallow public="1" set="method" line="345"><f a="node">
	<c path="org.poly2tri.Node"/>
	<x path="Bool"/>
</f></isShallow>
		<fillEdgeEvent public="1" set="method" line="356"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillEdgeEvent>
		<fillRightAboveEdgeEvent public="1" set="method" line="368"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightAboveEdgeEvent>
		<fillRightBelowEdgeEvent public="1" set="method" line="384"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightBelowEdgeEvent>
		<fillRightConcaveEdgeEvent public="1" set="method" line="399"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConcaveEdgeEvent>
		<fillRightConvexEdgeEvent public="1" set="method" line="421"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConvexEdgeEvent>
		<fillLeftAboveEdgeEvent public="1" set="method" line="445"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftAboveEdgeEvent>
		<fillLeftBelowEdgeEvent public="1" set="method" line="461"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftBelowEdgeEvent>
		<fillLeftConvexEdgeEvent public="1" set="method" line="480"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConvexEdgeEvent>
		<fillLeftConcaveEdgeEvent public="1" set="method" line="504"><f a="edge:node">
	<c path="org.poly2tri.Edge"/>
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConcaveEdgeEvent>
		<flipEdgeEvent public="1" set="method" line="528"><f a="ep:eq:t:p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<x path="Void"/>
</f></flipEdgeEvent>
		<nextFlipTriangle public="1" set="method" line="577"><f a="o:t:ot:p:op">
	<x path="Int"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
</f></nextFlipTriangle>
		<flipScanEdgeEvent public="1" set="method" line="617"><f a="ep:eq:flip_triangle:t:p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<x path="Void"/>
</f></flipScanEdgeEvent>
		<new public="1" set="method" line="7"><f a="context">
	<c path="org.poly2tri.SweepContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.SweepContext" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/SweepContext.hx">
		<triangles public="1"><c path="Array"><c path="org.poly2tri.Triangle"/></c></triangles>
		<points public="1"><c path="Array"><c path="org.poly2tri.Point"/></c></points>
		<edge_list public="1"><c path="Array"><c path="org.poly2tri.Edge"/></c></edge_list>
		<map public="1"><t path="Map">
	<c path="String"/>
	<c path="org.poly2tri.Triangle"/>
</t></map>
		<front public="1"><c path="org.poly2tri.AdvancingFront"/></front>
		<head public="1"><c path="org.poly2tri.Point"/></head>
		<tail public="1"><c path="org.poly2tri.Point"/></tail>
		<basin public="1"><c path="org.poly2tri.Basin"/></basin>
		<edge_event public="1"><c path="org.poly2tri.EdgeEvent"/></edge_event>
		<addPoints set="method" line="42"><f a="points">
	<c path="Array"><c path="org.poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPoints>
		<addPolyline public="1" set="method" line="53"><f a="polyline">
	<c path="Array"><c path="org.poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPolyline>
		<initEdges set="method" line="62"><f a="polyline">
	<c path="Array"><c path="org.poly2tri.Point"/></c>
	<x path="Void"/>
</f></initEdges>
		<addToMap public="1" set="method" line="75"><f a="triangle">
	<c path="org.poly2tri.Triangle"/>
	<x path="Void"/>
</f></addToMap>
		<initTriangulation public="1" set="method" line="81"><f a=""><x path="Void"/></f></initTriangulation>
		<locateNode public="1" set="method" line="110"><f a="point">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Node"/>
</f></locateNode>
		<createAdvancingFront public="1" set="method" line="115"><f a=""><x path="Void"/></f></createAdvancingFront>
		<removeNode public="1" set="method" line="135"><f a="node">
	<c path="org.poly2tri.Node"/>
	<x path="Void"/>
</f></removeNode>
		<mapTriangleToNodes public="1" set="method" line="140"><f a="triangle">
	<c path="org.poly2tri.Triangle"/>
	<x path="Void"/>
</f></mapTriangleToNodes>
		<meshClean public="1" set="method" line="152"><f a="t">
	<c path="org.poly2tri.Triangle"/>
	<x path="Void"/>
</f></meshClean>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Triangle" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Triangle.hx">
		<CW_OFFSET get="inline" set="null" expr="1" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Return the point clockwise to the given point.
	 * Return the point counter-clockwise to the given point.
	 *
	 * Return the neighbor clockwise to given point.
	 * Return the neighbor counter-clockwise to given point.</haxe_doc>
		</CW_OFFSET>
		<CCW_OFFSET get="inline" set="null" expr="-1" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW_OFFSET>
		<rotateTrianglePair public="1" set="method" line="331" static="1">
			<f a="t:p:ot:op">
				<c path="org.poly2tri.Triangle"/>
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Triangle"/>
				<c path="org.poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Rotates a triangle pair one vertex CW
	 *<pre>
	 *       n2                    n2
	 *  P +-----+             P +-----+
	 *    | t  /|               |\  t |
	 *    |   / |               | \   |
	 *  n1|  /  |n3           n1|  \  |n3
	 *    | /   |    after CW   |   \ |
	 *    |/ oT |               | oT \|
	 *    +-----+ oP            +-----+
	 *       n4                    n4
	 * </pre>]]></haxe_doc>
		</rotateTrianglePair>
		<points public="1"><c path="Array"><c path="org.poly2tri.Point"/></c></points>
		<neighbors public="1"><c path="Array"><c path="org.poly2tri.Triangle"/></c></neighbors>
		<interior public="1"><x path="Bool"/></interior>
		<constrained_edge public="1"><c path="Array"><x path="Bool"/></c></constrained_edge>
		<delaunay_edge public="1"><c path="Array"><x path="Bool"/></c></delaunay_edge>
		<containsPoint public="1" set="method" line="52">
			<f a="point">
				<c path="org.poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Test if this Triangle contains the Point object given as parameter as its vertices.
	 *
	 * @return <code>True</code> if the Point objects are of the Triangle's vertices,
	 *         <code>false</code> otherwise.]]></haxe_doc>
		</containsPoint>
		<containsEdgePoints public="1" set="method" line="57"><f a="p1:p2">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></containsEdgePoints>
		<markNeighbor public="1" set="method" line="72">
			<f a="t:p1:p2">
				<c path="org.poly2tri.Triangle"/>
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Update neighbor pointers.<br>
	 * This method takes either 3 parameters (<code>p1</code>, <code>p2</code> and
	 * <code>t</code>) or 1 parameter (<code>t</code>).
	 * @param   t   Triangle object.
	 * @param   p1  Point object.
	 * @param   p2  Point object.]]></haxe_doc>
		</markNeighbor>
		<markNeighborTriangle public="1" set="method" line="90"><f a="that">
	<c path="org.poly2tri.Triangle"/>
	<x path="Void"/>
</f></markNeighborTriangle>
		<getPointIndexOffset public="1" set="method" line="116">
			<f a="p:?offset" v=":0">
				<c path="org.poly2tri.Point"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</getPointIndexOffset>
		<pointCW public="1" set="method" line="150"><f a="p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
</f></pointCW>
		<pointCCW public="1" set="method" line="155"><f a="p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
</f></pointCCW>
		<neighborCW public="1" set="method" line="160"><f a="p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
</f></neighborCW>
		<neighborCCW public="1" set="method" line="165"><f a="p">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Triangle"/>
</f></neighborCCW>
		<getConstrainedEdgeCW public="1" set="method" line="170"><f a="p">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCW>
		<setConstrainedEdgeCW public="1" set="method" line="171"><f a="p:ce">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCW>
		<getConstrainedEdgeCCW public="1" set="method" line="173"><f a="p">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCCW>
		<setConstrainedEdgeCCW public="1" set="method" line="174"><f a="p:ce">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCCW>
		<getDelaunayEdgeCW public="1" set="method" line="176"><f a="p">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCW>
		<setDelaunayEdgeCW public="1" set="method" line="177"><f a="p:e">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCW>
		<getDelaunayEdgeCCW public="1" set="method" line="179"><f a="p">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCCW>
		<setDelaunayEdgeCCW public="1" set="method" line="180"><f a="p:e">
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCCW>
		<neighborAcross public="1" set="method" line="186">
			<f a="p">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Triangle"/>
			</f>
			<haxe_doc>* The neighbor across to given point.</haxe_doc>
		</neighborAcross>
		<oppositePoint public="1" set="method" line="188"><f a="t:p">
	<c path="org.poly2tri.Triangle"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
</f></oppositePoint>
		<legalize public="1" set="method" line="199">
			<f a="opoint:?npoint" v=":null">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ npoint : null }</e></m></meta>
			<haxe_doc><![CDATA[* Legalize triangle by rotating clockwise.<br>
	 * This method takes either 1 parameter (then the triangle is rotated around
	 * points(0)) or 2 parameters (then the triangle is rotated around the first
	 * parameter).]]></haxe_doc>
		</legalize>
		<index public="1" set="method" line="230">
			<f a="p">
				<c path="org.poly2tri.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Alias for getPointIndexOffset
	 *
	 * @param	p</haxe_doc>
		</index>
		<edgeIndex public="1" set="method" line="241"><f a="p1:p2">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Int"/>
</f></edgeIndex>
		<markConstrainedEdgeByIndex public="1" set="method" line="267">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Mark an edge of this triangle as constrained.<br>
	 * This method takes either 1 parameter (an edge index or an Edge instance) or
	 * 2 parameters (two Point instances defining the edge of the triangle).]]></haxe_doc>
		</markConstrainedEdgeByIndex>
		<markConstrainedEdgeByEdge public="1" set="method" line="272"><f a="edge">
	<c path="org.poly2tri.Edge"/>
	<x path="Void"/>
</f></markConstrainedEdgeByEdge>
		<markConstrainedEdgeByPoints public="1" set="method" line="277"><f a="p:q">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Void"/>
</f></markConstrainedEdgeByPoints>
		<isEdgeSide public="1" set="method" line="305">
			<f a="ep:eq">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a side from this triangle is an edge side.
	 * If sides are not marked they will be marked.
	 *
	 * @param	ep
	 * @param	eq
	 * @return</haxe_doc>
		</isEdgeSide>
		<clearNeigbors public="1" set="method" line="377"><f a=""><x path="Void"/></f></clearNeigbors>
		<clearDelunayEdges public="1" set="method" line="384"><f a=""><x path="Void"/></f></clearDelunayEdges>
		<toString public="1" set="method" line="392"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="21">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.Utils" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/Utils.hx">
		<insideIncircle public="1" set="method" line="29" static="1">
			<f a="pa:pb:pc:pd">
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<c path="org.poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* <b>Requirement</b>:<br>
	 * 1. a, b and c form a triangle.<br>
	 * 2. a and d is know to be on opposite side of bc<br>
	 * <pre>
	 *                a
	 *                +
	 *               / \
	 *              /   \
	 *            b/     \c
	 *            +-------+
	 *           /    d    \
	 *          /           \
	 * </pre>
	 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
	 *  a,b and c<br>
	 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
	 *  This preknowledge gives us a way to optimize the incircle test
	 * @param pa - triangle point, opposite d
	 * @param pb - triangle point
	 * @param pc - triangle point
	 * @param pd - point opposite a
	 * @return true if d is inside circle, false if on circle edge]]></haxe_doc>
		</insideIncircle>
		<inScanArea public="1" set="method" line="62" static="1"><f a="pa:pb:pc:pd">
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<c path="org.poly2tri.Point"/>
	<x path="Bool"/>
</f></inScanArea>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.poly2tri.VisiblePolygon" params="" file="/usr/local/lib/haxeLibrary/poly2trihx/0,1,4/org/poly2tri/VisiblePolygon.hx">
		<sweepContext><c path="org.poly2tri.SweepContext"/></sweepContext>
		<sweep><c path="org.poly2tri.Sweep"/></sweep>
		<triangulated><x path="Bool"/></triangulated>
		<addPolyline public="1" set="method" line="17"><f a="polyline">
	<c path="Array"><c path="org.poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPolyline>
		<addPolylineFromFloats public="1" set="method" line="22"><f a="pos">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></addPolylineFromFloats>
		<reset public="1" set="method" line="33"><f a=""><x path="Void"/></f></reset>
		<performTriangulationOnce public="1" set="method" line="40"><f a=""><x path="Void"/></f></performTriangulationOnce>
		<getVerticesAndTriangles public="1" set="method" line="48"><f a=""><a>
	<vertices><c path="Array"><x path="Float"/></c></vertices>
	<triangles><c path="Array"><x path="Int"/></c></triangles>
</a></f></getVerticesAndTriangles>
		<getNumTriangles public="1" set="method" line="77"><f a=""><x path="Int"/></f></getNumTriangles>
		<drawShape public="1" set="method" line="84"><f a="g">
	<t path="flash.display.Graphics"/>
	<x path="Void"/>
</f></drawShape>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pallette.utils.ARGB" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ARGB.hx">
		<a public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</a>
		<r public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</r>
		<g public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</g>
		<b public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</b>
		<new public="1" set="method" line="11"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ a, r, g, b }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pallette.utils.CYMK" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/CYMK.hx">
		<c public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</c>
		<y public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<m public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</m>
		<k public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</k>
		<new public="1" set="method" line="11"><f a="c:y:m:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ c, y, m, k }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pallette.utils.CYMKA" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/CYMKA.hx">
		<c public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</c>
		<y public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<m public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</m>
		<k public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</k>
		<a public="1" expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":optional"/>
			</meta>
		</a>
		<new public="1" set="method" line="12"><f a="c:y:m:k:?a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ c, y, m, k, ?a }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pallette.utils.ColorHelper" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ColorHelper.hx">
		<htmlRGBA_ public="1" expr="htmlRGBA">
			<f a="r_:g_:b_:a_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>htmlRGBA</e></m></meta>
		</htmlRGBA_>
		<htmlHex_ public="1" expr="htmlHex">
			<f a="r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>htmlHex</e></m></meta>
		</htmlHex_>
		<getBlack_ public="1" expr="getBlack">
			<f a="r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>getBlack</e></m></meta>
		</getBlack_>
		<from_cymka_ public="1" expr="from_cymka">
			<f a="c:y:m:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>from_cymka</e></m></meta>
		</from_cymka_>
		<from_argb_ public="1" expr="from_argb">
			<f a="a:r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>from_argb</e></m></meta>
		</from_argb_>
		<toHexInt_ public="1" expr="toHexInt">
			<f a="c">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>toHexInt</e></m></meta>
		</toHexInt_>
		<rgbConvert_ public="1" expr="rgbConvert">
			<f a="color:k">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>rgbConvert</e></m></meta>
		</rgbConvert_>
		<cymkConvert_ public="1" expr="cymkConvert">
			<f a="color:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>cymkConvert</e></m></meta>
		</cymkConvert_>
		<alphaChannel_ public="1" expr="alphaChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>alphaChannel</e></m></meta>
		</alphaChannel_>
		<redChannel_ public="1" expr="redChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>redChannel</e></m></meta>
		</redChannel_>
		<greenChannel_ public="1" expr="greenChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>greenChannel</e></m></meta>
		</greenChannel_>
		<blueChannel_ public="1" expr="blueChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>blueChannel</e></m></meta>
		</blueChannel_>
		<get_percentHex_ public="1" expr="get_percentHex">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<meta><m n=":value"><e>get_percentHex</e></m></meta>
		</get_percentHex_>
		<percentWhite_ public="1" expr="percentWhite">
			<f a="percent">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentWhite</e></m></meta>
		</percentWhite_>
		<percentBlack_ public="1" expr="percentBlack">
			<f a="percent">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentBlack</e></m></meta>
		</percentBlack_>
		<rgbPercent_ public="1" expr="rgbPercent">
			<f a="rPercent:gPercent:bPercent">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>rgbPercent</e></m></meta>
		</rgbPercent_>
		<percentColor_ public="1" expr="percentColor">
			<f a="rPercent:gPercent:bPercent">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentColor</e></m></meta>
		</percentColor_>
		<percentDarkColor_ public="1" expr="percentDarkColor">
			<f a="rPercent:gPercent:bPercent">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentDarkColor</e></m></meta>
		</percentDarkColor_>
		<percentRed_ public="1" expr="percentRed">
			<f a="rPercent">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentRed</e></m></meta>
		</percentRed_>
		<percentGreen_ public="1" expr="percentGreen">
			<f a="gPercent">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentGreen</e></m></meta>
		</percentGreen_>
		<percentBlue_ public="1" expr="percentBlue">
			<f a="bPercent">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentBlue</e></m></meta>
		</percentBlue_>
		<percentRedSoft_ public="1" expr="percentRedSoft">
			<f a="rPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentRedSoft</e></m></meta>
		</percentRedSoft_>
		<percentGreenSoft_ public="1" expr="percentGreenSoft">
			<f a="gPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentGreenSoft</e></m></meta>
		</percentGreenSoft_>
		<percentBlueSoft_ public="1" expr="percentBlueSoft">
			<f a="bPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentBlueSoft</e></m></meta>
		</percentBlueSoft_>
		<percentYellowSoft_ public="1" expr="percentYellowSoft">
			<f a="bPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentYellowSoft</e></m></meta>
		</percentYellowSoft_>
		<percentMagentaSoft_ public="1" expr="percentMagentaSoft">
			<f a="bPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentMagentaSoft</e></m></meta>
		</percentMagentaSoft_>
		<percentCyanSoft_ public="1" expr="percentCyanSoft">
			<f a="bPercent:percentSoft">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>percentCyanSoft</e></m></meta>
		</percentCyanSoft_>
		<new public="1" set="method" line="146">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pallette.utils._ColorHelper.ColorHelper_Fields_" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ColorHelper.hx" private="1" module="pallette.utils.ColorHelper" final="1">
		<htmlRGBA public="1" get="inline" set="null" line="3" static="1"><f a="r_:g_:b_:a_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
</f></htmlRGBA>
		<htmlHex public="1" get="inline" set="null" line="11" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
</f></htmlHex>
		<getBlack public="1" get="inline" set="null" line="14" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getBlack>
		<from_cymka public="1" get="inline" set="null" line="18" static="1"><f a="c:y:m:k:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_cymka>
		<from_cymk public="1" get="inline" set="null" line="24" static="1"><f a="c:y:m:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_cymk>
		<from_argb public="1" get="inline" set="null" line="29" static="1"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_argb>
		<from_rgb public="1" get="inline" set="null" line="35" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_rgb>
		<toHexInt public="1" get="inline" set="null" line="40" static="1"><f a="c">
	<x path="Float"/>
	<x path="Int"/>
</f></toHexInt>
		<rgbConvert public="1" get="inline" set="null" line="43" static="1"><f a="color:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rgbConvert>
		<cymkConvert public="1" get="inline" set="null" line="46" static="1"><f a="color:black">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></cymkConvert>
		<alphaChannel public="1" get="inline" set="null" line="49" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="52" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="55" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="58" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<argbInt public="1" get="inline" set="null" line="61" static="1"><f a="a:r:g:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></argbInt>
		<percentHex public="1" get="accessor" set="null" static="1"><c path="Array"><x path="Int"/></c></percentHex>
		<get_percentHex public="1" get="inline" set="null" line="66" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></get_percentHex>
		<percentWhite public="1" get="inline" set="null" line="80" static="1"><f a="percent">
	<x path="Int"/>
	<x path="Int"/>
</f></percentWhite>
		<percentBlack public="1" get="inline" set="null" line="85" static="1"><f a="percent">
	<x path="Int"/>
	<x path="Int"/>
</f></percentBlack>
		<rgbPercent public="1" get="inline" set="null" line="90" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rgbPercent>
		<percentColor public="1" get="inline" set="null" line="94" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentColor>
		<percentDarkColor public="1" get="inline" set="null" line="98" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentDarkColor>
		<percentRed public="1" get="inline" set="null" line="102" static="1"><f a="rPercent">
	<x path="Int"/>
	<x path="Int"/>
</f></percentRed>
		<percentGreen public="1" get="inline" set="null" line="106" static="1"><f a="gPercent">
	<x path="Int"/>
	<x path="Int"/>
</f></percentGreen>
		<percentBlue public="1" get="inline" set="null" line="110" static="1"><f a="bPercent">
	<x path="Int"/>
	<x path="Int"/>
</f></percentBlue>
		<percentRedSoft public="1" get="inline" set="null" line="114" static="1"><f a="rPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentRedSoft>
		<percentGreenSoft public="1" get="inline" set="null" line="119" static="1"><f a="gPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentGreenSoft>
		<percentBlueSoft public="1" get="inline" set="null" line="124" static="1"><f a="bPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentBlueSoft>
		<percentYellowSoft public="1" get="inline" set="null" line="129" static="1"><f a="bPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentYellowSoft>
		<percentMagentaSoft public="1" get="inline" set="null" line="135" static="1"><f a="bPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentMagentaSoft>
		<percentCyanSoft public="1" get="inline" set="null" line="141" static="1"><f a="bPercent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></percentCyanSoft>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="pallette.utils.ColorInt" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ColorInt.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast field="fromARGB"><c path="pallette.utils.ARGB"/></icast>
			<icast field="fromRGB"><c path="pallette.utils.RGB"/></icast>
			<icast field="fromCYMKA"><c path="pallette.utils.CYMKA"/></icast>
			<icast field="fromCYMK"><c path="pallette.utils.CYMK"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="htmlStyleRGBA"><c path="String"/></icast>
			<icast field="htmlStyleHex"><c path="String"/></icast>
			<icast field="toARGB"><c path="pallette.utils.ARGB"/></icast>
			<icast field="toRGB"><c path="pallette.utils.RGB"/></icast>
			<icast field="toCYMKA"><c path="pallette.utils.CYMKA"/></icast>
			<icast field="toCYMK"><c path="pallette.utils.CYMK"/></icast>
		</to>
		<impl><class path="pallette.utils._ColorInt.ColorInt_Impl_" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ColorInt.hx" private="1" module="pallette.utils.ColorInt" final="1">
	<_new public="1" get="inline" set="null" line="10" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromARGB public="1" get="inline" set="null" line="15" static="1">
		<f a="argb">
			<c path="pallette.utils.ARGB"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromARGB>
	<fromRGB public="1" get="inline" set="null" line="20" static="1">
		<f a="argb">
			<c path="pallette.utils.RGB"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromRGB>
	<htmlStyleRGBA public="1" get="inline" set="null" line="25" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</htmlStyleRGBA>
	<htmlStyleHex public="1" get="inline" set="null" line="30" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</htmlStyleHex>
	<toARGB public="1" get="inline" set="null" line="35" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="pallette.utils.ARGB"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toARGB>
	<toRGB public="1" get="inline" set="null" line="40" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="pallette.utils.RGB"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toRGB>
	<fromCYMKA public="1" get="inline" set="null" line="45" static="1">
		<f a="c">
			<c path="pallette.utils.CYMKA"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromCYMKA>
	<fromCYMK public="1" get="inline" set="null" line="50" static="1">
		<f a="c">
			<c path="pallette.utils.CYMK"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromCYMK>
	<toCYMKA public="1" get="inline" set="null" line="55" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="pallette.utils.CYMKA"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toCYMKA>
	<toCYMK public="1" get="inline" set="null" line="64" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="pallette.utils.CYMK"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toCYMK>
	<cyan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cyan>
	<get_cyan get="inline" set="null" line="73" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cyan>
	<set_cyan get="inline" set="null" line="77" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cyan>
	<yellow public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</yellow>
	<get_yellow get="inline" set="null" line="86" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_yellow>
	<set_yellow get="inline" set="null" line="90" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_yellow>
	<magenta public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</magenta>
	<get_magenta get="inline" set="null" line="99" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_magenta>
	<set_magenta get="inline" set="null" line="103" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_magenta>
	<black public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</black>
	<get_black get="inline" set="null" line="112" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_black>
	<set_black get="inline" set="null" line="115" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_black>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<get_alpha get="inline" set="null" line="124" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<set_alpha get="inline" set="null" line="128" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</red>
	<get_red get="inline" set="null" line="134" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<set_red get="inline" set="null" line="138" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</green>
	<get_green get="inline" set="null" line="144" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<set_green get="inline" set="null" line="148" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<get_blue get="inline" set="null" line="154" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<set_blue get="inline" set="null" line="158" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<aiCYMKA public="1" get="inline" set="null" line="164" static="1">
		<f a="arr:?alpha" v=":1.0">
			<c path="Array"><c path="String"/></c>
			<x path="Float"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiCYMKA>
	<aiARGB public="1" get="inline" set="null" line="172" static="1">
		<f a="arr:?alpha" v=":1.0">
			<c path="Array"><c path="String"/></c>
			<x path="Float"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiARGB>
	<aiGreyA public="1" get="inline" set="null" line="180" static="1">
		<f a="s:?alpha" v=":1.0">
			<c path="String"/>
			<x path="Float"/>
			<x path="pallette.utils.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiGreyA>
	<ARGB_CYMKA public="1" get="inline" set="null" line="187" static="1"><f a="v">
	<c path="pallette.utils.ARGB"/>
	<c path="pallette.utils.CYMKA"/>
</f></ARGB_CYMKA>
	<CYMKA_ARGB public="1" get="inline" set="null" line="197" static="1"><f a="v">
	<c path="pallette.utils.CYMKA"/>
	<c path="pallette.utils.ARGB"/>
</f></CYMKA_ARGB>
	<luminosityGrey public="1" get="inline" set="null" line="204" static="1">
		<f a="this:?scale" v=":1.">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":value"><e>{ scale : 1. }</e></m>
			<m n=":impl"/>
		</meta>
	</luminosityGrey>
	<blendARGB public="1" get="inline" set="null" line="208" static="1">
		<f a="this:colB:t">
			<x path="Int"/>
			<x path="pallette.utils.ColorInt"/>
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</blendARGB>
	<blendRGB public="1" get="inline" set="null" line="222" static="1">
		<f a="this:colB:t">
			<x path="Int"/>
			<x path="pallette.utils.ColorInt"/>
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</blendRGB>
	<blend get="inline" set="null" line="235" static="1">
		<f a="this:a:b:t">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</blend>
	<smootherStep get="inline" set="null" line="240" static="1">
		<f a="this:t">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</smootherStep>
	<whitePercent public="1" get="inline" set="null" line="244" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></whitePercent>
	<whiteRatio public="1" get="inline" set="null" line="248" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></whiteRatio>
	<blackPercent public="1" get="inline" set="null" line="252" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></blackPercent>
	<blackRatio public="1" get="inline" set="null" line="256" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blackRatio>
	<colorPercent public="1" get="inline" set="null" line="260" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></colorPercent>
	<colorRatio public="1" get="inline" set="null" line="264" static="1"><f a="rRatio:gRatio:bRatio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></colorRatio>
	<darkColorPercent public="1" get="inline" set="null" line="268" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></darkColorPercent>
	<darkColorRatio public="1" get="inline" set="null" line="272" static="1"><f a="rRatio:gRatio:bRatio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></darkColorRatio>
	<redPercent public="1" get="inline" set="null" line="276" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></redPercent>
	<redRatio public="1" get="inline" set="null" line="280" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></redRatio>
	<greenPercent public="1" get="inline" set="null" line="284" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenPercent>
	<greenRatio public="1" get="inline" set="null" line="288" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenRatio>
	<bluePercent public="1" get="inline" set="null" line="292" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></bluePercent>
	<blueRatio public="1" get="inline" set="null" line="296" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueRatio>
	<redSoftPercent public="1" get="inline" set="null" line="300" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></redSoftPercent>
	<redSoftRatio public="1" get="inline" set="null" line="304" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></redSoftRatio>
	<greenSoftPercent public="1" get="inline" set="null" line="308" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenSoftPercent>
	<greenSoftRatio public="1" get="inline" set="null" line="312" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenSoftRatio>
	<blueSoftPercent public="1" get="inline" set="null" line="316" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueSoftPercent>
	<blueSoftRatio public="1" get="inline" set="null" line="320" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueSoftRatio>
	<yellowSoftPercent public="1" get="inline" set="null" line="324" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></yellowSoftPercent>
	<yellowSoftRatio public="1" get="inline" set="null" line="328" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></yellowSoftRatio>
	<magentaSoftPercent public="1" get="inline" set="null" line="332" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></magentaSoftPercent>
	<magentaSoftRatio public="1" get="inline" set="null" line="336" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></magentaSoftRatio>
	<cyanSoftPercent public="1" get="inline" set="null" line="340" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></cyanSoftPercent>
	<cyanSoftRatio public="1" get="inline" set="null" line="344" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></cyanSoftRatio>
</class></impl>
	</abstract>
	<class path="pallette.utils._ColorInt.ColorInt_Impl_" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/ColorInt.hx" private="1" module="pallette.utils.ColorInt" final="1">
		<_new public="1" get="inline" set="null" line="10" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromARGB public="1" get="inline" set="null" line="15" static="1">
			<f a="argb">
				<c path="pallette.utils.ARGB"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromARGB>
		<fromRGB public="1" get="inline" set="null" line="20" static="1">
			<f a="argb">
				<c path="pallette.utils.RGB"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromRGB>
		<htmlStyleRGBA public="1" get="inline" set="null" line="25" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</htmlStyleRGBA>
		<htmlStyleHex public="1" get="inline" set="null" line="30" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</htmlStyleHex>
		<toARGB public="1" get="inline" set="null" line="35" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="pallette.utils.ARGB"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toARGB>
		<toRGB public="1" get="inline" set="null" line="40" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="pallette.utils.RGB"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toRGB>
		<fromCYMKA public="1" get="inline" set="null" line="45" static="1">
			<f a="c">
				<c path="pallette.utils.CYMKA"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromCYMKA>
		<fromCYMK public="1" get="inline" set="null" line="50" static="1">
			<f a="c">
				<c path="pallette.utils.CYMK"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromCYMK>
		<toCYMKA public="1" get="inline" set="null" line="55" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="pallette.utils.CYMKA"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toCYMKA>
		<toCYMK public="1" get="inline" set="null" line="64" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="pallette.utils.CYMK"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toCYMK>
		<cyan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cyan>
		<get_cyan get="inline" set="null" line="73" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cyan>
		<set_cyan get="inline" set="null" line="77" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cyan>
		<yellow public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</yellow>
		<get_yellow get="inline" set="null" line="86" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_yellow>
		<set_yellow get="inline" set="null" line="90" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_yellow>
		<magenta public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</magenta>
		<get_magenta get="inline" set="null" line="99" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_magenta>
		<set_magenta get="inline" set="null" line="103" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_magenta>
		<black public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</black>
		<get_black get="inline" set="null" line="112" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_black>
		<set_black get="inline" set="null" line="115" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_black>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="124" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<set_alpha get="inline" set="null" line="128" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</red>
		<get_red get="inline" set="null" line="134" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<set_red get="inline" set="null" line="138" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</green>
		<get_green get="inline" set="null" line="144" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<set_green get="inline" set="null" line="148" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<get_blue get="inline" set="null" line="154" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<set_blue get="inline" set="null" line="158" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<aiCYMKA public="1" get="inline" set="null" line="164" static="1">
			<f a="arr:?alpha" v=":1.0">
				<c path="Array"><c path="String"/></c>
				<x path="Float"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiCYMKA>
		<aiARGB public="1" get="inline" set="null" line="172" static="1">
			<f a="arr:?alpha" v=":1.0">
				<c path="Array"><c path="String"/></c>
				<x path="Float"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiARGB>
		<aiGreyA public="1" get="inline" set="null" line="180" static="1">
			<f a="s:?alpha" v=":1.0">
				<c path="String"/>
				<x path="Float"/>
				<x path="pallette.utils.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiGreyA>
		<ARGB_CYMKA public="1" get="inline" set="null" line="187" static="1"><f a="v">
	<c path="pallette.utils.ARGB"/>
	<c path="pallette.utils.CYMKA"/>
</f></ARGB_CYMKA>
		<CYMKA_ARGB public="1" get="inline" set="null" line="197" static="1"><f a="v">
	<c path="pallette.utils.CYMKA"/>
	<c path="pallette.utils.ARGB"/>
</f></CYMKA_ARGB>
		<luminosityGrey public="1" get="inline" set="null" line="204" static="1">
			<f a="this:?scale" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{ scale : 1. }</e></m>
				<m n=":impl"/>
			</meta>
		</luminosityGrey>
		<blendARGB public="1" get="inline" set="null" line="208" static="1">
			<f a="this:colB:t">
				<x path="Int"/>
				<x path="pallette.utils.ColorInt"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</blendARGB>
		<blendRGB public="1" get="inline" set="null" line="222" static="1">
			<f a="this:colB:t">
				<x path="Int"/>
				<x path="pallette.utils.ColorInt"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</blendRGB>
		<blend get="inline" set="null" line="235" static="1">
			<f a="this:a:b:t">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</blend>
		<smootherStep get="inline" set="null" line="240" static="1">
			<f a="this:t">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</smootherStep>
		<whitePercent public="1" get="inline" set="null" line="244" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></whitePercent>
		<whiteRatio public="1" get="inline" set="null" line="248" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></whiteRatio>
		<blackPercent public="1" get="inline" set="null" line="252" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></blackPercent>
		<blackRatio public="1" get="inline" set="null" line="256" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blackRatio>
		<colorPercent public="1" get="inline" set="null" line="260" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></colorPercent>
		<colorRatio public="1" get="inline" set="null" line="264" static="1"><f a="rRatio:gRatio:bRatio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></colorRatio>
		<darkColorPercent public="1" get="inline" set="null" line="268" static="1"><f a="rPercent:gPercent:bPercent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></darkColorPercent>
		<darkColorRatio public="1" get="inline" set="null" line="272" static="1"><f a="rRatio:gRatio:bRatio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></darkColorRatio>
		<redPercent public="1" get="inline" set="null" line="276" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></redPercent>
		<redRatio public="1" get="inline" set="null" line="280" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></redRatio>
		<greenPercent public="1" get="inline" set="null" line="284" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenPercent>
		<greenRatio public="1" get="inline" set="null" line="288" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenRatio>
		<bluePercent public="1" get="inline" set="null" line="292" static="1"><f a="percent">
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></bluePercent>
		<blueRatio public="1" get="inline" set="null" line="296" static="1"><f a="ratio">
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueRatio>
		<redSoftPercent public="1" get="inline" set="null" line="300" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></redSoftPercent>
		<redSoftRatio public="1" get="inline" set="null" line="304" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></redSoftRatio>
		<greenSoftPercent public="1" get="inline" set="null" line="308" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenSoftPercent>
		<greenSoftRatio public="1" get="inline" set="null" line="312" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></greenSoftRatio>
		<blueSoftPercent public="1" get="inline" set="null" line="316" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueSoftPercent>
		<blueSoftRatio public="1" get="inline" set="null" line="320" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></blueSoftRatio>
		<yellowSoftPercent public="1" get="inline" set="null" line="324" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></yellowSoftPercent>
		<yellowSoftRatio public="1" get="inline" set="null" line="328" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></yellowSoftRatio>
		<magentaSoftPercent public="1" get="inline" set="null" line="332" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></magentaSoftPercent>
		<magentaSoftRatio public="1" get="inline" set="null" line="336" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></magentaSoftRatio>
		<cyanSoftPercent public="1" get="inline" set="null" line="340" static="1"><f a="percent:percentSoft">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pallette.utils.ColorInt"/>
</f></cyanSoftPercent>
		<cyanSoftRatio public="1" get="inline" set="null" line="344" static="1"><f a="ratio:ratioSoft">
	<x path="Float"/>
	<x path="Float"/>
	<x path="pallette.utils.ColorInt"/>
</f></cyanSoftRatio>
	</class>
	<class path="pallette.utils.RGB" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/utils/RGB.hx">
		<r public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</r>
		<g public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</g>
		<b public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</b>
		<new public="1" set="method" line="10"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ r, g, b }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="pallette.wheel.Wheel24" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/wheel/ColorWheel24.hx" module="pallette.wheel.ColorWheel24">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="pallette.wheel._ColorWheel24.Wheel24_Impl_" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/wheel/ColorWheel24.hx" private="1" module="pallette.wheel.ColorWheel24" extern="1" final="1">
	<redRadish public="1" get="inline" set="null" expr="cast 0xffef3c42" line="5" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffef3c42</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</redRadish>
	<orangeSoda public="1" get="inline" set="null" expr="cast 0xfff25e40" line="6" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfff25e40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</orangeSoda>
	<gokuOrange public="1" get="inline" set="null" expr="cast 0xfff2823a" line="7" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfff2823a</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</gokuOrange>
	<highlighterOrange public="1" get="inline" set="null" expr="cast 0xfff69537" line="8" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfff69537</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</highlighterOrange>
	<carona public="1" get="inline" set="null" expr="cast 0xfff4aa2f" line="9" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfff4aa2f</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</carona>
	<solarPower public="1" get="inline" set="null" expr="cast 0xfff6c137" line="10" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfff6c137</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</solarPower>
	<flirtatious public="1" get="inline" set="null" expr="cast 0xfffad435" line="11" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfffad435</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</flirtatious>
	<yellowBellied public="1" get="inline" set="null" expr="cast 0xfffdf32f" line="12" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xfffdf32f</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</yellowBellied>
	<daffodil public="1" get="inline" set="null" expr="cast 0xffffff2d" line="13" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffffff2d</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</daffodil>
	<spoiledEgg public="1" get="inline" set="null" expr="cast 0xffdff429" line="14" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffdff429</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</spoiledEgg>
	<peraRocha public="1" get="inline" set="null" expr="cast 0xffa7d52a" line="15" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffa7d52a</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</peraRocha>
	<appleGreen public="1" get="inline" set="null" expr="cast 0xff79c725" line="16" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff79c725</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</appleGreen>
	<fieldGreen public="1" get="inline" set="null" expr="cast 0xff53c025" line="17" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff53c025</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</fieldGreen>
	<parisGreen public="1" get="inline" set="null" expr="cast 0xff52c67f" line="18" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff52c67f</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</parisGreen>
	<maximumBlue public="1" get="inline" set="null" expr="cast 0xff4daecf" line="19" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff4daecf</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</maximumBlue>
	<blueTourmaline public="1" get="inline" set="null" expr="cast 0xff4592ca" line="20" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff4592ca</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</blueTourmaline>
	<celestialPlum public="1" get="inline" set="null" expr="cast 0xff3f77c4" line="21" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff3f77c4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</celestialPlum>
	<freeSpeechBlue public="1" get="inline" set="null" expr="cast 0xff3a57bf" line="22" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff3a57bf</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</freeSpeechBlue>
	<earlySpringNight public="1" get="inline" set="null" expr="cast 0xff3438bd" line="23" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff3438bd</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</earlySpringNight>
	<blueDepression public="1" get="inline" set="null" expr="cast 0xff4b27bd" line="24" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff4b27bd</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</blueDepression>
	<nebulaFuchsia public="1" get="inline" set="null" expr="cast 0xff7328b6" line="25" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xff7328b6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</nebulaFuchsia>
	<fuchsiaFlair public="1" get="inline" set="null" expr="cast 0xffb528c5" line="26" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffb528c5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</fuchsiaFlair>
	<royalFuchsia public="1" get="inline" set="null" expr="cast 0xffc32a94" line="27" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffc32a94</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</royalFuchsia>
	<fuchsiaPurple public="1" get="inline" set="null" expr="cast 0xffdd3371" line="28" static="1">
		<x path="pallette.wheel.Wheel24"/>
		<meta>
			<m n=":value"><e>cast 0xffdd3371</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</fuchsiaPurple>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="pallette.wheel._ColorWheel24.Wheel24_Impl_" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/wheel/ColorWheel24.hx" private="1" module="pallette.wheel.ColorWheel24" extern="1" final="1">
		<redRadish public="1" get="inline" set="null" expr="cast 0xffef3c42" line="5" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffef3c42</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</redRadish>
		<orangeSoda public="1" get="inline" set="null" expr="cast 0xfff25e40" line="6" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfff25e40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</orangeSoda>
		<gokuOrange public="1" get="inline" set="null" expr="cast 0xfff2823a" line="7" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfff2823a</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</gokuOrange>
		<highlighterOrange public="1" get="inline" set="null" expr="cast 0xfff69537" line="8" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfff69537</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</highlighterOrange>
		<carona public="1" get="inline" set="null" expr="cast 0xfff4aa2f" line="9" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfff4aa2f</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</carona>
		<solarPower public="1" get="inline" set="null" expr="cast 0xfff6c137" line="10" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfff6c137</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</solarPower>
		<flirtatious public="1" get="inline" set="null" expr="cast 0xfffad435" line="11" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfffad435</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</flirtatious>
		<yellowBellied public="1" get="inline" set="null" expr="cast 0xfffdf32f" line="12" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xfffdf32f</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</yellowBellied>
		<daffodil public="1" get="inline" set="null" expr="cast 0xffffff2d" line="13" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffffff2d</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</daffodil>
		<spoiledEgg public="1" get="inline" set="null" expr="cast 0xffdff429" line="14" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffdff429</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</spoiledEgg>
		<peraRocha public="1" get="inline" set="null" expr="cast 0xffa7d52a" line="15" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffa7d52a</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</peraRocha>
		<appleGreen public="1" get="inline" set="null" expr="cast 0xff79c725" line="16" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff79c725</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</appleGreen>
		<fieldGreen public="1" get="inline" set="null" expr="cast 0xff53c025" line="17" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff53c025</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</fieldGreen>
		<parisGreen public="1" get="inline" set="null" expr="cast 0xff52c67f" line="18" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff52c67f</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</parisGreen>
		<maximumBlue public="1" get="inline" set="null" expr="cast 0xff4daecf" line="19" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff4daecf</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</maximumBlue>
		<blueTourmaline public="1" get="inline" set="null" expr="cast 0xff4592ca" line="20" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff4592ca</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</blueTourmaline>
		<celestialPlum public="1" get="inline" set="null" expr="cast 0xff3f77c4" line="21" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff3f77c4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</celestialPlum>
		<freeSpeechBlue public="1" get="inline" set="null" expr="cast 0xff3a57bf" line="22" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff3a57bf</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</freeSpeechBlue>
		<earlySpringNight public="1" get="inline" set="null" expr="cast 0xff3438bd" line="23" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff3438bd</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</earlySpringNight>
		<blueDepression public="1" get="inline" set="null" expr="cast 0xff4b27bd" line="24" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff4b27bd</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</blueDepression>
		<nebulaFuchsia public="1" get="inline" set="null" expr="cast 0xff7328b6" line="25" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xff7328b6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</nebulaFuchsia>
		<fuchsiaFlair public="1" get="inline" set="null" expr="cast 0xffb528c5" line="26" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffb528c5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</fuchsiaFlair>
		<royalFuchsia public="1" get="inline" set="null" expr="cast 0xffc32a94" line="27" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffc32a94</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</royalFuchsia>
		<fuchsiaPurple public="1" get="inline" set="null" expr="cast 0xffdd3371" line="28" static="1">
			<x path="pallette.wheel.Wheel24"/>
			<meta>
				<m n=":value"><e>cast 0xffdd3371</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</fuchsiaPurple>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="pallette.wheel.ColorWheel24" params="" file="/usr/local/lib/haxeLibrary/pallette/0,0,1/src/pallette/wheel/ColorWheel24.hx">
		<getWheel public="1" get="inline" set="null" line="34" static="1"><f a=""><c path="Array"><x path="pallette.wheel.Wheel24"/></c></f></getWheel>
		<random public="1" get="inline" set="null" line="61" static="1"><f a=""><x path="pallette.wheel.Wheel24"/></f></random>
		<getName public="1" get="inline" set="null" line="67" static="1"><f a="w">
	<x path="pallette.wheel.Wheel24"/>
	<c path="String"/>
</f></getName>
		<next public="1" get="inline" set="null" line="96" static="1"><f a="w">
	<x path="pallette.wheel.Wheel24"/>
	<x path="pallette.wheel.Wheel24"/>
</f></next>
		<haxe_doc>![wheel24](../../bootstrap/img/wheel24.png)</haxe_doc>
	</class>
	<typedef path="sys.FileStat" params="" file="/usr/local/lib/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.io.File" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="29" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<getBytes public="1" set="method" line="33" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveContent public="1" set="method" line="38" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<saveBytes public="1" set="method" line="44" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" line="50" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" line="54" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<__f><d/></__f>
		<readByte public="1" set="method" line="36" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="47" override="1">
			<f a="s:p:l">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readBytes>
		<close public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="63"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="67"><f a=""><x path="Int"/></f></tell>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<__f><d/></__f>
		<writeByte public="1" set="method" line="36" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="43" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/local/lib/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="sys.thread._Thread.ThreadHandle" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<this><x path="sys.thread._Thread.ThreadHandle"/></this>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="sys.thread.Thread" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/thread/Thread.hx">
		<this><x path="sys.thread._Thread.ThreadHandle"/></this>
		<impl><class path="sys.thread._Thread.Thread_Impl_" params="" file="/usr/local/lib/haxe/std/cpp/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="trilateral3.DocTrilateral3" params="" file="src/trilateral3/DocTrilateral3.hx">
		<main public="1" set="method" line="20" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="trilateral3.Trilateral" params="" file="src/trilateral3/Trilateral.hx">
		<transformMatrix public="1" expr="null" line="6" static="1">
			<x path="Null"><c path="trilateral3.matrix.MatrixDozen"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformMatrix>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.color.ColorHelper" params="" file="src/trilateral3/color/ColorHelper.hx">
		<getBlack_ public="1" expr="getBlack">
			<f a="r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>getBlack</e></m></meta>
		</getBlack_>
		<from_cymka_ public="1" expr="from_cymka">
			<f a="c:y:m:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>from_cymka</e></m></meta>
		</from_cymka_>
		<from_argb_ public="1" expr="from_argb">
			<f a="a:r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>from_argb</e></m></meta>
		</from_argb_>
		<toHexInt_ public="1" expr="toHexInt">
			<f a="c">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>toHexInt</e></m></meta>
		</toHexInt_>
		<rgbConvert_ public="1" expr="rgbConvert">
			<f a="color:k">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>rgbConvert</e></m></meta>
		</rgbConvert_>
		<cymkConvert_ public="1" expr="cymkConvert">
			<f a="color:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>cymkConvert</e></m></meta>
		</cymkConvert_>
		<alphaChannel_ public="1" expr="alphaChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>alphaChannel</e></m></meta>
		</alphaChannel_>
		<redChannel_ public="1" expr="redChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>redChannel</e></m></meta>
		</redChannel_>
		<greenChannel_ public="1" expr="greenChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>greenChannel</e></m></meta>
		</greenChannel_>
		<blueChannel_ public="1" expr="blueChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>blueChannel</e></m></meta>
		</blueChannel_>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="trilateral3.color._ColorHelper.ColorHelper_Fields_" params="" file="src/trilateral3/color/ColorHelper.hx" private="1" module="trilateral3.color.ColorHelper" final="1">
		<getBlack public="1" get="inline" set="null" line="4" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getBlack>
		<from_cymka public="1" get="inline" set="null" line="8" static="1"><f a="c:y:m:k:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_cymka>
		<from_argb public="1" get="inline" set="null" line="15" static="1"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_argb>
		<toHexInt public="1" get="inline" set="null" line="21" static="1"><f a="c">
	<x path="Float"/>
	<x path="Int"/>
</f></toHexInt>
		<rgbConvert public="1" get="inline" set="null" line="24" static="1"><f a="color:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rgbConvert>
		<cymkConvert public="1" get="inline" set="null" line="27" static="1"><f a="color:black">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></cymkConvert>
		<alphaChannel public="1" get="inline" set="null" line="30" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="33" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="36" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="39" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.color.ColorInt" params="" file="src/trilateral3/color/ColorInt.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast field="fromARGB"><c path="trilateral3.structure.ARGB"/></icast>
			<icast field="fromCYMKA"><c path="trilateral3.structure.CYMKA"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toARGB"><c path="trilateral3.structure.ARGB"/></icast>
			<icast field="toCYMK"><c path="trilateral3.structure.CYMKA"/></icast>
		</to>
		<impl><class path="trilateral3.color._ColorInt.ColorInt_Impl_" params="" file="src/trilateral3/color/ColorInt.hx" private="1" module="trilateral3.color.ColorInt" final="1">
	<_new public="1" get="inline" set="null" line="7" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromARGB public="1" get="inline" set="null" line="12" static="1">
		<f a="argb">
			<c path="trilateral3.structure.ARGB"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromARGB>
	<toARGB public="1" get="inline" set="null" line="17" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="trilateral3.structure.ARGB"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toARGB>
	<fromCYMKA public="1" get="inline" set="null" line="22" static="1">
		<f a="c">
			<c path="trilateral3.structure.CYMKA"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromCYMKA>
	<toCYMK public="1" get="inline" set="null" line="27" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="trilateral3.structure.CYMKA"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toCYMK>
	<cyan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cyan>
	<get_cyan get="inline" set="null" line="36" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cyan>
	<set_cyan get="inline" set="null" line="40" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cyan>
	<yellow public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</yellow>
	<get_yellow get="inline" set="null" line="49" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_yellow>
	<set_yellow get="inline" set="null" line="53" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_yellow>
	<magenta public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</magenta>
	<get_magenta get="inline" set="null" line="62" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_magenta>
	<set_magenta get="inline" set="null" line="66" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_magenta>
	<black public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</black>
	<get_black get="inline" set="null" line="75" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_black>
	<set_black get="inline" set="null" line="78" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_black>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<get_alpha get="inline" set="null" line="87" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<set_alpha get="inline" set="null" line="91" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</red>
	<get_red get="inline" set="null" line="97" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<set_red get="inline" set="null" line="101" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</green>
	<get_green get="inline" set="null" line="107" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<set_green get="inline" set="null" line="111" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<get_blue get="inline" set="null" line="117" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<set_blue get="inline" set="null" line="121" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<aiCYMKA public="1" get="inline" set="null" line="127" static="1">
		<f a="arr:?alpha" v=":1.0">
			<c path="Array"><c path="String"/></c>
			<x path="Float"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiCYMKA>
	<aiARGB public="1" get="inline" set="null" line="135" static="1">
		<f a="arr:?alpha" v=":1.0">
			<c path="Array"><c path="String"/></c>
			<x path="Float"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiARGB>
	<aiGreyA public="1" get="inline" set="null" line="143" static="1">
		<f a="s:?alpha" v=":1.0">
			<c path="String"/>
			<x path="Float"/>
			<x path="trilateral3.color.ColorInt"/>
		</f>
		<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
	</aiGreyA>
	<ARGB_CYMKA public="1" get="inline" set="null" line="150" static="1"><f a="v">
	<c path="trilateral3.structure.ARGB"/>
	<c path="trilateral3.structure.CYMKA"/>
</f></ARGB_CYMKA>
	<CYMKA_ARGB public="1" get="inline" set="null" line="160" static="1"><f a="v">
	<c path="trilateral3.structure.CYMKA"/>
	<c path="trilateral3.structure.ARGB"/>
</f></CYMKA_ARGB>
</class></impl>
	</abstract>
	<class path="trilateral3.color._ColorInt.ColorInt_Impl_" params="" file="src/trilateral3/color/ColorInt.hx" private="1" module="trilateral3.color.ColorInt" final="1">
		<_new public="1" get="inline" set="null" line="7" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromARGB public="1" get="inline" set="null" line="12" static="1">
			<f a="argb">
				<c path="trilateral3.structure.ARGB"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromARGB>
		<toARGB public="1" get="inline" set="null" line="17" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="trilateral3.structure.ARGB"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toARGB>
		<fromCYMKA public="1" get="inline" set="null" line="22" static="1">
			<f a="c">
				<c path="trilateral3.structure.CYMKA"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromCYMKA>
		<toCYMK public="1" get="inline" set="null" line="27" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="trilateral3.structure.CYMKA"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toCYMK>
		<cyan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cyan>
		<get_cyan get="inline" set="null" line="36" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cyan>
		<set_cyan get="inline" set="null" line="40" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cyan>
		<yellow public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</yellow>
		<get_yellow get="inline" set="null" line="49" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_yellow>
		<set_yellow get="inline" set="null" line="53" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_yellow>
		<magenta public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</magenta>
		<get_magenta get="inline" set="null" line="62" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_magenta>
		<set_magenta get="inline" set="null" line="66" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_magenta>
		<black public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</black>
		<get_black get="inline" set="null" line="75" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_black>
		<set_black get="inline" set="null" line="78" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_black>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="87" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<set_alpha get="inline" set="null" line="91" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</red>
		<get_red get="inline" set="null" line="97" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<set_red get="inline" set="null" line="101" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</green>
		<get_green get="inline" set="null" line="107" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<set_green get="inline" set="null" line="111" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<get_blue get="inline" set="null" line="117" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<set_blue get="inline" set="null" line="121" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<aiCYMKA public="1" get="inline" set="null" line="127" static="1">
			<f a="arr:?alpha" v=":1.0">
				<c path="Array"><c path="String"/></c>
				<x path="Float"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiCYMKA>
		<aiARGB public="1" get="inline" set="null" line="135" static="1">
			<f a="arr:?alpha" v=":1.0">
				<c path="Array"><c path="String"/></c>
				<x path="Float"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiARGB>
		<aiGreyA public="1" get="inline" set="null" line="143" static="1">
			<f a="s:?alpha" v=":1.0">
				<c path="String"/>
				<x path="Float"/>
				<x path="trilateral3.color.ColorInt"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</aiGreyA>
		<ARGB_CYMKA public="1" get="inline" set="null" line="150" static="1"><f a="v">
	<c path="trilateral3.structure.ARGB"/>
	<c path="trilateral3.structure.CYMKA"/>
</f></ARGB_CYMKA>
		<CYMKA_ARGB public="1" get="inline" set="null" line="160" static="1"><f a="v">
	<c path="trilateral3.structure.CYMKA"/>
	<c path="trilateral3.structure.ARGB"/>
</f></CYMKA_ARGB>
	</class>
	<abstract path="trilateral3.drawing.Color3Abstract" params="" file="src/trilateral3/drawing/Color3Abstract.hx">
		<from><icast><t path="trilateral3.drawing.Color3Type"/></icast></from>
		<this><t path="trilateral3.drawing.Color3Type"/></this>
		<to><icast><t path="trilateral3.drawing.Color3Type"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._Color3Abstract.Color3Abstract_Impl_" params="" file="src/trilateral3/drawing/Color3Abstract.hx" private="1" module="trilateral3.drawing.Color3Abstract" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="color3Type">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="trilateral3.drawing.Color3Abstract"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<argb public="1" get="null" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argb>
	<set_argb get="inline" set="null" line="9" static="1">
		<f a="this:col">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argb>
	<argbA public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbA>
	<set_argbA get="inline" set="null" line="16" static="1">
		<f a="this:col">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbA>
	<get_argbA get="inline" set="null" line="20" static="1">
		<f a="this">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbA>
	<argbB public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbB>
	<set_argbB get="inline" set="null" line="25" static="1">
		<f a="this:col">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbB>
	<get_argbB get="inline" set="null" line="29" static="1">
		<f a="this">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbB>
	<argbC public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</argbC>
	<set_argbC get="inline" set="null" line="34" static="1">
		<f a="this:col">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_argbC>
	<get_argbC get="inline" set="null" line="38" static="1">
		<f a="this">
			<t path="trilateral3.drawing.Color3Type"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_argbC>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._Color3Abstract.Color3Abstract_Impl_" params="" file="src/trilateral3/drawing/Color3Abstract.hx" private="1" module="trilateral3.drawing.Color3Abstract" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="color3Type">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="trilateral3.drawing.Color3Abstract"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<argb public="1" get="null" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argb>
		<set_argb get="inline" set="null" line="9" static="1">
			<f a="this:col">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argb>
		<argbA public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbA>
		<set_argbA get="inline" set="null" line="16" static="1">
			<f a="this:col">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbA>
		<get_argbA get="inline" set="null" line="20" static="1">
			<f a="this">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbA>
		<argbB public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbB>
		<set_argbB get="inline" set="null" line="25" static="1">
			<f a="this:col">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbB>
		<get_argbB get="inline" set="null" line="29" static="1">
			<f a="this">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbB>
		<argbC public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</argbC>
		<set_argbC get="inline" set="null" line="34" static="1">
			<f a="this:col">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_argbC>
		<get_argbC get="inline" set="null" line="38" static="1">
			<f a="this">
				<t path="trilateral3.drawing.Color3Type"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_argbC>
	</class>
	<typedef path="trilateral3.drawing.Color3Type" params="" file="src/trilateral3/drawing/Color3Type.hx"><a>
	<set_argbC set="method"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argbC>
	<set_argbB set="method"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argbB>
	<set_argbA set="method"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argbA>
	<set_argb set="method"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argb>
	<get_argbC set="method"><f a=""><x path="Int"/></f></get_argbC>
	<get_argbB set="method"><f a=""><x path="Int"/></f></get_argbB>
	<get_argbA set="method"><f a=""><x path="Int"/></f></get_argbA>
</a></typedef>
	<abstract path="trilateral3.drawing.ColorAbstract" params="" file="src/trilateral3/drawing/ColorAbstract.hx">
		<from><icast><t path="trilateral3.drawing.ColorType"/></icast></from>
		<this><t path="trilateral3.drawing.ColorType"/></this>
		<to><icast><t path="trilateral3.drawing.ColorType"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._ColorAbstract.ColorAbstract_Impl_" params="" file="src/trilateral3/drawing/ColorAbstract.hx" private="1" module="trilateral3.drawing.ColorAbstract" final="1">
	<_new public="1" get="inline" set="null" line="4" static="1">
		<f a="colorType">
			<t path="trilateral3.drawing.ColorType"/>
			<x path="trilateral3.drawing.ColorAbstract"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<pos public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</pos>
	<get_pos get="inline" set="null" line="8" static="1">
		<f a="this">
			<t path="trilateral3.drawing.ColorType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pos>
	<set_pos get="inline" set="null" line="11" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.ColorType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_pos>
	<size public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</size>
	<set_size get="inline" set="null" line="16" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.ColorType"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_size>
	<get_size get="inline" set="null" line="20" static="1">
		<f a="this">
			<t path="trilateral3.drawing.ColorType"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_size>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._ColorAbstract.ColorAbstract_Impl_" params="" file="src/trilateral3/drawing/ColorAbstract.hx" private="1" module="trilateral3.drawing.ColorAbstract" final="1">
		<_new public="1" get="inline" set="null" line="4" static="1">
			<f a="colorType">
				<t path="trilateral3.drawing.ColorType"/>
				<x path="trilateral3.drawing.ColorAbstract"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<pos public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</pos>
		<get_pos get="inline" set="null" line="8" static="1">
			<f a="this">
				<t path="trilateral3.drawing.ColorType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pos>
		<set_pos get="inline" set="null" line="11" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.ColorType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_pos>
		<size public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</size>
		<set_size get="inline" set="null" line="16" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.ColorType"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_size>
		<get_size get="inline" set="null" line="20" static="1">
			<f a="this">
				<t path="trilateral3.drawing.ColorType"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_size>
	</class>
	<typedef path="trilateral3.drawing.ColorType" params="" file="src/trilateral3/drawing/ColorType.hx"><a>
	<set_size set="method"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
	<set_pos set="method"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pos>
	<get_size set="method"><f a=""><x path="Int"/></f></get_size>
	<get_pos set="method"><f a=""><x path="Float"/></f></get_pos>
	<getTriInt><f a=""><c path="trilateral3.structure.TriInt"/></f></getTriInt>
	<cornerColors><f a="colorA:colorB:colorC">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></cornerColors>
	<colorTriangles><f a="color:times">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></colorTriangles>
	<color3current>
		<x path="Null"><x path="trilateral3.drawing.Color3Abstract"/></x>
		<meta><m n=":optional"/></meta>
	</color3current>
</a></typedef>
	<class path="trilateral3.drawing.Contour" params="" file="src/trilateral3/drawing/Contour.hx">
		<smallDotScale get="inline" set="null" expr="0.07" line="95" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.07</e></m></meta>
		</smallDotScale>
		<thetaCompute get="inline" set="null" line="180" static="1"><f a="px:py:qx:qy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></thetaCompute>
		<dist get="inline" set="null" line="184" static="1"><f a="px:py:qx:qy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></dist>
		<debugCol0 public="1" expr="redRadish">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>redRadish</e></m></meta>
		</debugCol0>
		<debugCol1 public="1" expr="gokuOrange">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>gokuOrange</e></m></meta>
		</debugCol1>
		<debugCol2 public="1" expr="carona">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>carona</e></m></meta>
		</debugCol2>
		<debugCol3 public="1" expr="flirtatious">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>flirtatious</e></m></meta>
		</debugCol3>
		<debugCol4 public="1" expr="daffodil">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>daffodil</e></m></meta>
		</debugCol4>
		<debugCol5 public="1" expr="peraRocha">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>peraRocha</e></m></meta>
		</debugCol5>
		<debugCol6 public="1" expr="fieldGreen">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>fieldGreen</e></m></meta>
		</debugCol6>
		<debugCol7 public="1" expr="maximumBlue">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>maximumBlue</e></m></meta>
		</debugCol7>
		<debugCol8 public="1" expr="celestialPlum">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>celestialPlum</e></m></meta>
		</debugCol8>
		<debugCol9 public="1" expr="earlySpringNight">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>earlySpringNight</e></m></meta>
		</debugCol9>
		<debugCol10 public="1" expr="nebulaFuchsia">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>nebulaFuchsia</e></m></meta>
		</debugCol10>
		<debugCol11 public="1" expr="royalFuchsia">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>royalFuchsia</e></m></meta>
		</debugCol11>
		<debugCol12 public="1" expr="orangeSoda">
			<x path="pallette.wheel.Wheel24"/>
			<meta><m n=":value"><e>orangeSoda</e></m></meta>
		</debugCol12>
		<pointsClock public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointsClock>
		<pointsAnti public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointsAnti>
		<penultimateCX public="1"><x path="Float"/></penultimateCX>
		<penultimateCY public="1"><x path="Float"/></penultimateCY>
		<lastClockX public="1"><x path="Float"/></lastClockX>
		<lastClockY public="1"><x path="Float"/></lastClockY>
		<penultimateAX public="1"><x path="Float"/></penultimateAX>
		<penultimateAY public="1"><x path="Float"/></penultimateAY>
		<lastAntiX public="1"><x path="Float"/></lastAntiX>
		<lastAntiY public="1"><x path="Float"/></lastAntiY>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<endLine><x path="trilateral3.drawing.StyleEndLine"/></endLine>
		<ax><x path="Float"/></ax>
		<ay><x path="Float"/></ay>
		<bx><x path="Float"/></bx>
		<by><x path="Float"/></by>
		<cx><x path="Float"/></cx>
		<cy><x path="Float"/></cy>
		<dx><x path="Null"><x path="Float"/></x></dx>
		<dy><x path="Null"><x path="Float"/></x></dy>
		<ex><x path="Null"><x path="Float"/></x></ex>
		<ey><x path="Null"><x path="Float"/></x></ey>
		<dxPrev><x path="Null"><x path="Float"/></x></dxPrev>
		<dyPrev><x path="Null"><x path="Float"/></x></dyPrev>
		<exPrev><x path="Null"><x path="Float"/></x></exPrev>
		<eyPrev><x path="Null"><x path="Float"/></x></eyPrev>
		<dxOld><x path="Null"><x path="Float"/></x></dxOld>
		<dyOld><x path="Null"><x path="Float"/></x></dyOld>
		<exOld><x path="Null"><x path="Float"/></x></exOld>
		<eyOld><x path="Null"><x path="Float"/></x></eyOld>
		<jx><x path="Float"/></jx>
		<jy><x path="Float"/></jy>
		<lastClock><x path="Bool"/></lastClock>
		<jxOld><x path="Float"/></jxOld>
		<jyOld><x path="Float"/></jyOld>
		<kax><x path="Float"/></kax>
		<kay><x path="Float"/></kay>
		<kbx><x path="Float"/></kbx>
		<kby><x path="Float"/></kby>
		<kcx><x path="Float"/></kcx>
		<kcy><x path="Float"/></kcy>
		<ncx><x path="Float"/></ncx>
		<ncy><x path="Float"/></ncy>
		<quadIndex><x path="Float"/></quadIndex>
		<angleA public="1"><x path="Float"/></angleA>
		<halfA public="1"><x path="Float"/></halfA>
		<beta public="1"><x path="Float"/></beta>
		<r><x path="Float"/></r>
		<theta public="1"><x path="Float"/></theta>
		<angle1 public="1"><x path="Null"><x path="Float"/></x></angle1>
		<angle2 public="1"><x path="Float"/></angle2>
		<reset public="1" set="method" line="97"><f a=""><x path="Void"/></f></reset>
		<count public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<computeDE public="1" get="inline" set="null" line="139"><f a=""><x path="Void"/></f></computeDE>
		<anglesCompute get="inline" set="null" line="155"><f a=""><x path="Void"/></f></anglesCompute>
		<thetaComputeAdj get="inline" set="null" line="176"><f a="qx:qy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></thetaComputeAdj>
		<triangleJoin public="1" get="inline" set="null" line="193">
			<f a="ax_:ay_:bx_:by_:width_:?curveEnds:?overlap" v=":::::false:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ overlap : false, curveEnds : false }</e></m></meta>
		</triangleJoin>
		<overlapQuad get="inline" set="null" line="300"><f a=""><x path="Void"/></f></overlapQuad>
		<end public="1" get="inline" set="null" line="308"><f a="width_">
	<x path="Float"/>
	<x path="Void"/>
</f></end>
		<triangle2DFill get="inline" set="null" line="314">
			<f a="ax_:ay_:bx_:by_:cx_:cy_:?color_" v="::::::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color_ : -1 }</e></m></meta>
		</triangle2DFill>
		<addPieXstart get="inline" set="null" line="318">
			<f a="ax:ay:radius:beta:gamma:prefer:?mark:?sides" v="::::::-1:36">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36, mark : -1 }</e></m></meta>
		</addPieXstart>
		<addPieX get="inline" set="null" line="340">
			<f a="ax:ay:radius:beta:gamma:prefer:?mark:?sides" v="::::::0:36">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36, mark : 0 }</e></m></meta>
		</addPieX>
		<addPie get="inline" set="null" line="361">
			<f a="ax:ay:radius:beta:gamma:prefer:?mark:?sides" v="::::::0:36">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36, mark : 0 }</e></m></meta>
		</addPie>
		<computeJ get="inline" set="null" line="368"><f a="width_:theta0:dif">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></computeJ>
		<addDot get="inline" set="null" line="378"><f a="x:y:color:width_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addDot>
		<addSmallTriangles get="inline" set="null" line="407"><f a="clockWise:width_">
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addSmallTriangles>
		<triangle2DFillangleCorners get="inline" set="null" line="419"><f a="oldx_:oldy_:prevx_:prevy_:width_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></triangle2DFillangleCorners>
		<triangle2DFillangleCornersLess get="inline" set="null" line="435"><f a="oldx_:oldy_:prevx_:prevy_:width_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></triangle2DFillangleCornersLess>
		<connectQuadsWhenQuadsOverlay get="inline" set="null" line="449"><f a="clockWise:width_">
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></connectQuadsWhenQuadsOverlay>
		<connectQuads get="inline" set="null" line="464"><f a="clockWise:width_">
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></connectQuads>
		<addInitialQuads get="inline" set="null" line="480"><f a="clockWise:width_">
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addInitialQuads>
		<endEdges public="1" set="method" line="564"><f a=""><x path="Void"/></f></endEdges>
		<counter expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</counter>
		<addQuads set="method" line="590"><f a="clockWise:width_">
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addQuads>
		<storeLastQuads get="inline" set="null" line="756"><f a=""><x path="Void"/></f></storeLastQuads>
		<isClockwise get="inline" set="null" line="766"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isClockwise>
		<line public="1" get="inline" set="null" line="770">
			<f a="ax_:ay_:bx_:by_:width_:?endLineCurve" v=":::::no">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.drawing.StyleEndLine"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endLineCurve : no }</e></m></meta>
		</line>
		<new public="1" set="method" line="134">
			<f a="pen_:?endLine_" v=":no">
				<c path="trilateral3.drawing.Pen"/>
				<x path="trilateral3.drawing.StyleEndLine"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endLine_ : no }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.drawing.DrawAbstract" params="" file="src/trilateral3/drawing/DrawAbstract.hx">
		<from><icast><t path="trilateral3.drawing.DrawType"/></icast></from>
		<this><t path="trilateral3.drawing.DrawType"/></this>
		<to><icast><t path="trilateral3.drawing.DrawType"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._DrawAbstract.DrawAbstract_Impl_" params="" file="src/trilateral3/drawing/DrawAbstract.hx" private="1" module="trilateral3.drawing.DrawAbstract" final="1">
	<_new public="1" get="inline" set="null" line="4" static="1">
		<f a="drawType">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="trilateral3.drawing.DrawAbstract"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<pos public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</pos>
	<get_pos get="inline" set="null" line="8" static="1">
		<f a="this">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pos>
	<set_pos get="inline" set="null" line="11" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_pos>
	<size public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</size>
	<set_size get="inline" set="null" line="16" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_size>
	<get_size get="inline" set="null" line="20" static="1">
		<f a="this">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_size>
	<toStart get="inline" set="null" line="23" static="1">
		<f a="this:v:len">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toStart>
	<toEnd get="inline" set="null" line="26" static="1">
		<f a="this:v:len">
			<t path="trilateral3.drawing.DrawType"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toEnd>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._DrawAbstract.DrawAbstract_Impl_" params="" file="src/trilateral3/drawing/DrawAbstract.hx" private="1" module="trilateral3.drawing.DrawAbstract" final="1">
		<_new public="1" get="inline" set="null" line="4" static="1">
			<f a="drawType">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="trilateral3.drawing.DrawAbstract"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<pos public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</pos>
		<get_pos get="inline" set="null" line="8" static="1">
			<f a="this">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pos>
		<set_pos get="inline" set="null" line="11" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_pos>
		<size public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</size>
		<set_size get="inline" set="null" line="16" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_size>
		<get_size get="inline" set="null" line="20" static="1">
			<f a="this">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_size>
		<toStart get="inline" set="null" line="23" static="1">
			<f a="this:v:len">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toStart>
		<toEnd get="inline" set="null" line="26" static="1">
			<f a="this:v:len">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toEnd>
	</class>
	<typedef path="trilateral3.drawing.DrawType" params="" file="src/trilateral3/drawing/DrawType.hx"><a>
	<triangleUV>
		<x path="Null"><f a="uA_:vA_:uB_:vB_:uC_:vC_:?windAdjust_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</triangleUV>
	<triangleCurrentUV>
		<x path="Null"><x path="trilateral3.drawing.TriangleAbstractUV"/></x>
		<meta><m n=":optional"/></meta>
	</triangleCurrentUV>
	<triangleCurrent>
		<x path="Null"><x path="trilateral3.drawing.TriangleAbstract"/></x>
		<meta><m n=":optional"/></meta>
	</triangleCurrent>
	<triangle><f a="ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></triangle>
	<transformRange><f a="m:startEnd">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></transformRange>
	<transform><f a="">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="Void"/>
</f></transform>
	<toStart set="method"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></toStart>
	<toEnd set="method"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></toEnd>
	<set_size set="method"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
	<set_pos set="method"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pos>
	<next><f a=""><x path="Float"/></f></next>
	<hasNext><f a=""><x path="Bool"/></f></hasNext>
	<get_size set="method"><f a=""><x path="Int"/></f></get_size>
	<get_pos set="method"><f a=""><x path="Float"/></f></get_pos>
	<getTriangleUV>
		<x path="Null"><f a=""><c path="trilateral3.structure.TriangleUV"/></f></x>
		<meta><m n=":optional"/></meta>
	</getTriangleUV>
	<getTriangle3D><f a=""><c path="trilateral3.structure.Triangle3D"/></f></getTriangle3D>
</a></typedef>
	<class path="trilateral3.drawing._Fill.Fill_Fields_" params="" file="src/trilateral3/drawing/Fill.hx" private="1" module="trilateral3.drawing.Fill" final="1"><triangulate public="1" set="method" line="11" static="1"><f a="pen:sketch:fillForm">
	<c path="trilateral3.drawing.Pen"/>
	<c path="trilateral3.drawing.Sketch"/>
	<x path="trilateral3.drawing.StyleFill"/>
	<x path="Void"/>
</f></triangulate></class>
	<class path="trilateral3.drawing.Nymph" params="" file="src/trilateral3/drawing/Nymph.hx">
		<iterNymph public="1" set="method" line="34" static="1"><f a="pen:iteratorRange">
	<c path="trilateral3.drawing.Pen"/>
	<x path="trilateral3.shape.IteratorRange"/>
	<c path="trilateral3.drawing.Nymph"/>
</f></iterNymph>
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<curr><x path="trilateral3.drawing.TriangleAbstract"/></curr>
		<currUV><x path="trilateral3.drawing.TriangleAbstractUV"/></currUV>
		<curr3color><x path="trilateral3.drawing.Color3Abstract"/></curr3color>
		<indexRange><x path="trilateral3.shape.IndexRange"/></indexRange>
		<sx expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sx>
		<sy expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sy>
		<su expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</su>
		<sv expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sv>
		<theta expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</theta>
		<moveStart public="1" set="method" line="38"><f a="sx_:sy_:su_:sv_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveStart>
		<dMoveXY public="1" set="method" line="54"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dMoveXY>
		<dMoveUV public="1" set="method" line="63"><f a="du:dv">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dMoveUV>
		<dMoveXYUV public="1" set="method" line="72"><f a="dx:dy:du:dv">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dMoveXYUV>
		<setColor public="1" set="method" line="83"><f a="col">
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<setRndColor public="1" set="method" line="89"><f a="col">
	<x path="Int"/>
	<x path="Void"/>
</f></setRndColor>
		<dRotate public="1" set="method" line="95"><f a="dx:dy:dr">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dRotate>
		<rotateCentre2 public="1" set="method" line="103"><f a="vx:vy:ax:ay:val">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateCentre2>
		<rotateCentre public="1" set="method" line="107"><f a="vx:vy:val">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateCentre>
		<x get="accessor" set="accessor"><x path="Float"/></x>
		<get_x public="1" set="method" line="111"><f a=""><x path="Float"/></f></get_x>
		<set_x public="1" set="method" line="114"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y get="accessor" set="accessor"><x path="Float"/></y>
		<get_y public="1" set="method" line="120"><f a=""><x path="Float"/></f></get_y>
		<set_y public="1" set="method" line="123"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<u get="accessor" set="accessor"><x path="Float"/></u>
		<get_u public="1" set="method" line="129"><f a=""><x path="Float"/></f></get_u>
		<set_u public="1" set="method" line="132"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_u>
		<v get="accessor" set="accessor"><x path="Float"/></v>
		<get_v public="1" set="method" line="138"><f a=""><x path="Float"/></f></get_v>
		<set_v public="1" set="method" line="141"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_v>
		<argb public="1" get="accessor" set="accessor"><x path="Int"/></argb>
		<_argb expr="0xFFFFFFFF">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		</_argb>
		<set_argb get="inline" set="null" line="148"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argb>
		<get_argb get="inline" set="null" line="154"><f a=""><x path="Int"/></f></get_argb>
		<new public="1" set="method" line="20"><f a="pen:indexRange">
	<c path="trilateral3.drawing.Pen"/>
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="trilateral3.drawing.PaintAbstract" params="" file="src/trilateral3/drawing/PaintAbstract.hx">
		<from><icast><t path="trilateral3.drawing.PaintType"/></icast></from>
		<this><t path="trilateral3.drawing.PaintType"/></this>
		<to><icast><t path="trilateral3.drawing.PaintType"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._PaintAbstract.PaintAbstract_Impl_" params="" file="src/trilateral3/drawing/PaintAbstract.hx" private="1" module="trilateral3.drawing.PaintAbstract" final="1">
	<_new public="1" get="inline" set="null" line="4" static="1">
		<f a="paintType">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="trilateral3.drawing.PaintAbstract"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<pos public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</pos>
	<get_pos get="inline" set="null" line="8" static="1">
		<f a="this">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pos>
	<set_pos get="inline" set="null" line="11" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_pos>
	<size public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</size>
	<set_size get="inline" set="null" line="16" static="1">
		<f a="this:v">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_size>
	<get_size get="inline" set="null" line="20" static="1">
		<f a="this">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_size>
	<toStart public="1" get="inline" set="null" line="23" static="1">
		<f a="this:v:len">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toStart>
	<toEnd public="1" get="inline" set="null" line="27" static="1">
		<f a="this:v:len">
			<t path="trilateral3.drawing.PaintType"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toEnd>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._PaintAbstract.PaintAbstract_Impl_" params="" file="src/trilateral3/drawing/PaintAbstract.hx" private="1" module="trilateral3.drawing.PaintAbstract" final="1">
		<_new public="1" get="inline" set="null" line="4" static="1">
			<f a="paintType">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="trilateral3.drawing.PaintAbstract"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<pos public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</pos>
		<get_pos get="inline" set="null" line="8" static="1">
			<f a="this">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pos>
		<set_pos get="inline" set="null" line="11" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_pos>
		<size public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</size>
		<set_size get="inline" set="null" line="16" static="1">
			<f a="this:v">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_size>
		<get_size get="inline" set="null" line="20" static="1">
			<f a="this">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_size>
		<toStart public="1" get="inline" set="null" line="23" static="1">
			<f a="this:v:len">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toStart>
		<toEnd public="1" get="inline" set="null" line="27" static="1">
			<f a="this:v:len">
				<t path="trilateral3.drawing.PaintType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toEnd>
	</class>
	<typedef path="trilateral3.drawing.PaintType" params="" file="src/trilateral3/drawing/PaintType.hx"><a>
	<triangleUV>
		<x path="Null"><f a="uA_:vA_:uB_:vB_:uC_:vC_:?windAdjust_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</triangleUV>
	<triangleCurrentUV>
		<x path="Null"><x path="trilateral3.drawing.TriangleAbstractUV"/></x>
		<meta><m n=":optional"/></meta>
	</triangleCurrentUV>
	<triangleCurrent>
		<x path="Null"><x path="trilateral3.drawing.TriangleAbstract"/></x>
		<meta><m n=":optional"/></meta>
	</triangleCurrent>
	<triangle><f a="ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></triangle>
	<transformRange><f a="m:startEnd">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></transformRange>
	<transform><f a="">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="Void"/>
</f></transform>
	<toStart set="method"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></toStart>
	<toEnd set="method"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></toEnd>
	<set_size set="method"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
	<set_pos set="method"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pos>
	<next><f a=""><x path="Float"/></f></next>
	<hasNext><f a=""><x path="Bool"/></f></hasNext>
	<get_size set="method"><f a=""><x path="Int"/></f></get_size>
	<get_pos set="method"><f a=""><x path="Float"/></f></get_pos>
	<getTriangleUV>
		<x path="Null"><f a=""><c path="trilateral3.structure.TriangleUV"/></f></x>
		<meta><m n=":optional"/></meta>
	</getTriangleUV>
	<getTriangle3D><f a=""><c path="trilateral3.structure.Triangle3D"/></f></getTriangle3D>
	<getTriInt><f a=""><c path="trilateral3.structure.TriInt"/></f></getTriInt>
	<cornerColors><f a="colorA:colorB:colorC">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></cornerColors>
	<colorTriangles><f a="color:times">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></colorTriangles>
	<color3current>
		<x path="Null"><x path="trilateral3.drawing.Color3Abstract"/></x>
		<meta><m n=":optional"/></meta>
	</color3current>
</a></typedef>
	<class path="trilateral3.drawing.Pen" params="" file="src/trilateral3/drawing/Pen.hx">
		<tweenWrap public="1" set="method" line="267" static="1"><f a="tweenEquation">
	<f a=":::">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Float"/>
	</f>
	<f a="">
		<x path="Float"/>
		<x path="Float"/>
	</f>
</f></tweenWrap>
		<z2D public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</z2D>
		<useTexture public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useTexture>
		<textureFX expr="1. / 1000.">
			<x path="Float"/>
			<meta><m n=":value"><e>1. / 1000.</e></m></meta>
		</textureFX>
		<textureFY expr="1. / 1000.">
			<x path="Float"/>
			<meta><m n=":value"><e>1. / 1000.</e></m></meta>
		</textureFY>
		<rounded public="1" expr="30">
			<x path="Float"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</rounded>
		<dz public="1" expr="0.01">
			<x path="Float"/>
			<meta><m n=":value"><e>0.01</e></m></meta>
		</dz>
		<currentColor public="1" expr="0xFACADE">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFACADE</e></m></meta>
		</currentColor>
		<paintType public="1"><x path="trilateral3.drawing.PaintAbstract"/></paintType>
		<translateX public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></translateX>
		<translateY public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></translateY>
		<translateZ public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></translateZ>
		<rotateX public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></rotateX>
		<rotateY public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></rotateY>
		<rotateZ public="1"><f a="">
	<x path="Float"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></rotateZ>
		<indices public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</indices>
		<transformRange public="1" get="inline" set="null" line="41"><f a="trans:ir">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></transformRange>
		<textureXYWH public="1" get="null" set="accessor"><x path="trilateral3.structure.XYWH"/></textureXYWH>
		<set_textureXYWH get="inline" set="null" line="46"><f a="r">
	<x path="trilateral3.structure.XYWH"/>
	<x path="trilateral3.structure.XYWH"/>
</f></set_textureXYWH>
		<up public="1" get="inline" set="null" line="52"><f a="ir">
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></up>
		<down public="1" get="inline" set="null" line="57"><f a="ir">
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></down>
		<back public="1" get="inline" set="null" line="62"><f a="ir">
	<x path="trilateral3.shape.IndexRange"/>
	<x path="Void"/>
</f></back>
		<transBack get="inline" set="null" line="66"><f a=""><c path="trilateral3.matrix.MatrixDozen"/></f></transBack>
		<cornerColor public="1" get="inline" set="null" line="96">
			<f a="?color" v="-1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : -1 }</e></m></meta>
		</cornerColor>
		<cornerColors public="1" get="inline" set="null" line="101"><f a="colorA:colorB:colorC">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></cornerColors>
		<middleColor public="1" get="inline" set="null" line="105"><f a="color:colorCentre">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleColor>
		<middleColors public="1" get="inline" set="null" line="109"><f a="color:colorCentre:times">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleColors>
		<colorTriangles public="1" get="inline" set="null" line="115"><f a="color:times">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></colorTriangles>
		<addTriangle public="1" get="inline" set="null" line="121"><f a="ax:ay:az:bx:by:bz:cx:cy:cz">
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="cpp.Float32"/>
	<x path="Bool"/>
</f></addTriangle>
		<triangle2DFillGrad public="1" get="inline" set="null" line="167">
			<f a="ax:ay:bx:by:cx:cy:?col0:?col1:?gradCorner" v="::::::-1:-1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ gradCorner : 0, col1 : -1, col0 : -1 }</e></m></meta>
		</triangle2DFillGrad>
		<triangle2DFill public="1" get="inline" set="null" line="186">
			<f a="ax:ay:bx:by:cx:cy:?color" v="::::::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ color : -1 }</e></m></meta>
		</triangle2DFill>
		<nineSliceFill public="1" get="inline" set="null" line="202">
			<f a="ax:ay:width:height:left:right:top:bottom:?color0:?color1:?color2:?color3:?color4:?color5:?color6:?color7:?color8" v="::::::::-1:-1:-1:-1:-1:-1:-1:-1:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ color8 : -1, color7 : -1, color6 : -1, color5 : -1, color4 : -1, color3 : -1, color2 : -1, color1 : -1, color0 : -1 }</e></m></meta>
		</nineSliceFill>
		<quad2DFill public="1" get="inline" set="null" line="225">
			<f a="ax:ay:width:height:?color" v="::::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ color : -1 }</e></m></meta>
		</quad2DFill>
		<quad2DFillclockwise public="1" get="inline" set="null" line="234">
			<f a="ax:ay:bx:by:cx:cy:dx:dy:?color" v="::::::::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ color : -1 }</e></m></meta>
		</quad2DFillclockwise>
		<quadGradient public="1" get="inline" set="null" line="246">
			<f a="pos:dim:?col0:?col1:?horizontal:?theta:?pivotX:?pivotY" v="::-1:-1:false:0.:0.:0.">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ pivotY : 0., pivotX : 0., theta : 0., horizontal : false, col1 : -1, col0 : -1 }</e></m></meta>
		</quadGradient>
		<multiGradient public="1" get="inline" set="null" line="271">
			<f a="horizontal_:x_:y_:wid_:hi_:colors:?func:?theta:?pivotX:?pivotY" v="::::::null:0.:0.:0.">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Int"/></c>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ pivotY : 0., pivotX : 0., theta : 0., func : null }</e></m></meta>
		</multiGradient>
		<pos public="1" get="accessor" set="accessor"><x path="Float"/></pos>
		<get_pos get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_pos>
		<set_pos get="inline" set="null" line="316"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pos>
		<size public="1" get="accessor" set="accessor"><x path="Int"/></size>
		<get_size get="inline" set="null" line="323"><f a=""><x path="Int"/></f></get_size>
		<set_size get="inline" set="null" line="327"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<setStartDepth public="1" get="inline" set="null" line="335">
			<f a="v:len">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* sends pos to start of draw array ( bottom? )</haxe_doc>
		</setStartDepth>
		<setEndDepth public="1" get="inline" set="null" line="342">
			<f a="v:len">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* sends pos to end of draw array ( top? )</haxe_doc>
		</setEndDepth>
		<triangleCurrent public="1" get="accessor" set="null">
			<x path="trilateral3.drawing.TriangleAbstract"/>
			<haxe_doc>* Only optionally available use with care, works with PenNodule.</haxe_doc>
		</triangleCurrent>
		<get_triangleCurrent get="inline" set="null" line="350"><f a=""><x path="trilateral3.drawing.TriangleAbstract"/></f></get_triangleCurrent>
		<triangleCurrentUV public="1" get="accessor" set="null">
			<x path="trilateral3.drawing.TriangleAbstractUV"/>
			<haxe_doc>* Only optionally available use with care, works with PenNoduleUV.</haxe_doc>
		</triangleCurrentUV>
		<get_triangleCurrentUV get="inline" set="null" line="358"><f a=""><x path="trilateral3.drawing.TriangleAbstractUV"/></f></get_triangleCurrentUV>
		<color3Current public="1" get="accessor" set="null">
			<x path="trilateral3.drawing.Color3Abstract"/>
			<haxe_doc>* Only possible if using interleave data structure !! use with care.</haxe_doc>
		</color3Current>
		<get_color3Current get="inline" set="null" line="366"><f a=""><x path="trilateral3.drawing.Color3Abstract"/></f></get_color3Current>
		<copyRange public="1" get="inline" set="null" line="370"><f a="otherPen:startEnd:vec">
	<c path="trilateral3.drawing.Pen"/>
	<x path="trilateral3.shape.IndexRange"/>
	<c path="trilateral3.matrix.Vertex"/>
	<x path="trilateral3.shape.IndexRange"/>
</f></copyRange>
		<new public="1" set="method" line="38"><f a="paintType_">
	<x path="trilateral3.drawing.PaintAbstract"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.drawing.AIColorType" params="" file="src/trilateral3/drawing/Sketch.hx" module="trilateral3.drawing.Sketch">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.drawing._Sketch.AIColorType_Impl_" params="" file="src/trilateral3/drawing/Sketch.hx" private="1" module="trilateral3.drawing.Sketch" extern="1" final="1">
	<GRAY public="1" get="inline" set="null" expr="cast &quot;g&quot;" line="10" static="1">
		<x path="trilateral3.drawing.AIColorType"/>
		<meta>
			<m n=":value"><e>cast "g"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAY>
	<CYMK public="1" get="inline" set="null" expr="cast &quot;k&quot;" line="11" static="1">
		<x path="trilateral3.drawing.AIColorType"/>
		<meta>
			<m n=":value"><e>cast "k"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CYMK>
	<RGB public="1" get="inline" set="null" expr="cast &quot;xa&quot;" line="12" static="1">
		<x path="trilateral3.drawing.AIColorType"/>
		<meta>
			<m n=":value"><e>cast "xa"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB>
	<EPS_RGB public="1" get="inline" set="null" expr="cast &quot;r&quot;" line="13" static="1">
		<x path="trilateral3.drawing.AIColorType"/>
		<meta>
			<m n=":value"><e>cast "r"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EPS_RGB>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._Sketch.AIColorType_Impl_" params="" file="src/trilateral3/drawing/Sketch.hx" private="1" module="trilateral3.drawing.Sketch" extern="1" final="1">
		<GRAY public="1" get="inline" set="null" expr="cast &quot;g&quot;" line="10" static="1">
			<x path="trilateral3.drawing.AIColorType"/>
			<meta>
				<m n=":value"><e>cast "g"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAY>
		<CYMK public="1" get="inline" set="null" expr="cast &quot;k&quot;" line="11" static="1">
			<x path="trilateral3.drawing.AIColorType"/>
			<meta>
				<m n=":value"><e>cast "k"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CYMK>
		<RGB public="1" get="inline" set="null" expr="cast &quot;xa&quot;" line="12" static="1">
			<x path="trilateral3.drawing.AIColorType"/>
			<meta>
				<m n=":value"><e>cast "xa"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB>
		<EPS_RGB public="1" get="inline" set="null" expr="cast &quot;r&quot;" line="13" static="1">
			<x path="trilateral3.drawing.AIColorType"/>
			<meta>
				<m n=":value"><e>cast "r"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EPS_RGB>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="trilateral3.drawing.Dim" params="" file="src/trilateral3/drawing/Sketch.hx" module="trilateral3.drawing.Sketch"><a>
	<minY><x path="Float"/></minY>
	<minX><x path="Float"/></minX>
	<maxY><x path="Float"/></maxY>
	<maxX><x path="Float"/></maxX>
</a></typedef>
	<class path="trilateral3.drawing.Sketch" params="" file="src/trilateral3/drawing/Sketch.hx">
		<implements path="justPath.IPathContext"/>
		<create public="1" get="inline" set="null" line="88" static="1">
			<f a="paintType_:sketchForm_:?endLine_" v="::no">
				<x path="trilateral3.drawing.PaintAbstract"/>
				<x path="trilateral3.drawing.StyleSketch"/>
				<x path="trilateral3.drawing.StyleEndLine"/>
				<c path="trilateral3.drawing.Sketch"/>
			</f>
			<meta><m n=":value"><e>{ endLine_ : no }</e></m></meta>
		</create>
		<x expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x>
		<y expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<width public="1" expr="0.01">
			<x path="Float"/>
			<meta><m n=":value"><e>0.01</e></m></meta>
		</width>
		<widthFunction public="1"><f a="::::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></widthFunction>
		<colourFunction public="1"><f a="::::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colourFunction>
		<tempArr><c path="Array"><x path="Float"/></c></tempArr>
		<contour public="1"><c path="trilateral3.drawing.Contour"/></contour>
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<endLine><x path="trilateral3.drawing.StyleEndLine"/></endLine>
		<sketchForm><x path="trilateral3.drawing.StyleSketch"/></sketchForm>
		<points public="1"><c path="Array"><c path="Array"><x path="Float"/></c></c></points>
		<pointsClock public="1"><c path="Array"><c path="Array"><x path="Float"/></c></c></pointsClock>
		<pointsAnti public="1"><c path="Array"><c path="Array"><x path="Float"/></c></c></pointsAnti>
		<dim public="1"><c path="Array"><t path="trilateral3.drawing.Dim"/></c></dim>
		<tracerLine get="inline" set="null" line="37"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></tracerLine>
		<fillOnlyLine get="inline" set="null" line="40"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillOnlyLine>
		<baseLine set="method" line="42"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></baseLine>
		<crudeLine get="inline" set="null" line="46"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></crudeLine>
		<roundEndLine get="inline" set="null" line="49"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></roundEndLine>
		<mediumLine get="inline" set="null" line="52"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></mediumLine>
		<mediumOverlapLine get="inline" set="null" line="55"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></mediumOverlapLine>
		<fineLine get="inline" set="null" line="58"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fineLine>
		<fineOverlapLine get="inline" set="null" line="61"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fineOverlapLine>
		<line public="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></line>
		<reset public="1" set="method" line="97"><f a=""><x path="Void"/></f></reset>
		<pointsNoEndOverlap public="1" set="method" line="106"><f a=""><c path="Array"><c path="Array"><x path="Float"/></c></c></f></pointsNoEndOverlap>
		<pointsRewound public="1" set="method" line="160"><f a=""><c path="Array"><c path="Array"><x path="Float"/></c></c></f></pointsRewound>
		<initDim get="inline" set="null" line="220"><f a=""><t path="trilateral3.drawing.Dim"/></f></initDim>
		<updateDim get="inline" set="null" line="223"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateDim>
		<moveTo public="1" set="method" line="230"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lastClock public="1" get="inline" set="null" line="247"><f a=""><x path="Void"/></f></lastClock>
		<getEdges public="1" get="inline" set="null" line="257"><f a=""><c path="Array"><c path="Array"><x path="Float"/></c></c></f></getEdges>
		<lineTo public="1" get="inline" set="null" line="285"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadTo public="1" get="inline" set="null" line="302"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<quadThru public="1" get="inline" set="null" line="311"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadThru>
		<curveTo public="1" get="inline" set="null" line="317"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<plotCoord public="1" get="inline" set="null" line="325">
			<f a="arr:?withMove" v=":true">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withMove : true }</e></m></meta>
		</plotCoord>
		<aiColorSet set="method" line="339"><f a="colorType:arr">
	<x path="trilateral3.drawing.AIColorType"/>
	<c path="Array"><c path="String"/></c>
	<x path="trilateral3.color.ColorInt"/>
</f></aiColorSet>
		<getColorType set="method" line="356"><f a="arr">
	<c path="Array"><c path="String"/></c>
	<x path="trilateral3.drawing.AIColorType"/>
</f></getColorType>
		<aiStringPart public="1" get="inline" set="null" line="362">
			<f a="str:x:y:?flipY" v=":::0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flipY : 0 }</e></m></meta>
		</aiStringPart>
		<new public="1" set="method" line="65">
			<f a="pen_:sketchForm_:?endLine_" v="::no">
				<c path="trilateral3.drawing.Pen"/>
				<x path="trilateral3.drawing.StyleSketch"/>
				<x path="trilateral3.drawing.StyleEndLine"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endLine_ : no }</e></m></meta>
		</new>
	</class>
	<abstract path="trilateral3.drawing.StyleEndLine" params="" file="src/trilateral3/drawing/StyleEndLine.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.drawing._StyleEndLine.StyleEndLine_Impl_" params="" file="src/trilateral3/drawing/StyleEndLine.hx" private="1" module="trilateral3.drawing.StyleEndLine" extern="1" final="1">
	<no public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="trilateral3.drawing.StyleEndLine"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</no>
	<begin public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="trilateral3.drawing.StyleEndLine"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</begin>
	<end public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="trilateral3.drawing.StyleEndLine"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</end>
	<both public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="trilateral3.drawing.StyleEndLine"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</both>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._StyleEndLine.StyleEndLine_Impl_" params="" file="src/trilateral3/drawing/StyleEndLine.hx" private="1" module="trilateral3.drawing.StyleEndLine" extern="1" final="1">
		<no public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="trilateral3.drawing.StyleEndLine"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</no>
		<begin public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="trilateral3.drawing.StyleEndLine"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</begin>
		<end public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="trilateral3.drawing.StyleEndLine"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</end>
		<both public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="trilateral3.drawing.StyleEndLine"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</both>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="trilateral3.drawing.StyleFill" params="" file="src/trilateral3/drawing/StyleFill.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.drawing._StyleFill.StyleFill_Impl_" params="" file="src/trilateral3/drawing/StyleFill.hx" private="1" module="trilateral3.drawing.StyleFill" extern="1" final="1">
	<tess2 public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="trilateral3.drawing.StyleFill"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</tess2>
	<polyK public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="trilateral3.drawing.StyleFill"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</polyK>
	<poly2tri public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="trilateral3.drawing.StyleFill"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</poly2tri>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._StyleFill.StyleFill_Impl_" params="" file="src/trilateral3/drawing/StyleFill.hx" private="1" module="trilateral3.drawing.StyleFill" extern="1" final="1">
		<tess2 public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="trilateral3.drawing.StyleFill"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</tess2>
		<polyK public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="trilateral3.drawing.StyleFill"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</polyK>
		<poly2tri public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="trilateral3.drawing.StyleFill"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</poly2tri>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="trilateral3.drawing.StyleSketch" params="" file="src/trilateral3/drawing/StyleSketch.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.drawing._StyleSketch.StyleSketch_Impl_" params="" file="src/trilateral3/drawing/StyleSketch.hx" private="1" module="trilateral3.drawing.StyleSketch" extern="1" final="1">
	<Tracer public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tracer>
	<Base public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Base>
	<Crude public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Crude>
	<FillOnly public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FillOnly>
	<Fine public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Fine>
	<FineOverlap public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FineOverlap>
	<Medium public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Medium>
	<MediumOverlap public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MediumOverlap>
	<RoundEnd public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="trilateral3.drawing.StyleSketch"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RoundEnd>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._StyleSketch.StyleSketch_Impl_" params="" file="src/trilateral3/drawing/StyleSketch.hx" private="1" module="trilateral3.drawing.StyleSketch" extern="1" final="1">
		<Tracer public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tracer>
		<Base public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Base>
		<Crude public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Crude>
		<FillOnly public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FillOnly>
		<Fine public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Fine>
		<FineOverlap public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FineOverlap>
		<Medium public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Medium>
		<MediumOverlap public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MediumOverlap>
		<RoundEnd public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="trilateral3.drawing.StyleSketch"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RoundEnd>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="trilateral3.drawing.TriangleAbstract" params="" file="src/trilateral3/drawing/TriangleAbstract.hx">
		<from><icast><t path="trilateral3.drawing.TriangleType"/></icast></from>
		<this><t path="trilateral3.drawing.TriangleType"/></this>
		<to><icast><t path="trilateral3.drawing.TriangleType"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._TriangleAbstract.TriangleAbstract_Impl_" params="" file="src/trilateral3/drawing/TriangleAbstract.hx" private="1" module="trilateral3.drawing.TriangleAbstract" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="triangleType">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="trilateral3.drawing.TriangleAbstract"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<bottom public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottom>
	<get_bottom get="inline" set="null" line="9" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottom>
	<back public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</back>
	<get_back get="inline" set="null" line="13" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_back>
	<right public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</right>
	<get_right get="inline" set="null" line="17" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_right>
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="21" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<set_x get="inline" set="null" line="24" static="1">
		<f a="this:x_">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="28" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<set_y get="inline" set="null" line="31" static="1">
		<f a="this:y_">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_y>
	<z public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</z>
	<get_z get="inline" set="null" line="35" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_z>
	<set_z get="inline" set="null" line="38" static="1">
		<f a="this:z_">
			<t path="trilateral3.drawing.TriangleType"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_z>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._TriangleAbstract.TriangleAbstract_Impl_" params="" file="src/trilateral3/drawing/TriangleAbstract.hx" private="1" module="trilateral3.drawing.TriangleAbstract" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="triangleType">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="trilateral3.drawing.TriangleAbstract"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<bottom public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottom>
		<get_bottom get="inline" set="null" line="9" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottom>
		<back public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</back>
		<get_back get="inline" set="null" line="13" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_back>
		<right public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</right>
		<get_right get="inline" set="null" line="17" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_right>
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="21" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<set_x get="inline" set="null" line="24" static="1">
			<f a="this:x_">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="28" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<set_y get="inline" set="null" line="31" static="1">
			<f a="this:y_">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_y>
		<z public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</z>
		<get_z get="inline" set="null" line="35" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_z>
		<set_z get="inline" set="null" line="38" static="1">
			<f a="this:z_">
				<t path="trilateral3.drawing.TriangleType"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_z>
	</class>
	<abstract path="trilateral3.drawing.TriangleAbstractUV" params="" file="src/trilateral3/drawing/TriangleAbstractUV.hx">
		<from><icast><t path="trilateral3.drawing.TriangleTypeUV"/></icast></from>
		<this><t path="trilateral3.drawing.TriangleTypeUV"/></this>
		<to><icast><t path="trilateral3.drawing.TriangleTypeUV"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.drawing._TriangleAbstractUV.TriangleAbstractUV_Impl_" params="" file="src/trilateral3/drawing/TriangleAbstractUV.hx" private="1" module="trilateral3.drawing.TriangleAbstractUV" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="triangleTypeUV">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="trilateral3.drawing.TriangleAbstractUV"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<bottomV public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</bottomV>
	<get_bottomV get="inline" set="null" line="9" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bottomV>
	<rightU public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</rightU>
	<get_rightU get="inline" set="null" line="13" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rightU>
	<u public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</u>
	<get_u get="inline" set="null" line="17" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_u>
	<set_u get="inline" set="null" line="20" static="1">
		<f a="this:u_">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_u>
	<v public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</v>
	<get_v get="inline" set="null" line="24" static="1">
		<f a="this">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_v>
	<set_v get="inline" set="null" line="27" static="1">
		<f a="this:v_">
			<t path="trilateral3.drawing.TriangleTypeUV"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_v>
</class></impl>
	</abstract>
	<class path="trilateral3.drawing._TriangleAbstractUV.TriangleAbstractUV_Impl_" params="" file="src/trilateral3/drawing/TriangleAbstractUV.hx" private="1" module="trilateral3.drawing.TriangleAbstractUV" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="triangleTypeUV">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="trilateral3.drawing.TriangleAbstractUV"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<bottomV public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</bottomV>
		<get_bottomV get="inline" set="null" line="9" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bottomV>
		<rightU public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</rightU>
		<get_rightU get="inline" set="null" line="13" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rightU>
		<u public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</u>
		<get_u get="inline" set="null" line="17" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_u>
		<set_u get="inline" set="null" line="20" static="1">
			<f a="this:u_">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_u>
		<v public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</v>
		<get_v get="inline" set="null" line="24" static="1">
			<f a="this">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_v>
		<set_v get="inline" set="null" line="27" static="1">
			<f a="this:v_">
				<t path="trilateral3.drawing.TriangleTypeUV"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_v>
	</class>
	<typedef path="trilateral3.drawing.TriangleType" params="" file="src/trilateral3/drawing/TriangleType.hx"><a>
	<triangle><f a="ax_:ay_:az_:bx_:by_:bz_:cx_:cy_:cz_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></triangle>
	<transform><f a="">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<x path="Void"/>
</f></transform>
	<set_z set="method"><f a="z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
	<set_y set="method"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
	<set_x set="method"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
	<rotateTrig><f a="x:y:cos:sin">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateTrig>
	<rotate><f a="x:y:theta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
	<moveDelta><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveDelta>
	<liteHit><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></liteHit>
	<get_z set="method"><f a=""><x path="Float"/></f></get_z>
	<get_y set="method"><f a=""><x path="Float"/></f></get_y>
	<get_x set="method"><f a=""><x path="Float"/></f></get_x>
	<get_right set="method"><f a=""><x path="Float"/></f></get_right>
	<get_bottom set="method"><f a=""><x path="Float"/></f></get_bottom>
	<get_back set="method"><f a=""><x path="Float"/></f></get_back>
	<getTriangle3D><f a=""><c path="trilateral3.structure.Triangle3D"/></f></getTriangle3D>
	<fullHit><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></fullHit>
</a></typedef>
	<typedef path="trilateral3.drawing.TriangleTypeUV" params="" file="src/trilateral3/drawing/TriangleTypeUV.hx"><a>
	<triangleUV><f a="au_:av_:bu_:bv_:cu_:cv_:?windAdjust_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></triangleUV>
	<set_v set="method"><f a="v_">
	<x path="Float"/>
	<x path="Float"/>
</f></set_v>
	<set_u set="method"><f a="u_">
	<x path="Float"/>
	<x path="Float"/>
</f></set_u>
	<moveDelta><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveDelta>
	<get_v set="method"><f a=""><x path="Float"/></f></get_v>
	<get_u set="method"><f a=""><x path="Float"/></f></get_u>
	<get_rightU set="method"><f a=""><x path="Float"/></f></get_rightU>
	<get_bottomV set="method"><f a=""><x path="Float"/></f></get_bottomV>
	<getTriangleUV><f a=""><c path="trilateral3.structure.TriangleUV"/></f></getTriangleUV>
</a></typedef>
	<abstract path="trilateral3.geom.FlatColorTriangles" params="" file="src/trilateral3/geom/FlatColorTriangles.hx">
		<this><x path="dsHelper.flatInterleave.FloatColorTriangles"/></this>
		<to><icast field="toArray"><x path="lime.utils.Float32Array"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.geom._FlatColorTriangles.FlatColorTriangles_Impl_" params="" file="src/trilateral3/geom/FlatColorTriangles.hx" private="1" module="trilateral3.geom.FlatColorTriangles" final="1">
	<toArray public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toArray>
	<_new public="1" get="inline" set="null" line="20" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="trilateral3.geom.FlatColorTriangles"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<transform public="1" set="method" line="23" static="1">
		<f a="this:m">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transform>
	<transformAll public="1" set="method" line="41" static="1">
		<f a="this:m">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformAll>
	<transformRange public="1" set="method" line="49" static="1">
		<f a="this:m:startEnd">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="trilateral3.shape.IndexRange"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformRange>
	<getTriangle3D public="1" get="inline" set="null" line="60" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<c path="trilateral3.structure.Triangle3D"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriangle3D>
	<getTriInt public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
			<c path="trilateral3.structure.TriInt"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriInt>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.geom._FlatColorTriangles.FlatColorTriangles_Impl_" params="" file="src/trilateral3/geom/FlatColorTriangles.hx" private="1" module="trilateral3.geom.FlatColorTriangles" final="1">
		<toArray public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<_new public="1" get="inline" set="null" line="20" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="trilateral3.geom.FlatColorTriangles"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<transform public="1" set="method" line="23" static="1">
			<f a="this:m">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transform>
		<transformAll public="1" set="method" line="41" static="1">
			<f a="this:m">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformAll>
		<transformRange public="1" set="method" line="49" static="1">
			<f a="this:m:startEnd">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="trilateral3.shape.IndexRange"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformRange>
		<getTriangle3D public="1" get="inline" set="null" line="60" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<c path="trilateral3.structure.Triangle3D"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriangle3D>
		<getTriInt public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTriangles"/>
				<c path="trilateral3.structure.TriInt"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriInt>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.geom.FlatColorTrianglesUV" params="" file="src/trilateral3/geom/FlatColorTrianglesUV.hx">
		<from><icast><x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/></icast></from>
		<this><x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/></this>
		<to>
			<icast><x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/></icast>
			<icast field="toArray"><x path="lime.utils.Float32Array"/></icast>
		</to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.geom._FlatColorTrianglesUV.FlatColorTrianglesUV_Impl_" params="" file="src/trilateral3/geom/FlatColorTrianglesUV.hx" private="1" module="trilateral3.geom.FlatColorTrianglesUV" final="1">
	<toArray public="1" get="inline" set="null" line="17" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<t path="dsHelper.haxe.io.Float32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toArray>
	<_new public="1" get="inline" set="null" line="22" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="trilateral3.geom.FlatColorTrianglesUV"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<transform public="1" set="method" line="25" static="1">
		<f a="this:m">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transform>
	<transformAll public="1" set="method" line="43" static="1">
		<f a="this:m">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformAll>
	<transformRange public="1" set="method" line="51" static="1">
		<f a="this:m:startEnd">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="trilateral3.shape.IndexRange"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformRange>
	<getTriangle3D public="1" get="inline" set="null" line="62" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.structure.Triangle3D"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriangle3D>
	<getTriangleUV public="1" get="inline" set="null" line="69" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.structure.TriangleUV"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriangleUV>
	<getTriInt public="1" get="inline" set="null" line="76" static="1">
		<f a="this">
			<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
			<c path="trilateral3.structure.TriInt"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriInt>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.geom._FlatColorTrianglesUV.FlatColorTrianglesUV_Impl_" params="" file="src/trilateral3/geom/FlatColorTrianglesUV.hx" private="1" module="trilateral3.geom.FlatColorTrianglesUV" final="1">
		<toArray public="1" get="inline" set="null" line="17" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<t path="dsHelper.haxe.io.Float32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<_new public="1" get="inline" set="null" line="22" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="trilateral3.geom.FlatColorTrianglesUV"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<transform public="1" set="method" line="25" static="1">
			<f a="this:m">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transform>
		<transformAll public="1" set="method" line="43" static="1">
			<f a="this:m">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformAll>
		<transformRange public="1" set="method" line="51" static="1">
			<f a="this:m:startEnd">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="trilateral3.shape.IndexRange"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformRange>
		<getTriangle3D public="1" get="inline" set="null" line="62" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.structure.Triangle3D"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriangle3D>
		<getTriangleUV public="1" get="inline" set="null" line="69" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.structure.TriangleUV"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriangleUV>
		<getTriInt public="1" get="inline" set="null" line="76" static="1">
			<f a="this">
				<x path="dsHelper.flatInterleave.FloatColorTrianglesUV"/>
				<c path="trilateral3.structure.TriInt"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriInt>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.geom.FlatColors" params="" file="src/trilateral3/geom/FlatColors.hx">
		<this><x path="dsHelper.flat.f32.Float32FlatRGBA"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.geom._FlatColors.FlatColors_Impl_" params="" file="src/trilateral3/geom/FlatColors.hx" private="1" module="trilateral3.geom.FlatColors" final="1">
	<_new public="1" get="inline" set="null" line="12" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="trilateral3.geom.FlatColors"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getTriInt public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32FlatRGBA"/>
			<c path="trilateral3.structure.TriInt"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriInt>
</class></impl>
	</abstract>
	<class path="trilateral3.geom._FlatColors.FlatColors_Impl_" params="" file="src/trilateral3/geom/FlatColors.hx" private="1" module="trilateral3.geom.FlatColors" final="1">
		<_new public="1" get="inline" set="null" line="12" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="trilateral3.geom.FlatColors"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getTriInt public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32FlatRGBA"/>
				<c path="trilateral3.structure.TriInt"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriInt>
	</class>
	<abstract path="trilateral3.geom.FlatTriangles" params="" file="src/trilateral3/geom/FlatTriangles.hx">
		<this><x path="dsHelper.flat.f32.Float32FlatTriangle"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.geom._FlatTriangles.FlatTriangles_Impl_" params="" file="src/trilateral3/geom/FlatTriangles.hx" private="1" module="trilateral3.geom.FlatTriangles" final="1">
	<_new public="1" get="inline" set="null" line="11" static="1">
		<f a="len">
			<x path="Int"/>
			<x path="trilateral3.geom.FlatTriangles"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<transform public="1" set="method" line="14" static="1">
		<f a="this:m">
			<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transform>
	<transformAll public="1" set="method" line="32" static="1">
		<f a="this:m">
			<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformAll>
	<transformRange public="1" set="method" line="40" static="1">
		<f a="this:m:startEnd">
			<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
			<c path="trilateral3.matrix.MatrixDozen"/>
			<x path="trilateral3.shape.IndexRange"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformRange>
	<getTriangle3D public="1" get="inline" set="null" line="51" static="1">
		<f a="this">
			<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
			<c path="trilateral3.structure.Triangle3D"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getTriangle3D>
</class></impl>
	</abstract>
	<class path="trilateral3.geom._FlatTriangles.FlatTriangles_Impl_" params="" file="src/trilateral3/geom/FlatTriangles.hx" private="1" module="trilateral3.geom.FlatTriangles" final="1">
		<_new public="1" get="inline" set="null" line="11" static="1">
			<f a="len">
				<x path="Int"/>
				<x path="trilateral3.geom.FlatTriangles"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<transform public="1" set="method" line="14" static="1">
			<f a="this:m">
				<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transform>
		<transformAll public="1" set="method" line="32" static="1">
			<f a="this:m">
				<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformAll>
		<transformRange public="1" set="method" line="40" static="1">
			<f a="this:m:startEnd">
				<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
				<c path="trilateral3.matrix.MatrixDozen"/>
				<x path="trilateral3.shape.IndexRange"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformRange>
		<getTriangle3D public="1" get="inline" set="null" line="51" static="1">
			<f a="this">
				<x path="dsHelper.flat.f32.Float32FlatTriangle"/>
				<c path="trilateral3.structure.Triangle3D"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getTriangle3D>
	</class>
	<class path="trilateral3.geom._Transformer.Transformer_Fields_" params="" file="src/trilateral3/geom/Transformer.hx" private="1" module="trilateral3.geom.Transformer" final="1">
		<multiplyTransform public="1" get="inline" set="null" line="7" static="1"><f a="r:s">
	<c path="trilateral3.matrix.MatrixDozen"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
</f></multiplyTransform>
		<transformVertex public="1" get="inline" set="null" line="18" static="1"><f a="v:t">
	<c path="trilateral3.matrix.Vertex"/>
	<c path="trilateral3.matrix.MatrixDozen"/>
	<c path="trilateral3.matrix.Vertex"/>
</f></transformVertex>
		<unitTransform public="1" get="inline" set="null" line="26" static="1"><f a=""><c path="trilateral3.matrix.MatrixDozen"/></f></unitTransform>
	</class>
	<class path="trilateral3.math.Algebra" params="" file="src/trilateral3/math/Algebra.hx">
		<adjustWinding_ public="1" expr="adjustWinding">
			<f a="A_:B_:C_">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>adjustWinding</e></m></meta>
		</adjustWinding_>
		<minusXY_ public="1" expr="minusXY">
			<f a="a:b">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
			</f>
			<meta><m n=":value"><e>minusXY</e></m></meta>
		</minusXY_>
		<sign_ public="1" expr="sign">
			<f a="n">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>sign</e></m></meta>
		</sign_>
		<quadCurve_ public="1" expr="quadCurve">
			<f a="p:ax:ay:bx:by:cx:cy">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>quadCurve</e></m></meta>
		</quadCurve_>
		<cubicCurve_ public="1" expr="cubicCurve">
			<f a="p:ax:ay:bx:by:cx:cy:dx:dy">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>cubicCurve</e></m></meta>
		</cubicCurve_>
		<calculateQuadStep_ public="1" expr="calculateQuadStep">
			<f a="ax:ay:bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>calculateQuadStep</e></m></meta>
		</calculateQuadStep_>
		<calculateCubicStep_ public="1" expr="calculateCubicStep">
			<f a="ax:ay:bx:by:cx:cy:dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>calculateCubicStep</e></m></meta>
		</calculateCubicStep_>
		<lineAB_ public="1" expr="lineAB">
			<f a="A:B:width">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
				<c path="trilateral3.structure.Quad2D"/>
			</f>
			<meta><m n=":value"><e>lineAB</e></m></meta>
		</lineAB_>
		<lineABCoord_ public="1" expr="lineABCoord">
			<f a="ax:ay:bx:by:width">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="trilateral3.structure.Quad2D"/>
			</f>
			<meta><m n=":value"><e>lineABCoord</e></m></meta>
		</lineABCoord_>
		<rotateVectorLine_ public="1" expr="rotateVectorLine">
			<f a="pos:dim:omega:pivotX:pivotY">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="trilateral3.structure.Quad2D"/>
			</f>
			<meta><m n=":value"><e>rotateVectorLine</e></m></meta>
		</rotateVectorLine_>
		<pivotCheap_ public="1" expr="pivotCheap">
			<f a="p:sin:cos:pivotX:pivotY">
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="trilateral3.structure.XY"/>
			</f>
			<meta><m n=":value"><e>pivotCheap</e></m></meta>
		</pivotCheap_>
		<pivot_ public="1" expr="pivot">
			<f a="p:omega:pivotX:pivotY">
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="trilateral3.structure.XY"/>
			</f>
			<meta><m n=":value"><e>pivot</e></m></meta>
		</pivot_>
		<thetaCheap_ public="1" expr="thetaCheap">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>thetaCheap</e></m></meta>
		</thetaCheap_>
		<distCheap_ public="1" expr="distCheap">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>distCheap</e></m></meta>
		</distCheap_>
		<distance_ public="1" expr="distance">
			<f a="px:py:qx:qy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>distance</e></m></meta>
		</distance_>
		<quadraticThru_ public="1" expr="quadraticThru">
			<f a="t:s:c:e">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>quadraticThru</e></m></meta>
		</quadraticThru_>
		<quadratic_ public="1" expr="quadratic">
			<f a="t:s:c:e">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>quadratic</e></m></meta>
		</quadratic_>
		<quadSegment_ public="1" expr="quadSegment">
			<f a="t0:t1:s:c:e">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>quadSegment</e></m></meta>
		</quadSegment_>
		<cubic_ public="1" expr="cubic">
			<f a="t:s:c1:c2:e">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>cubic</e></m></meta>
		</cubic_>
		<perp_ public="1" expr="perp">
			<f a="a:b">
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>perp</e></m></meta>
		</perp_>
		<new public="1" set="method" line="168">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="trilateral3.math._Algebra.Algebra_Fields_" params="" file="src/trilateral3/math/Algebra.hx" private="1" module="trilateral3.math.Algebra" final="1">
		<adjustWinding public="1" get="inline" set="null" line="7" static="1"><f a="A_:B_:C_">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Bool"/>
</f></adjustWinding>
		<minusXY public="1" get="inline" set="null" line="14" static="1"><f a="a:b">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></minusXY>
		<sign public="1" get="inline" set="null" line="19" static="1"><f a="n">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<quadStep public="1" expr="0.03" line="22" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
		</quadStep>
		<quadCurve public="1" get="inline" set="null" line="25" static="1"><f a="p:ax:ay:bx:by:cx:cy">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></quadCurve>
		<cubicStep public="1" get="inline" set="null" expr="0.03" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
		</cubicStep>
		<cubicCurve public="1" get="inline" set="null" line="44" static="1"><f a="p:ax:ay:bx:by:cx:cy:dx:dy">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></cubicCurve>
		<calculateQuadStep public="1" get="inline" set="null" line="60" static="1"><f a="ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculateQuadStep>
		<calculateCubicStep public="1" get="inline" set="null" line="66" static="1"><f a="ax:ay:bx:by:cx:cy:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculateCubicStep>
		<lineAB public="1" get="inline" set="null" line="73" static="1"><f a="A:B:width">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
	<c path="trilateral3.structure.Quad2D"/>
</f></lineAB>
		<lineABCoord public="1" get="inline" set="null" line="83" static="1"><f a="ax:ay:bx:by:width">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="trilateral3.structure.Quad2D"/>
</f></lineABCoord>
		<rotateVectorLine public="1" get="inline" set="null" line="92" static="1"><f a="pos:dim:omega:pivotX:pivotY">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="trilateral3.structure.Quad2D"/>
</f></rotateVectorLine>
		<pivotCheap public="1" get="inline" set="null" line="114" static="1"><f a="p:sin:cos:pivotX:pivotY">
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="trilateral3.structure.XY"/>
</f></pivotCheap>
		<pivot public="1" get="inline" set="null" line="122" static="1"><f a="p:omega:pivotX:pivotY">
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="trilateral3.structure.XY"/>
</f></pivot>
		<thetaCheap public="1" get="inline" set="null" line="130" static="1"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></thetaCheap>
		<distCheap public="1" get="inline" set="null" line="134" static="1"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distCheap>
		<distance public="1" get="inline" set="null" line="138" static="1"><f a="px:py:qx:qy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distance>
		<quadraticThru public="1" get="inline" set="null" line="144" static="1"><f a="t:s:c:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticThru>
		<quadratic public="1" get="inline" set="null" line="149" static="1"><f a="t:s:c:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></quadratic>
		<quadSegment public="1" get="inline" set="null" line="154" static="1"><f a="t0:t1:s:c:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></quadSegment>
		<cubic public="1" get="inline" set="null" line="159" static="1"><f a="t:s:c1:c2:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></cubic>
		<perp public="1" get="inline" set="null" line="164" static="1"><f a="a:b">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
</f></perp>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.matrix.MatrixDozen" params="" file="src/trilateral3/matrix/MatrixDozen.hx">
		<a public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</a>
		<b public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</b>
		<c public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</c>
		<d public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</d>
		<e public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</e>
		<f public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</f>
		<g public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</g>
		<h public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</h>
		<i public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</i>
		<j public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</j>
		<k public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</k>
		<l public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</l>
		<values public="1" set="method" line="20"><f a=""><c path="String"/></f></values>
		<new set="method" line="12"><f a="a:b:c:d:e:f:g:h:i:j:k:l">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.matrix.UV" params="" file="src/trilateral3/matrix/UV.hx">
		<u public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</u>
		<v public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</v>
		<values public="1" set="method" line="50"><f a=""><c path="String"/></f></values>
		<new set="method" line="45"><f a="u:v">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ u, v }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.matrix.Vertex" params="" file="src/trilateral3/matrix/Vertex.hx">
		<x public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x>
		<y public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<z public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</z>
		<w public="1" expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":optional"/>
			</meta>
		</w>
		<values public="1" set="method" line="25"><f a=""><c path="String"/></f></values>
		<new set="method" line="18">
			<f a="x:y:z:?w" v=":::1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1. }</e></m></meta>
		</new>
		<haxe_doc>{ x, y, z, w }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.nodule.PenNodule" params="" file="src/trilateral3/nodule/PenNodule.hx">
		<largeEnough final="1" set="null" expr="20000000" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20000000</e></m></meta>
		</largeEnough>
		<colorTriangles public="1" expr="new FlatColorTriangles(largeEnough)">
			<x path="trilateral3.geom.FlatColorTriangles"/>
			<meta><m n=":value"><e>new FlatColorTriangles(largeEnough)</e></m></meta>
		</colorTriangles>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<createPen public="1" set="method" line="24"><f a=""><c path="trilateral3.drawing.Pen"/></f></createPen>
		<data public="1" get="accessor" set="null"><t path="dsHelper.haxe.io.Float32Array"/></data>
		<get_data public="1" get="inline" set="null" line="82"><f a=""><t path="dsHelper.haxe.io.Float32Array"/></f></get_data>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<get_size public="1" get="inline" set="null" line="87"><f a=""><x path="Int"/></f></get_size>
		<new public="1" set="method" line="14">
			<f a="?useGLScale" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useGLScale : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.nodule.PenPaint" params="" file="src/trilateral3/nodule/PenPaint.hx">
		<largeEnough final="1" set="null" expr="20000000" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20000000</e></m></meta>
		</largeEnough>
		<colorTriangles public="1" expr="new FlatColorTrianglesUV(largeEnough)">
			<x path="trilateral3.geom.FlatColorTrianglesUV"/>
			<meta><m n=":value"><e>new FlatColorTrianglesUV(largeEnough)</e></m></meta>
		</colorTriangles>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<createPen public="1" set="method" line="27"><f a=""><x path="Void"/></f></createPen>
		<data public="1" get="accessor" set="null"><t path="dsHelper.haxe.io.Float32Array"/></data>
		<get_data public="1" get="inline" set="null" line="99"><f a=""><t path="dsHelper.haxe.io.Float32Array"/></f></get_data>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<get_size public="1" get="inline" set="null" line="104"><f a=""><x path="Int"/></f></get_size>
		<new public="1" set="method" line="17">
			<f a="?useGLScale" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useGLScale : true }</e></m></meta>
		</new>
	</class>
	<abstract path="trilateral3.reShape.DepthArray" params="T" file="src/trilateral3/reShape/DepthArray.hx">
		<from><icast><c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c></icast></from>
		<this><c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c></this>
		<to><icast><c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.reShape._DepthArray.DepthArray_Impl_" params="" file="src/trilateral3/reShape/DepthArray.hx" private="1" module="trilateral3.reShape.DepthArray" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="arr">
			<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
			<x path="trilateral3.reShape.DepthArray"><c path="trilateral3.reShape.DepthArray.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<rangeToEnd public="1" set="method" line="9" static="1">
		<f a="this:starting:totalLen">
			<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rangeToEnd>
	<rangeToStart public="1" get="inline" set="null" line="30" static="1">
		<f a="this:starting:totalLen">
			<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</rangeToStart>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.reShape._DepthArray.DepthArray_Impl_" params="" file="src/trilateral3/reShape/DepthArray.hx" private="1" module="trilateral3.reShape.DepthArray" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="arr">
				<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
				<x path="trilateral3.reShape.DepthArray"><c path="trilateral3.reShape.DepthArray.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<rangeToEnd public="1" set="method" line="9" static="1">
			<f a="this:starting:totalLen">
				<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rangeToEnd>
		<rangeToStart public="1" get="inline" set="null" line="30" static="1">
			<f a="this:starting:totalLen">
				<c path="Array"><c path="trilateral3.reShape.DepthArray.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</rangeToStart>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.reShape.NineShaper" params="" file="src/trilateral3/reShape/NineShaper.hx">
		<tri><c path="trilateral3.reShape.TrianglesShaper"/></tri>
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<start><x path="Int"/></start>
		<right><x path="Float"/></right>
		<left><x path="Float"/></left>
		<top><x path="Float"/></top>
		<bottom><x path="Float"/></bottom>
		<quadShaper><c path="trilateral3.reShape.QuadShaper"/></quadShaper>
		<XYWH public="1" get="inline" set="null" line="34"><f a="xywh">
	<a>
		<y><x path="Float"/></y>
		<x><x path="Float"/></x>
		<w><x path="Float"/></w>
		<h><x path="Float"/></h>
	</a>
	<x path="Void"/>
</f></XYWH>
		<new public="1" set="method" line="21">
			<f a="pen:start:?wid:?hi" v="::1000:1000">
				<c path="trilateral3.drawing.Pen"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hi : 1000, wid : 1000 }</e></m></meta>
		</new>
	</class>
	<class path="trilateral3.reShape.QuadDepth" params="" file="src/trilateral3/reShape/QuadDepth.hx">
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<space public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</space>
		<orderCount public="1" expr="new DepthArray(new Array&lt;Int&gt;())">
			<x path="trilateral3.reShape.DepthArray"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[new DepthArray(new Array<Int>())]]></e></m></meta>
		</orderCount>
		<depthPieces public="1" expr="new DepthArray(new Array&lt;QuadShaper&gt;())">
			<x path="trilateral3.reShape.DepthArray"><c path="trilateral3.reShape.QuadShaper"/></x>
			<meta><m n=":value"><e><![CDATA[new DepthArray(new Array<QuadShaper>())]]></e></m></meta>
		</depthPieces>
		<origPos public="1" expr="new Array&lt;XY&gt;()">
			<c path="Array"><c path="trilateral3.structure.XY"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<XY>()]]></e></m></meta>
		</origPos>
		<range public="1"><x path="trilateral3.shape.IteratorRange"/></range>
		<quadRange public="1"><x path="trilateral3.shape.IteratorRange"/></quadRange>
		<topLast public="1"><x path="Int"/></topLast>
		<last public="1"><x path="Int"/></last>
		<traceBegins public="1" set="method" line="21"><f a="w">
	<x path="Int"/>
	<x path="Void"/>
</f></traceBegins>
		<traceOrderCount public="1" set="method" line="35"><f a="w">
	<x path="Int"/>
	<x path="Void"/>
</f></traceOrderCount>
		<addQuad get="inline" set="null" line="49"><f a="dx:dy:w:h:u:v:col:row:count">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addQuad>
		<grid public="1" set="method" line="67"><f a="x:y:dw:dh:nW:nH">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></grid>
		<deltaXY public="1" set="method" line="96"><f a="id:dx:dy">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></deltaXY>
		<setXY public="1" set="method" line="103"><f a="id:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setXY>
		<getXY public="1" set="method" line="106"><f a="id">
	<x path="Int"/>
	<c path="trilateral3.structure.XY"/>
</f></getXY>
		<argbQuad public="1" set="method" line="109"><f a="id:argb">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></argbQuad>
		<alphaQuad public="1" set="method" line="112"><f a="id:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></alphaQuad>
		<hideQuad public="1" set="method" line="115"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></hideQuad>
		<showQuad public="1" set="method" line="118"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></showQuad>
		<fullHit public="1" set="method" line="121"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Int"/></c>
</f></fullHit>
		<getQuad public="1" set="method" line="136"><f a="countNo">
	<x path="Int"/>
	<c path="trilateral3.reShape.QuadShaper"/>
</f></getQuad>
		<depthIndex public="1" get="inline" set="null" line="140"><f a="countNo">
	<x path="Int"/>
	<x path="Int"/>
</f></depthIndex>
		<toTopCount public="1" set="method" line="144"><f a="countNo">
	<x path="Int"/>
	<x path="Void"/>
</f></toTopCount>
		<getLast public="1" set="method" line="149"><f a=""><x path="Int"/></f></getLast>
		<getPenultimate public="1" set="method" line="153"><f a=""><x path="Int"/></f></getPenultimate>
		<toTop public="1" set="method" line="157"><f a="pieceNo">
	<x path="Int"/>
	<x path="Void"/>
</f></toTop>
		<justLocalTop public="1" set="method" line="166"><f a="countNo">
	<x path="Int"/>
	<x path="Void"/>
</f></justLocalTop>
		<toBottomCount public="1" set="method" line="173"><f a="countNo">
	<x path="Int"/>
	<x path="Void"/>
</f></toBottomCount>
		<toBottom public="1" set="method" line="178"><f a="pieceNo">
	<x path="Int"/>
	<x path="Void"/>
</f></toBottom>
		<setStart get="inline" set="null" line="187"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="trilateral3.shape.IteratorRange"/>
</f></setStart>
		<setEnd get="inline" set="null" line="191"><f a="v:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="trilateral3.shape.IteratorRange"/>
</f></setEnd>
		<updateStarts set="method" line="196"><f a=""><x path="Void"/></f></updateStarts>
		<new public="1" set="method" line="17"><f a="pen_">
	<c path="trilateral3.drawing.Pen"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="trilateral3.reShape.QuadShaper" params="" file="src/trilateral3/reShape/QuadShaper.hx">
		<tri><c path="trilateral3.reShape.TrianglesShaper"/></tri>
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<lastXY public="1"><c path="trilateral3.structure.XY"/></lastXY>
		<lastUV public="1"><c path="trilateral3.structure.XY"/></lastUV>
		<oldStart><x path="Int"/></oldStart>
		<start><x path="Int"/></start>
		<name public="1"><c path="String"/></name>
		<begin public="1" get="accessor" set="accessor"><x path="Int"/></begin>
		<get_begin get="inline" set="null" line="23"><f a=""><x path="Int"/></f></get_begin>
		<set_begin get="inline" set="null" line="27"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_begin>
		<fullHit public="1" set="method" line="42"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></fullHit>
		<visible public="1" get="null" set="accessor"><x path="Bool"/></visible>
		<set_visible get="inline" set="null" line="51"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<alpha public="1" get="null" set="accessor"><x path="Float"/></alpha>
		<set_alpha get="inline" set="null" line="67"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<argb public="1" get="null" set="accessor"><x path="Int"/></argb>
		<set_argb get="inline" set="null" line="76"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argb>
		<xy public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy>
		<get_xy get="inline" set="null" line="85"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy>
		<set_xy get="inline" set="null" line="89"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy>
		<xy0 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY0"/></xy0>
		<get_xy0 get="inline" set="null" line="102"><f a=""><c path="trilateral3.structure.XY0"/></f></get_xy0>
		<set_xy0 get="inline" set="null" line="106"><f a="val">
	<c path="trilateral3.structure.XY0"/>
	<c path="trilateral3.structure.XY0"/>
</f></set_xy0>
		<xy1 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy1>
		<get_xy1 get="inline" set="null" line="119"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy1>
		<set_xy1 get="inline" set="null" line="122"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy1>
		<xy2 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy2>
		<get_xy2 get="inline" set="null" line="135"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy2>
		<set_xy2 get="inline" set="null" line="138"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy2>
		<uv public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></uv>
		<get_uv get="inline" set="null" line="151"><f a=""><c path="trilateral3.structure.XY"/></f></get_uv>
		<set_uv get="inline" set="null" line="155"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_uv>
		<setXYWH public="1" set="method" line="168"><f a="xywh">
	<a>
		<y><x path="Float"/></y>
		<x><x path="Float"/></x>
		<w><x path="Float"/></w>
		<h><x path="Float"/></h>
	</a>
	<x path="Void"/>
</f></setXYWH>
		<setWH public="1" set="method" line="188"><f a="wh">
	<a>
		<w><x path="Float"/></w>
		<h><x path="Float"/></h>
	</a>
	<x path="Void"/>
</f></setWH>
		<updatePos public="1" set="method" line="192"><f a=""><x path="Void"/></f></updatePos>
		<new public="1" set="method" line="17">
			<f a="pen:start:?wid:?hi" v="::1000:1000">
				<c path="trilateral3.drawing.Pen"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hi : 1000, wid : 1000 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.reShape.RangeShaper" params="" file="src/trilateral3/reShape/RangeShaper.hx">
		<tri><c path="trilateral3.reShape.TrianglesShaper"/></tri>
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<range public="1"><x path="trilateral3.shape.IteratorRange"/></range>
		<px expr="10000000000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000000000</e></m></meta>
		</px>
		<py expr="10000000000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000000000</e></m></meta>
		</py>
		<pu expr="10000000000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000000000</e></m></meta>
		</pu>
		<pv expr="10000000000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000000000</e></m></meta>
		</pv>
		<fullHit public="1" set="method" line="29"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Int"/></c>
</f></fullHit>
		<setColor public="1" set="method" line="42"><f a="col">
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<setXY public="1" set="method" line="48"><f a="xy">
	<c path="trilateral3.structure.XY"/>
	<x path="Void"/>
</f></setXY>
		<setUV public="1" set="method" line="59"><f a="xy">
	<c path="trilateral3.structure.XY"/>
	<x path="Void"/>
</f></setUV>
		<rotateAbout public="1" set="method" line="71"><f a="ax:ay:val">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateAbout>
		<new public="1" set="method" line="17">
			<f a="pen:iteratorRange:?wid:?hi" v="::1000:1000">
				<c path="trilateral3.drawing.Pen"/>
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hi : 1000, wid : 1000 }</e></m></meta>
		</new>
	</class>
	<class path="trilateral3.reShape.TrianglesShaper" params="" file="src/trilateral3/reShape/TrianglesShaper.hx">
		<pen><c path="trilateral3.drawing.Pen"/></pen>
		<hi><x path="Float"/></hi>
		<wid><x path="Float"/></wid>
		<curr public="1"><x path="trilateral3.drawing.TriangleAbstract"/></curr>
		<currUV public="1"><x path="trilateral3.drawing.TriangleAbstractUV"/></currUV>
		<curr3color public="1"><x path="trilateral3.drawing.Color3Abstract"/></curr3color>
		<start><x path="Int"/></start>
		<fullHit public="1" set="method" line="28"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></fullHit>
		<liteHit public="1" set="method" line="33"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></liteHit>
		<hide public="1" set="method" line="38"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="41"><f a=""><x path="Void"/></f></show>
		<alpha public="1" get="null" set="accessor"><x path="Float"/></alpha>
		<set_alpha get="inline" set="null" line="45"><f a="val">
	<x path="Float"/>
	<x path="Int"/>
</f></set_alpha>
		<argb public="1" get="accessor" set="accessor"><x path="Int"/></argb>
		<_argb expr="0xFFFFFFFF">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		</_argb>
		<set_argb get="inline" set="null" line="54"><f a="col">
	<x path="Int"/>
	<x path="Int"/>
</f></set_argb>
		<get_argb get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_argb>
		<rotateCentre2 public="1" set="method" line="65"><f a="vx:vy:ax:ay:val">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateCentre2>
		<rotateCentre public="1" set="method" line="69"><f a="vx:vy:val">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateCentre>
		<toGLx get="inline" set="null" line="72"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></toGLx>
		<toGLy get="inline" set="null" line="76"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></toGLy>
		<fromGLx get="inline" set="null" line="80"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></fromGLx>
		<fromGLy get="inline" set="null" line="84"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></fromGLy>
		<xy0 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY0"/></xy0>
		<get_xy0 get="inline" set="null" line="89"><f a=""><c path="trilateral3.structure.XY0"/></f></get_xy0>
		<set_xy0 get="inline" set="null" line="93"><f a="val">
	<c path="trilateral3.structure.XY0"/>
	<c path="trilateral3.structure.XY0"/>
</f></set_xy0>
		<xy1 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy1>
		<get_xy1 get="inline" set="null" line="100"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy1>
		<set_xy1 get="inline" set="null" line="104"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy1>
		<xy2 public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy2>
		<get_xy2 get="inline" set="null" line="109"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy2>
		<set_xy2 get="inline" set="null" line="113"><f a="val">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy2>
		<xy public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></xy>
		<get_xy get="inline" set="null" line="118"><f a=""><c path="trilateral3.structure.XY"/></f></get_xy>
		<set_xy get="inline" set="null" line="122"><f a="xy">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_xy>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<get_x get="inline" set="null" line="129"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="133"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<get_y get="inline" set="null" line="140"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="144"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<z public="1" get="accessor" set="accessor"><x path="Float"/></z>
		<get_z get="inline" set="null" line="151"><f a=""><x path="Float"/></f></get_z>
		<set_z get="inline" set="null" line="155"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<right public="1" get="accessor" set="null"><x path="Float"/></right>
		<get_right get="inline" set="null" line="161"><f a=""><x path="Float"/></f></get_right>
		<bottom public="1" get="accessor" set="null"><x path="Float"/></bottom>
		<get_bottom get="inline" set="null" line="166"><f a=""><x path="Float"/></f></get_bottom>
		<uv public="1" get="accessor" set="accessor"><c path="trilateral3.structure.XY"/></uv>
		<get_uv get="inline" set="null" line="171"><f a=""><c path="trilateral3.structure.XY"/></f></get_uv>
		<set_uv get="inline" set="null" line="175"><f a="xy">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
</f></set_uv>
		<u public="1" get="accessor" set="accessor"><x path="Float"/></u>
		<get_u get="inline" set="null" line="182"><f a=""><x path="Float"/></f></get_u>
		<set_u get="inline" set="null" line="186"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_u>
		<v public="1" get="accessor" set="accessor"><x path="Float"/></v>
		<get_v get="inline" set="null" line="193"><f a=""><x path="Float"/></f></get_v>
		<set_v get="inline" set="null" line="197"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_v>
		<new public="1" set="method" line="13">
			<f a="pen:?wid:?hi" v=":1000:1000">
				<c path="trilateral3.drawing.Pen"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hi : 1000, wid : 1000 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.shape.IndexRange" params="" file="src/trilateral3/shape/IndexRange.hx">
		<from><icast><c path="trilateral3.structure.StartEnd"/></icast></from>
		<this><c path="trilateral3.structure.StartEnd"/></this>
		<to><icast><c path="trilateral3.structure.StartEnd"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.shape._IndexRange.IndexRange_Impl_" params="" file="src/trilateral3/shape/IndexRange.hx" private="1" module="trilateral3.shape.IndexRange" final="1">
	<_new public="1" set="method" line="5" static="1">
		<f a="startEnd">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<adding public="1" get="inline" set="null" line="6" static="1">
		<f a="a:b">
			<x path="trilateral3.shape.IndexRange"/>
			<x path="trilateral3.shape.IndexRange"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</adding>
	<add public="1" get="inline" set="null" line="10" static="1">
		<f a="this:b">
			<c path="trilateral3.structure.StartEnd"/>
			<c path="trilateral3.structure.StartEnd"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</add>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="18" static="1">
		<f a="this">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<contains public="1" get="inline" set="null" line="22" static="1">
		<f a="this:v">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</contains>
	<isWithin public="1" get="inline" set="null" line="26" static="1">
		<f a="this:ir">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="trilateral3.shape.IndexRange"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</isWithin>
	<moveRange public="1" get="inline" set="null" line="30" static="1">
		<f a="this:v">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveRange>
	<ifContainMove public="1" get="inline" set="null" line="35" static="1">
		<f a="this:v:amount">
			<c path="trilateral3.structure.StartEnd"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</ifContainMove>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.shape._IndexRange.IndexRange_Impl_" params="" file="src/trilateral3/shape/IndexRange.hx" private="1" module="trilateral3.shape.IndexRange" final="1">
		<_new public="1" set="method" line="5" static="1">
			<f a="startEnd">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<adding public="1" get="inline" set="null" line="6" static="1">
			<f a="a:b">
				<x path="trilateral3.shape.IndexRange"/>
				<x path="trilateral3.shape.IndexRange"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</adding>
		<add public="1" get="inline" set="null" line="10" static="1">
			<f a="this:b">
				<c path="trilateral3.structure.StartEnd"/>
				<c path="trilateral3.structure.StartEnd"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</add>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="18" static="1">
			<f a="this">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<contains public="1" get="inline" set="null" line="22" static="1">
			<f a="this:v">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</contains>
		<isWithin public="1" get="inline" set="null" line="26" static="1">
			<f a="this:ir">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="trilateral3.shape.IndexRange"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</isWithin>
		<moveRange public="1" get="inline" set="null" line="30" static="1">
			<f a="this:v">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveRange>
		<ifContainMove public="1" get="inline" set="null" line="35" static="1">
			<f a="this:v:amount">
				<c path="trilateral3.structure.StartEnd"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</ifContainMove>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="trilateral3.shape.IntIterStart" params="" file="src/trilateral3/shape/IteratorRange.hx" module="trilateral3.shape.IteratorRange">
		<start public="1"><x path="Int"/></start>
		<max public="1"><x path="Int"/></max>
		<new public="1" set="method" line="7"><f a="min_:max_">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
		</meta>
	</class>
	<abstract path="trilateral3.shape.IteratorRange" params="" file="src/trilateral3/shape/IteratorRange.hx">
		<from>
			<icast><c path="trilateral3.shape.IntIterStart"/></icast>
			<icast field="fromIterator"><c path="IntIterator"/></icast>
		</from>
		<this><c path="trilateral3.shape.IntIterStart"/></this>
		<to><icast field="toIterStart"><x path="trilateral3.shape.IteratorRange"/></icast></to>
		<meta>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
			<m n=":forward"/>
		</meta>
		<impl><class path="trilateral3.shape._IteratorRange.IteratorRange_Impl_" params="" file="src/trilateral3/shape/IteratorRange.hx" private="1" module="trilateral3.shape.IteratorRange" final="1">
	<_new public="1" get="inline" set="null" line="15" static="1">
		<f a="min:max">
			<x path="Int"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromIterator public="1" get="inline" set="null" line="20" static="1">
		<f a="ii">
			<c path="IntIterator"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromIterator>
	<toIterStart set="method" line="25" static="1">
		<f a="this">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIterStart>
	<iterator public="1" get="inline" set="null" line="28" static="1">
		<f a="this">
			<c path="trilateral3.shape.IntIterStart"/>
			<c path="IntIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<adding public="1" get="inline" set="null" line="31" static="1">
		<f a="a:b">
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</adding>
	<add public="1" get="inline" set="null" line="35" static="1">
		<f a="this:b">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</add>
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<get_length get="inline" set="null" line="43" static="1">
		<f a="this">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<set_length get="inline" set="null" line="47" static="1">
		<f a="this:l">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_length>
	<contains public="1" get="inline" set="null" line="52" static="1">
		<f a="this:v">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</contains>
	<isWithin public="1" get="inline" set="null" line="56" static="1">
		<f a="this:ir">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</isWithin>
	<moveRange public="1" get="inline" set="null" line="60" static="1">
		<f a="this:v">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</moveRange>
	<addAssign public="1" get="inline" set="null" line="66" static="1">
		<f a="a:v">
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A += B</e></m></meta>
	</addAssign>
	<minusAssign public="1" get="inline" set="null" line="72" static="1">
		<f a="a:v">
			<x path="trilateral3.shape.IteratorRange"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A -= B</e></m></meta>
	</minusAssign>
	<ifContainMove public="1" get="inline" set="null" line="76" static="1">
		<f a="this:v:amount">
			<c path="trilateral3.shape.IntIterStart"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</ifContainMove>
	<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.shape._IteratorRange.IteratorRange_Impl_" params="" file="src/trilateral3/shape/IteratorRange.hx" private="1" module="trilateral3.shape.IteratorRange" final="1">
		<_new public="1" get="inline" set="null" line="15" static="1">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromIterator public="1" get="inline" set="null" line="20" static="1">
			<f a="ii">
				<c path="IntIterator"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromIterator>
		<toIterStart set="method" line="25" static="1">
			<f a="this">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIterStart>
		<iterator public="1" get="inline" set="null" line="28" static="1">
			<f a="this">
				<c path="trilateral3.shape.IntIterStart"/>
				<c path="IntIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<adding public="1" get="inline" set="null" line="31" static="1">
			<f a="a:b">
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</adding>
		<add public="1" get="inline" set="null" line="35" static="1">
			<f a="this:b">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</add>
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<get_length get="inline" set="null" line="43" static="1">
			<f a="this">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<set_length get="inline" set="null" line="47" static="1">
			<f a="this:l">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_length>
		<contains public="1" get="inline" set="null" line="52" static="1">
			<f a="this:v">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</contains>
		<isWithin public="1" get="inline" set="null" line="56" static="1">
			<f a="this:ir">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</isWithin>
		<moveRange public="1" get="inline" set="null" line="60" static="1">
			<f a="this:v">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</moveRange>
		<addAssign public="1" get="inline" set="null" line="66" static="1">
			<f a="a:v">
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A += B</e></m></meta>
		</addAssign>
		<minusAssign public="1" get="inline" set="null" line="72" static="1">
			<f a="a:v">
				<x path="trilateral3.shape.IteratorRange"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A -= B</e></m></meta>
		</minusAssign>
		<ifContainMove public="1" get="inline" set="null" line="76" static="1">
			<f a="this:v:amount">
				<c path="trilateral3.shape.IntIterStart"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</ifContainMove>
		<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
	</class>
	<abstract path="trilateral3.shape.PolyEdge" params="" file="src/trilateral3/shape/PolyEdge.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.shape._PolyEdge.PolyEdge_Impl_" params="" file="src/trilateral3/shape/PolyEdge.hx" private="1" module="trilateral3.shape.PolyEdge" extern="1" final="1">
	<triangle public="1" get="inline" set="null" expr="cast 3" line="3" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</triangle>
	<quadrilateral public="1" get="inline" set="null" expr="cast 4" line="4" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</quadrilateral>
	<tetragon public="1" get="inline" set="null" expr="cast 4" line="6" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</tetragon>
	<pentagon public="1" get="inline" set="null" expr="cast 5" line="7" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</pentagon>
	<hexagon public="1" get="inline" set="null" expr="cast 6" line="8" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</hexagon>
	<heptagon public="1" get="inline" set="null" expr="cast 7" line="9" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</heptagon>
	<septagon public="1" get="inline" set="null" expr="cast 7" line="10" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</septagon>
	<octagon public="1" get="inline" set="null" expr="cast 8" line="11" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</octagon>
	<nonagon public="1" get="inline" set="null" expr="cast 9" line="12" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</nonagon>
	<enneagon public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</enneagon>
	<decagon public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</decagon>
	<hendecagon public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</hendecagon>
	<undecagon public="1" get="inline" set="null" expr="cast 11" line="16" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</undecagon>
	<dodecagon public="1" get="inline" set="null" expr="cast 12" line="17" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</dodecagon>
	<dozen public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</dozen>
	<triskaidecagon public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</triskaidecagon>
	<tetrakaidecagon public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</tetrakaidecagon>
	<pentadecagon public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</pentadecagon>
	<hexakaidecagon public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</hexakaidecagon>
	<heptadecagon public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</heptadecagon>
	<octakaidecagon public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</octakaidecagon>
	<enneadecagon public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</enneadecagon>
	<icosagon public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</icosagon>
	<triacontagon public="1" get="inline" set="null" expr="cast 30" line="27" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</triacontagon>
	<tetracontagon public="1" get="inline" set="null" expr="cast 40" line="28" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</tetracontagon>
	<pentacontagon public="1" get="inline" set="null" expr="cast 50" line="29" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</pentacontagon>
	<hexacontagon public="1" get="inline" set="null" expr="cast 60" line="30" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</hexacontagon>
	<heptacontagon public="1" get="inline" set="null" expr="cast 70" line="31" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</heptacontagon>
	<octacontagon public="1" get="inline" set="null" expr="cast 80" line="32" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</octacontagon>
	<enneacontagon public="1" get="inline" set="null" expr="cast 90" line="33" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</enneacontagon>
	<hectagon public="1" get="inline" set="null" expr="cast 100" line="34" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</hectagon>
	<chiliagon public="1" get="inline" set="null" expr="cast 1000" line="35" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 1000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</chiliagon>
	<myriagon public="1" get="inline" set="null" expr="cast 10000" line="36" static="1">
		<x path="trilateral3.shape.PolyEdge"/>
		<meta>
			<m n=":value"><e>cast 10000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</myriagon>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.shape._PolyEdge.PolyEdge_Impl_" params="" file="src/trilateral3/shape/PolyEdge.hx" private="1" module="trilateral3.shape.PolyEdge" extern="1" final="1">
		<triangle public="1" get="inline" set="null" expr="cast 3" line="3" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</triangle>
		<quadrilateral public="1" get="inline" set="null" expr="cast 4" line="4" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</quadrilateral>
		<tetragon public="1" get="inline" set="null" expr="cast 4" line="6" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</tetragon>
		<pentagon public="1" get="inline" set="null" expr="cast 5" line="7" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</pentagon>
		<hexagon public="1" get="inline" set="null" expr="cast 6" line="8" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</hexagon>
		<heptagon public="1" get="inline" set="null" expr="cast 7" line="9" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</heptagon>
		<septagon public="1" get="inline" set="null" expr="cast 7" line="10" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</septagon>
		<octagon public="1" get="inline" set="null" expr="cast 8" line="11" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</octagon>
		<nonagon public="1" get="inline" set="null" expr="cast 9" line="12" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</nonagon>
		<enneagon public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</enneagon>
		<decagon public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</decagon>
		<hendecagon public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</hendecagon>
		<undecagon public="1" get="inline" set="null" expr="cast 11" line="16" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</undecagon>
		<dodecagon public="1" get="inline" set="null" expr="cast 12" line="17" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</dodecagon>
		<dozen public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</dozen>
		<triskaidecagon public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</triskaidecagon>
		<tetrakaidecagon public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</tetrakaidecagon>
		<pentadecagon public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</pentadecagon>
		<hexakaidecagon public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</hexakaidecagon>
		<heptadecagon public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</heptadecagon>
		<octakaidecagon public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</octakaidecagon>
		<enneadecagon public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</enneadecagon>
		<icosagon public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</icosagon>
		<triacontagon public="1" get="inline" set="null" expr="cast 30" line="27" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</triacontagon>
		<tetracontagon public="1" get="inline" set="null" expr="cast 40" line="28" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</tetracontagon>
		<pentacontagon public="1" get="inline" set="null" expr="cast 50" line="29" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</pentacontagon>
		<hexacontagon public="1" get="inline" set="null" expr="cast 60" line="30" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</hexacontagon>
		<heptacontagon public="1" get="inline" set="null" expr="cast 70" line="31" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</heptacontagon>
		<octacontagon public="1" get="inline" set="null" expr="cast 80" line="32" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</octacontagon>
		<enneacontagon public="1" get="inline" set="null" expr="cast 90" line="33" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</enneacontagon>
		<hectagon public="1" get="inline" set="null" expr="cast 100" line="34" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</hectagon>
		<chiliagon public="1" get="inline" set="null" expr="cast 1000" line="35" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 1000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</chiliagon>
		<myriagon public="1" get="inline" set="null" expr="cast 10000" line="36" static="1">
			<x path="trilateral3.shape.PolyEdge"/>
			<meta>
				<m n=":value"><e>cast 10000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</myriagon>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="trilateral3.shape.Regular" params="" file="src/trilateral3/shape/Regular.hx">
		<from><icast><c path="trilateral3.drawing.Pen"/></icast></from>
		<this><c path="trilateral3.drawing.Pen"/></this>
		<to><icast><c path="trilateral3.drawing.Pen"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.shape._Regular.Regular_Impl_" params="" file="src/trilateral3/shape/Regular.hx" private="1" module="trilateral3.shape.Regular" final="1">
	<_new public="1" set="method" line="7" static="1">
		<f a="pen_">
			<c path="trilateral3.drawing.Pen"/>
			<x path="trilateral3.shape.Regular"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<addRegular public="1" get="inline" set="null" line="10" static="1">
		<f a="this:rs:style">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.StyleRegular"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addRegular>
	<triangle public="1" get="inline" set="null" line="32" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</triangle>
	<triangle2 public="1" get="inline" set="null" line="36" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</triangle2>
	<square public="1" get="inline" set="null" line="43" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</square>
	<square2 public="1" get="inline" set="null" line="47" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</square2>
	<bar public="1" get="inline" set="null" line="54" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</bar>
	<colorTrianglesPos public="1" get="inline" set="null" line="64" static="1">
		<f a="this:start:col:len">
			<c path="trilateral3.drawing.Pen"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</colorTrianglesPos>
	<bar2 public="1" get="inline" set="null" line="69" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</bar2>
	<pentagon public="1" get="inline" set="null" line="76" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</pentagon>
	<pentagon2 public="1" get="inline" set="null" line="80" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</pentagon2>
	<hexagon public="1" get="inline" set="null" line="87" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexagon>
	<hexagon2 public="1" get="inline" set="null" line="91" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hexagon2>
	<circle public="1" get="inline" set="null" line="98" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</circle>
	<circle2 public="1" get="inline" set="null" line="102" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</circle2>
	<circleRadial public="1" get="inline" set="null" line="109" static="1">
		<f a="this:rs:colorCentre:rx:ry">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</circleRadial>
	<circleRadial2 public="1" get="inline" set="null" line="113" static="1">
		<f a="this:rs:colorCentre:rx:ry">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</circleRadial2>
	<roundedSquare public="1" get="inline" set="null" line="120" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</roundedSquare>
	<roundedSquare2 public="1" get="inline" set="null" line="129" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</roundedSquare2>
	<star public="1" get="inline" set="null" line="136" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</star>
	<star2 public="1" get="inline" set="null" line="145" static="1">
		<f a="this:rs">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</star2>
	<polygon public="1" get="inline" set="null" line="152" static="1">
		<f a="this:rs:?sides" v="::36">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ sides : 36 }</e></m>
			<m n=":impl"/>
		</meta>
	</polygon>
	<polygonRadial public="1" get="inline" set="null" line="161" static="1">
		<f a="this:rs:colorCentre:rx:ry:?sides" v=":::::36">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ sides : 36 }</e></m>
			<m n=":impl"/>
		</meta>
	</polygonRadial>
	<circleMultiCorners public="1" get="inline" set="null" line="170" static="1">
		<f a="this:rs:arr:?rx:?ry" v=":::0:0">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<c path="Array"><x path="Int"/></c>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ ry : 0, rx : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</circleMultiCorners>
	<polygonMultiCorners public="1" get="inline" set="null" line="174" static="1">
		<f a="this:rs:arr:?rx:?ry:?sides" v=":::0:0:36">
			<c path="trilateral3.drawing.Pen"/>
			<c path="trilateral3.structure.RegularShape"/>
			<c path="Array"><x path="Int"/></c>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ sides : 36, ry : 0, rx : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</polygonMultiCorners>
</class></impl>
	</abstract>
	<class path="trilateral3.shape._Regular.Regular_Impl_" params="" file="src/trilateral3/shape/Regular.hx" private="1" module="trilateral3.shape.Regular" final="1">
		<_new public="1" set="method" line="7" static="1">
			<f a="pen_">
				<c path="trilateral3.drawing.Pen"/>
				<x path="trilateral3.shape.Regular"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<addRegular public="1" get="inline" set="null" line="10" static="1">
			<f a="this:rs:style">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.StyleRegular"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addRegular>
		<triangle public="1" get="inline" set="null" line="32" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</triangle>
		<triangle2 public="1" get="inline" set="null" line="36" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</triangle2>
		<square public="1" get="inline" set="null" line="43" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</square>
		<square2 public="1" get="inline" set="null" line="47" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</square2>
		<bar public="1" get="inline" set="null" line="54" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</bar>
		<colorTrianglesPos public="1" get="inline" set="null" line="64" static="1">
			<f a="this:start:col:len">
				<c path="trilateral3.drawing.Pen"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</colorTrianglesPos>
		<bar2 public="1" get="inline" set="null" line="69" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</bar2>
		<pentagon public="1" get="inline" set="null" line="76" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</pentagon>
		<pentagon2 public="1" get="inline" set="null" line="80" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</pentagon2>
		<hexagon public="1" get="inline" set="null" line="87" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexagon>
		<hexagon2 public="1" get="inline" set="null" line="91" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hexagon2>
		<circle public="1" get="inline" set="null" line="98" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</circle>
		<circle2 public="1" get="inline" set="null" line="102" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</circle2>
		<circleRadial public="1" get="inline" set="null" line="109" static="1">
			<f a="this:rs:colorCentre:rx:ry">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</circleRadial>
		<circleRadial2 public="1" get="inline" set="null" line="113" static="1">
			<f a="this:rs:colorCentre:rx:ry">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</circleRadial2>
		<roundedSquare public="1" get="inline" set="null" line="120" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</roundedSquare>
		<roundedSquare2 public="1" get="inline" set="null" line="129" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</roundedSquare2>
		<star public="1" get="inline" set="null" line="136" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</star>
		<star2 public="1" get="inline" set="null" line="145" static="1">
			<f a="this:rs">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</star2>
		<polygon public="1" get="inline" set="null" line="152" static="1">
			<f a="this:rs:?sides" v="::36">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ sides : 36 }</e></m>
				<m n=":impl"/>
			</meta>
		</polygon>
		<polygonRadial public="1" get="inline" set="null" line="161" static="1">
			<f a="this:rs:colorCentre:rx:ry:?sides" v=":::::36">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ sides : 36 }</e></m>
				<m n=":impl"/>
			</meta>
		</polygonRadial>
		<circleMultiCorners public="1" get="inline" set="null" line="170" static="1">
			<f a="this:rs:arr:?rx:?ry" v=":::0:0">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ ry : 0, rx : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</circleMultiCorners>
		<polygonMultiCorners public="1" get="inline" set="null" line="174" static="1">
			<f a="this:rs:arr:?rx:?ry:?sides" v=":::0:0:36">
				<c path="trilateral3.drawing.Pen"/>
				<c path="trilateral3.structure.RegularShape"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ sides : 36, ry : 0, rx : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</polygonMultiCorners>
	</class>
	<class path="trilateral3.shape.Shaper" params="" file="src/trilateral3/shape/Shaper.hx">
		<add2DTriangle_ public="1" expr="add2DTriangle">
			<f a="drawType:ax:ay:bx:by:cx:cy">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>add2DTriangle</e></m></meta>
		</add2DTriangle_>
		<add2DQuad_ public="1" expr="add2DQuad">
			<f a="drawType:ax:ay:bx:by:cx:cy:dx:dy">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>add2DQuad</e></m></meta>
		</add2DQuad_>
		<quad_ public="1" expr="quad">
			<f a="drawType:q">
				<t path="trilateral3.drawing.DrawType"/>
				<c path="trilateral3.structure.Quad2D"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>quad</e></m></meta>
		</quad_>
		<lineAB_ public="1" expr="lineAB">
			<f a="drawType:A:B:width">
				<t path="trilateral3.drawing.DrawType"/>
				<c path="trilateral3.structure.XY"/>
				<c path="trilateral3.structure.XY"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>lineAB</e></m></meta>
		</lineAB_>
		<lineXY_ public="1" expr="lineXY">
			<f a="drawType:ax:ay:bx:by:width">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>lineXY</e></m></meta>
		</lineXY_>
		<rectangle_ public="1" expr="rectangle">
			<f a="drawType:x:y:w:h">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>rectangle</e></m></meta>
		</rectangle_>
		<squareOutline_ public="1" expr="squareOutline">
			<f a="drawType:px:py:radius:thick:?theta">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>squareOutline</e></m></meta>
		</squareOutline_>
		<square_ public="1" expr="square">
			<f a="drawType:px:py:radius:?theta">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>square</e></m></meta>
		</square_>
		<diamond_ public="1" expr="diamond">
			<f a="drawType:x:y:radius:?theta">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>diamond</e></m></meta>
		</diamond_>
		<diamondOutline_ public="1" expr="diamondOutline">
			<f a="drawType:x:y:thick:radius:?theta">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>diamondOutline</e></m></meta>
		</diamondOutline_>
		<overlapStar_ public="1" expr="overlapStar">
			<f a="drawType:px:py:radius:?theta">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>overlapStar</e></m></meta>
		</overlapStar_>
		<circle_ public="1" expr="circle">
			<f a="drawType:ax:ay:radius:?sides:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>circle</e></m></meta>
		</circle_>
		<circleRadial_ public="1" expr="circleRadial">
			<f a="drawType:ax:ay:rx:ry:radius:?sides:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>circleRadial</e></m></meta>
		</circleRadial_>
		<circleRadialOnSide_ public="1" expr="circleRadialOnSide">
			<f a="drawType:ax:ay:rx:ry:radius:?sides:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>circleRadialOnSide</e></m></meta>
		</circleRadialOnSide_>
		<ellipse_ public="1" expr="ellipse">
			<f a="drawType:ax:ay:rx:ry:sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>ellipse</e></m></meta>
		</ellipse_>
		<pie_ public="1" expr="pie">
			<f a="drawType:ax:ay:radius:beta:gamma:prefer:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>pie</e></m></meta>
		</pie_>
		<pieX_ public="1" expr="pieX">
			<f a="drawType:ax:ay:radius:beta:gamma:prefer:edgePoly:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>pieX</e></m></meta>
		</pieX_>
		<pieDifX_ public="1" expr="pieDifX">
			<f a="drawType:ax:ay:radius:beta:dif:edgePoly:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>pieDifX</e></m></meta>
		</pieDifX_>
		<ellpisePie_ public="1" expr="ellipsePie">
			<f a="drawType:ax:ay:rx:ry:beta:gamma:prefer:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>ellipsePie</e></m></meta>
		</ellpisePie_>
		<pieDif_ public="1" expr="pieDif">
			<f a="drawType:ax:ay:radius:beta:dif:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>pieDif</e></m></meta>
		</pieDif_>
		<arc_ public="1" expr="arc">
			<f a="drawType:ax:ay:radius:width:beta:gamma:prefer:?sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>arc</e></m></meta>
		</arc_>
		<circleOnSide_ public="1" expr="circleOnSide">
			<f a="drawType:ax:ay:radius:?sides:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>circleOnSide</e></m></meta>
		</circleOnSide_>
		<ellipseOnSide_ public="1" expr="ellipseOnSide">
			<f a="drawType:ax:ay:rx:ry:sides">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>ellipseOnSide</e></m></meta>
		</ellipseOnSide_>
		<shape_ public="1" expr="shape">
			<f a="drawType:x:y:radius:p:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.PolyEdge"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>shape</e></m></meta>
		</shape_>
		<shapeRadial_ public="1" expr="shapeRadial">
			<f a="drawType:x:y:rx:ry:radius:p:?omega">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.PolyEdge"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>shapeRadial</e></m></meta>
		</shapeRadial_>
		<roundedRectangle_ public="1" expr="roundedRectangle">
			<f a="drawType:x:y:width:height:radius">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>roundedRectangle</e></m></meta>
		</roundedRectangle_>
		<roundedRectangleOutline_ public="1" expr="roundedRectangleOutline">
			<f a="drawType:x:y:width:height:thick:radius">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>roundedRectangleOutline</e></m></meta>
		</roundedRectangleOutline_>
		<spiralLines_ public="1" expr="spiralLines">
			<f a="drawType:x:y:radius:nolines:startWid:stepWid">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>spiralLines</e></m></meta>
		</spiralLines_>
		<new public="1" set="method" line="735">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="trilateral3.shape._Shaper.Shaper_Fields_" params="" file="src/trilateral3/shape/Shaper.hx" private="1" module="trilateral3.shape.Shaper" final="1">
		<add2DTriangle public="1" get="inline" set="null" line="16" static="1">
			<f a="drawType:ax:ay:bx:by:cx:cy">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Shaper provides static methods for drawing with triangles.
the methods return the number of triangles added.</haxe_doc>
		</add2DTriangle>
		<add2DQuad public="1" get="inline" set="null" line="28" static="1"><f a="drawType:ax:ay:bx:by:cx:cy:dx:dy">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></add2DQuad>
		<quad public="1" get="inline" set="null" line="38" static="1"><f a="drawType:q">
	<t path="trilateral3.drawing.DrawType"/>
	<c path="trilateral3.structure.Quad2D"/>
	<x path="Int"/>
</f></quad>
		<lineAB public="1" get="inline" set="null" line="42" static="1"><f a="drawType:A:B:width">
	<t path="trilateral3.drawing.DrawType"/>
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Float"/>
	<x path="Int"/>
</f></lineAB>
		<lineXY public="1" get="inline" set="null" line="49" static="1"><f a="drawType:ax:ay:bx:by:width">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></lineXY>
		<rectangle public="1" get="inline" set="null" line="56" static="1"><f a="drawType:x:y:w:h">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></rectangle>
		<squareOutline public="1" get="inline" set="null" line="71" static="1">
			<f a="drawType:px:py:radius:thick:?theta" v=":::::0">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ theta : 0 }</e></m></meta>
		</squareOutline>
		<square public="1" get="inline" set="null" line="171" static="1">
			<f a="drawType:px:py:radius:?theta" v="::::0">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ theta : 0 }</e></m></meta>
		</square>
		<diamond public="1" get="inline" set="null" line="218" static="1">
			<f a="drawType:x:y:radius:?theta" v="::::0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ theta : 0. }</e></m></meta>
		</diamond>
		<diamondOutline public="1" get="inline" set="null" line="224" static="1">
			<f a="drawType:x:y:thick:radius:?theta" v=":::::0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ theta : 0. }</e></m></meta>
		</diamondOutline>
		<overlapStar public="1" get="inline" set="null" line="232" static="1">
			<f a="drawType:px:py:radius:?theta" v="::::0">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ theta : 0 }</e></m></meta>
		</overlapStar>
		<circle public="1" get="inline" set="null" line="262" static="1">
			<f a="drawType:ax:ay:radius:?sides:?omega" v="::::36:0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0., sides : 36 }</e></m></meta>
		</circle>
		<circleRadial public="1" get="inline" set="null" line="284" static="1">
			<f a="drawType:ax:ay:rx:ry:radius:?sides:?omega" v="::::::36:0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0., sides : 36 }</e></m></meta>
		</circleRadial>
		<circleRadialOnSide public="1" get="inline" set="null" line="313" static="1">
			<f a="drawType:ax:ay:rx:ry:radius:?sides:?omega" v="::::::36:0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0., sides : 36 }</e></m></meta>
		</circleRadialOnSide>
		<ellipse public="1" get="inline" set="null" line="347" static="1">
			<f a="drawType:ax:ay:rx:ry:?sides" v=":::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
		</ellipse>
		<pie public="1" get="inline" set="null" line="373" static="1">
			<f a="drawType:ax:ay:radius:beta:gamma:prefer:?sides" v=":::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
			<haxe_doc>* When calling Pie you can specify the DifferencePreference of what should be colored in terms of the two angles provided.
 * For example for drawing a packman shape you would want the use DifferencePreference.LARGE .</haxe_doc>
		</pie>
		<pieX public="1" get="inline" set="null" line="409" static="1">
			<f a="drawType:ax:ay:radius:beta:gamma:prefer:edgePoly:?sides" v="::::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
			<haxe_doc>* When calling Pie you can specify the DifferencePreference of what should be colored in terms of the two angles provided.
 * For example for drawing a packman shape you would want the use DifferencePreference.LARGE .</haxe_doc>
		</pieX>
		<pieDifX public="1" get="inline" set="null" line="449" static="1">
			<f a="drawType:ax:ay:radius:beta:dif:edgePoly:?sides" v=":::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
			<haxe_doc>* Optimized Pie used in Contour, with dif pre-calculated
 * External edge also added</haxe_doc>
		</pieDifX>
		<ellipsePie public="1" get="inline" set="null" line="484" static="1">
			<f a="drawType:ax:ay:rx:ry:beta:gamma:prefer:?sides" v="::::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
		</ellipsePie>
		<pieDif public="1" get="inline" set="null" line="520" static="1">
			<f a="drawType:ax:ay:radius:beta:dif:?sides" v="::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
			<haxe_doc>* Optimized Pie used in Contour, with dif pre-calculated</haxe_doc>
		</pieDif>
		<arc public="1" get="inline" set="null" line="549" static="1">
			<f a="drawType:ax:ay:radius:width:beta:gamma:prefer:?sides" v="::::::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="fracs.DifferencePreference"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
		</arc>
		<circleOnSide public="1" get="inline" set="null" line="589" static="1">
			<f a="drawType:ax:ay:radius:?sides:?omega" v="::::36:0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0., sides : 36 }</e></m></meta>
		</circleOnSide>
		<ellipseOnSide public="1" get="inline" set="null" line="612" static="1">
			<f a="drawType:ax:ay:rx:ry:?sides" v=":::::36">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ sides : 36 }</e></m></meta>
		</ellipseOnSide>
		<shape public="1" get="inline" set="null" line="635" static="1">
			<f a="drawType:x:y:radius:p:?omega" v=":::::0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.PolyEdge"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0. }</e></m></meta>
		</shape>
		<shapeRadial public="1" get="inline" set="null" line="645" static="1">
			<f a="drawType:x:y:rx:ry:radius:p:?omega" v=":::::::0.">
				<t path="trilateral3.drawing.DrawType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.PolyEdge"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ omega : 0. }</e></m></meta>
		</shapeRadial>
		<roundedRectangle public="1" get="inline" set="null" line="659" static="1"><f a="drawType:x:y:width:height:radius">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></roundedRectangle>
		<roundedRectangleOutline public="1" get="inline" set="null" line="689" static="1"><f a="drawType:x:y:width:height:thick:radius">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></roundedRectangleOutline>
		<spiralLines public="1" get="inline" set="null" line="720" static="1"><f a="drawType:x:y:radius:nolines:startWid:stepWid">
	<t path="trilateral3.drawing.DrawType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></spiralLines>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="trilateral3.shape.StyleRegular" params="" file="src/trilateral3/shape/StyleRegular.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="trilateral3.shape._StyleRegular.StyleRegular_Impl_" params="" file="src/trilateral3/shape/StyleRegular.hx" private="1" module="trilateral3.shape.StyleRegular" extern="1" final="1">
	<TRIANGLE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIANGLE>
	<SQUARE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SQUARE>
	<BAR public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BAR>
	<PENTAGON public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PENTAGON>
	<HEXAGON public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEXAGON>
	<CIRCLE public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CIRCLE>
	<ROUNDSQUARE public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUNDSQUARE>
	<STAR public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="trilateral3.shape.StyleRegular"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STAR>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="trilateral3.shape._StyleRegular.StyleRegular_Impl_" params="" file="src/trilateral3/shape/StyleRegular.hx" private="1" module="trilateral3.shape.StyleRegular" extern="1" final="1">
		<TRIANGLE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIANGLE>
		<SQUARE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SQUARE>
		<BAR public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BAR>
		<PENTAGON public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PENTAGON>
		<HEXAGON public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEXAGON>
		<CIRCLE public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CIRCLE>
		<ROUNDSQUARE public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUNDSQUARE>
		<STAR public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="trilateral3.shape.StyleRegular"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STAR>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="trilateral3.shape.xtra.DieSpots" params="" file="src/trilateral3/shape/xtra/DieSpots.hx">
		<from><icast><x path="trilateral3.shape.Regular"/></icast></from>
		<this><x path="trilateral3.shape.Regular"/></this>
		<to><icast><x path="trilateral3.shape.Regular"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.shape.xtra._DieSpots.DieSpots_Impl_" params="" file="src/trilateral3/shape/xtra/DieSpots.hx" private="1" module="trilateral3.shape.xtra.DieSpots" final="1">
	<_new public="1" set="method" line="9" static="1">
		<f a="regular">
			<x path="trilateral3.shape.Regular"/>
			<x path="trilateral3.shape.xtra.DieSpots"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<six2 public="1" get="inline" set="null" line="12" static="1">
		<f a="this:rs:?dx:?dy" v="::25:35">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
			<m n=":impl"/>
		</meta>
	</six2>
	<colorSix public="1" get="inline" set="null" line="44" static="1">
		<f a="this:rs:?dx:?dy" v="::25:35">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
			<m n=":impl"/>
		</meta>
	</colorSix>
	<five2 public="1" get="inline" set="null" line="76" static="1">
		<f a="this:rs:?dx:?dy" v="::30:30">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
			<m n=":impl"/>
		</meta>
	</five2>
	<four2 public="1" get="inline" set="null" line="103" static="1">
		<f a="this:rs:?dx:?dy" v="::30:30">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
			<m n=":impl"/>
		</meta>
	</four2>
	<three2 public="1" get="inline" set="null" line="127" static="1">
		<f a="this:rs:?dx:?dy" v="::25:25">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 25, dx : 25 }</e></m>
			<m n=":impl"/>
		</meta>
	</three2>
	<two2 public="1" get="inline" set="null" line="144" static="1">
		<f a="this:rs:?dx:?dy" v="::20:20">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 20, dx : 20 }</e></m>
			<m n=":impl"/>
		</meta>
	</two2>
	<one2 public="1" get="inline" set="null" line="158" static="1">
		<f a="this:rs">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</one2>
	<six public="1" get="inline" set="null" line="164" static="1">
		<f a="this:rs:?dx:?dy" v="::25:35">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
			<m n=":impl"/>
		</meta>
	</six>
	<five public="1" get="inline" set="null" line="196" static="1">
		<f a="this:rs:?dx:?dy" v="::30:30">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
			<m n=":impl"/>
		</meta>
	</five>
	<four public="1" get="inline" set="null" line="223" static="1">
		<f a="this:rs:?dx:?dy" v="::30:30">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
			<m n=":impl"/>
		</meta>
	</four>
	<three public="1" get="inline" set="null" line="247" static="1">
		<f a="this:rs:?dx:?dy" v="::25:25">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 25, dx : 25 }</e></m>
			<m n=":impl"/>
		</meta>
	</three>
	<two public="1" get="inline" set="null" line="264" static="1">
		<f a="this:rs:?dx:?dy" v="::20:20">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta>
			<m n=":value"><e>{ dy : 20, dx : 20 }</e></m>
			<m n=":impl"/>
		</meta>
	</two>
	<one public="1" get="inline" set="null" line="278" static="1">
		<f a="this:rs">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</one>
	<colorOne public="1" get="inline" set="null" line="284" static="1">
		<f a="this:rs">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</colorOne>
	<goldOne public="1" get="inline" set="null" line="290" static="1">
		<f a="this:rs">
			<x path="trilateral3.shape.Regular"/>
			<c path="trilateral3.structure.RegularShape"/>
			<x path="trilateral3.shape.IndexRange"/>
		</f>
		<meta><m n=":impl"/></meta>
	</goldOne>
</class></impl>
	</abstract>
	<class path="trilateral3.shape.xtra._DieSpots.DieSpots_Impl_" params="" file="src/trilateral3/shape/xtra/DieSpots.hx" private="1" module="trilateral3.shape.xtra.DieSpots" final="1">
		<_new public="1" set="method" line="9" static="1">
			<f a="regular">
				<x path="trilateral3.shape.Regular"/>
				<x path="trilateral3.shape.xtra.DieSpots"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<six2 public="1" get="inline" set="null" line="12" static="1">
			<f a="this:rs:?dx:?dy" v="::25:35">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
				<m n=":impl"/>
			</meta>
		</six2>
		<colorSix public="1" get="inline" set="null" line="44" static="1">
			<f a="this:rs:?dx:?dy" v="::25:35">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
				<m n=":impl"/>
			</meta>
		</colorSix>
		<five2 public="1" get="inline" set="null" line="76" static="1">
			<f a="this:rs:?dx:?dy" v="::30:30">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
				<m n=":impl"/>
			</meta>
		</five2>
		<four2 public="1" get="inline" set="null" line="103" static="1">
			<f a="this:rs:?dx:?dy" v="::30:30">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
				<m n=":impl"/>
			</meta>
		</four2>
		<three2 public="1" get="inline" set="null" line="127" static="1">
			<f a="this:rs:?dx:?dy" v="::25:25">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 25, dx : 25 }</e></m>
				<m n=":impl"/>
			</meta>
		</three2>
		<two2 public="1" get="inline" set="null" line="144" static="1">
			<f a="this:rs:?dx:?dy" v="::20:20">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 20, dx : 20 }</e></m>
				<m n=":impl"/>
			</meta>
		</two2>
		<one2 public="1" get="inline" set="null" line="158" static="1">
			<f a="this:rs">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</one2>
		<six public="1" get="inline" set="null" line="164" static="1">
			<f a="this:rs:?dx:?dy" v="::25:35">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 35, dx : 25 }</e></m>
				<m n=":impl"/>
			</meta>
		</six>
		<five public="1" get="inline" set="null" line="196" static="1">
			<f a="this:rs:?dx:?dy" v="::30:30">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
				<m n=":impl"/>
			</meta>
		</five>
		<four public="1" get="inline" set="null" line="223" static="1">
			<f a="this:rs:?dx:?dy" v="::30:30">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 30, dx : 30 }</e></m>
				<m n=":impl"/>
			</meta>
		</four>
		<three public="1" get="inline" set="null" line="247" static="1">
			<f a="this:rs:?dx:?dy" v="::25:25">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 25, dx : 25 }</e></m>
				<m n=":impl"/>
			</meta>
		</three>
		<two public="1" get="inline" set="null" line="264" static="1">
			<f a="this:rs:?dx:?dy" v="::20:20">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta>
				<m n=":value"><e>{ dy : 20, dx : 20 }</e></m>
				<m n=":impl"/>
			</meta>
		</two>
		<one public="1" get="inline" set="null" line="278" static="1">
			<f a="this:rs">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</one>
		<colorOne public="1" get="inline" set="null" line="284" static="1">
			<f a="this:rs">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</colorOne>
		<goldOne public="1" get="inline" set="null" line="290" static="1">
			<f a="this:rs">
				<x path="trilateral3.shape.Regular"/>
				<c path="trilateral3.structure.RegularShape"/>
				<x path="trilateral3.shape.IndexRange"/>
			</f>
			<meta><m n=":impl"/></meta>
		</goldOne>
	</class>
	<class path="trilateral3.structure.ARGB" params="" file="src/trilateral3/structure/ARGB.hx">
		<a public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</a>
		<r public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</r>
		<g public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</g>
		<b public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</b>
		<new public="1" set="method" line="11"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ a, r, g, b }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.CYMKA" params="" file="src/trilateral3/structure/CYMKA.hx">
		<c public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</c>
		<y public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<m public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</m>
		<k public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</k>
		<a public="1" expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":optional"/>
			</meta>
		</a>
		<new public="1" set="method" line="12"><f a="c:y:m:k:?a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ a, r, g, b }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.Quad2D" params="" file="src/trilateral3/structure/Quad2D.hx">
		<a public="1"><c path="trilateral3.structure.XY"/></a>
		<b public="1"><c path="trilateral3.structure.XY"/></b>
		<c public="1"><c path="trilateral3.structure.XY"/></c>
		<d public="1"><c path="trilateral3.structure.XY"/></d>
		<new set="method" line="9"><f a="a:b:c:d">
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<c path="trilateral3.structure.XY"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.RegularShape" params="" file="src/trilateral3/structure/RegularShape.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<radius public="1"><x path="Float"/></radius>
		<color public="1"><x path="Int"/></color>
		<clone public="1" set="method" line="14"><f a=""><c path="trilateral3.structure.RegularShape"/></f></clone>
		<new public="1" set="method" line="8"><f a="x:y:radius:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="trilateral3.structure.StartEnd" params="" file="src/trilateral3/structure/StartEnd.hx">
		<start public="1"><x path="Int"/></start>
		<end public="1"><x path="Int"/></end>
		<new public="1" set="method" line="6"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.TriInt" params="" file="src/trilateral3/structure/TriInt.hx">
		<a public="1"><x path="Int"/></a>
		<b public="1"><x path="Int"/></b>
		<c public="1"><x path="Int"/></c>
		<new public="1" set="method" line="7"><f a="a:b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.Triangle3D" params="" file="src/trilateral3/structure/Triangle3D.hx">
		<a public="1"><c path="trilateral3.matrix.Vertex"/></a>
		<b public="1"><c path="trilateral3.matrix.Vertex"/></b>
		<c public="1"><c path="trilateral3.matrix.Vertex"/></c>
		<new set="method" line="8"><f a="a:b:c">
	<c path="trilateral3.matrix.Vertex"/>
	<c path="trilateral3.matrix.Vertex"/>
	<c path="trilateral3.matrix.Vertex"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.TriangleUV" params="" file="src/trilateral3/structure/TriangleUV.hx">
		<a public="1"><c path="trilateral3.matrix.UV"/></a>
		<b public="1"><c path="trilateral3.matrix.UV"/></b>
		<c public="1"><c path="trilateral3.matrix.UV"/></c>
		<new set="method" line="8"><f a="a:b:c">
	<c path="trilateral3.matrix.UV"/>
	<c path="trilateral3.matrix.UV"/>
	<c path="trilateral3.matrix.UV"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.WH_" params="" file="src/trilateral3/structure/WH.hx" module="trilateral3.structure.WH">
		<w public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</w>
		<h public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</h>
		<new public="1" set="method" line="9"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ w, h }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="trilateral3.structure.WH" params="" file="src/trilateral3/structure/WH.hx">
		<from><icast><c path="trilateral3.structure.WH_"/></icast></from>
		<this><c path="trilateral3.structure.WH_"/></this>
		<to><icast><c path="trilateral3.structure.WH_"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.structure._WH.WH_Impl_" params="" file="src/trilateral3/structure/WH.hx" private="1" module="trilateral3.structure.WH" final="1">
	<_new public="1" get="inline" set="null" line="17" static="1">
		<f a="wh">
			<c path="trilateral3.structure.WH_"/>
			<x path="trilateral3.structure.WH"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<area public="1" get="inline" set="null" line="21" static="1">
		<f a="this">
			<c path="trilateral3.structure.WH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</area>
	<perimeter public="1" get="inline" set="null" line="25" static="1">
		<f a="this">
			<c path="trilateral3.structure.WH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</perimeter>
	<fits public="1" get="inline" set="null" line="29" static="1">
		<f a="this:r">
			<c path="trilateral3.structure.WH_"/>
			<x path="trilateral3.structure.WH"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fits>
</class></impl>
	</abstract>
	<class path="trilateral3.structure._WH.WH_Impl_" params="" file="src/trilateral3/structure/WH.hx" private="1" module="trilateral3.structure.WH" final="1">
		<_new public="1" get="inline" set="null" line="17" static="1">
			<f a="wh">
				<c path="trilateral3.structure.WH_"/>
				<x path="trilateral3.structure.WH"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<area public="1" get="inline" set="null" line="21" static="1">
			<f a="this">
				<c path="trilateral3.structure.WH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</area>
		<perimeter public="1" get="inline" set="null" line="25" static="1">
			<f a="this">
				<c path="trilateral3.structure.WH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</perimeter>
		<fits public="1" get="inline" set="null" line="29" static="1">
			<f a="this:r">
				<c path="trilateral3.structure.WH_"/>
				<x path="trilateral3.structure.WH"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fits>
	</class>
	<class path="trilateral3.structure.XY" params="" file="src/trilateral3/structure/XY.hx">
		<x public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x>
		<y public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y>
		<w public="1" expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":optional"/>
			</meta>
		</w>
		<clone public="1" set="method" line="14"><f a=""><c path="trilateral3.structure.XY"/></f></clone>
		<new public="1" set="method" line="10"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ x, y }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.XY0" params="" file="src/trilateral3/structure/XY0.hx">
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<w public="1" expr="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":optional"/>
			</meta>
		</w>
		<clone public="1" set="method" line="14"><f a=""><c path="trilateral3.structure.XY0"/></f></clone>
		<new public="1" set="method" line="10"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ x, y, ?w }</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="trilateral3.structure.XYWH_" params="" file="src/trilateral3/structure/XYWH.hx" module="trilateral3.structure.XYWH">
		<extends path="trilateral3.structure.WH_"/>
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<new public="1" set="method" line="10"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>{ x, y, w, h }</haxe_doc>
		<meta><m n=":structInit"/></meta>
	</class>
	<abstract path="trilateral3.structure.XYWH" params="" file="src/trilateral3/structure/XYWH.hx">
		<from><icast><c path="trilateral3.structure.XYWH_"/></icast></from>
		<this><c path="trilateral3.structure.XYWH_"/></this>
		<to><icast><c path="trilateral3.structure.XYWH_"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="trilateral3.structure._XYWH.XYWH_Impl_" params="" file="src/trilateral3/structure/XYWH.hx" private="1" module="trilateral3.structure.XYWH" final="1">
	<_new public="1" get="inline" set="null" line="19" static="1">
		<f a="xywh">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="trilateral3.structure.XYWH"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<r public="1" get="inline" set="null" line="23" static="1">
		<f a="this">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</r>
	<b public="1" get="inline" set="null" line="27" static="1">
		<f a="this">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</b>
	<setR public="1" get="inline" set="null" line="31" static="1">
		<f a="this:rr">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setR>
	<setB public="1" get="inline" set="null" line="35" static="1">
		<f a="this:bb">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setB>
	<mother get="inline" set="null" line="39" static="1">
		<f a="this">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="trilateral3.structure.WH"/>
		</f>
		<meta><m n=":impl"/></meta>
	</mother>
	<area public="1" get="inline" set="null" line="44" static="1">
		<f a="this">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</area>
	<perimeter public="1" get="inline" set="null" line="48" static="1">
		<f a="this">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</perimeter>
	<fits public="1" get="inline" set="null" line="52" static="1">
		<f a="this:r">
			<c path="trilateral3.structure.XYWH_"/>
			<x path="trilateral3.structure.WH"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</fits>
</class></impl>
	</abstract>
	<class path="trilateral3.structure._XYWH.XYWH_Impl_" params="" file="src/trilateral3/structure/XYWH.hx" private="1" module="trilateral3.structure.XYWH" final="1">
		<_new public="1" get="inline" set="null" line="19" static="1">
			<f a="xywh">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="trilateral3.structure.XYWH"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<r public="1" get="inline" set="null" line="23" static="1">
			<f a="this">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</r>
		<b public="1" get="inline" set="null" line="27" static="1">
			<f a="this">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</b>
		<setR public="1" get="inline" set="null" line="31" static="1">
			<f a="this:rr">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setR>
		<setB public="1" get="inline" set="null" line="35" static="1">
			<f a="this:bb">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setB>
		<mother get="inline" set="null" line="39" static="1">
			<f a="this">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="trilateral3.structure.WH"/>
			</f>
			<meta><m n=":impl"/></meta>
		</mother>
		<area public="1" get="inline" set="null" line="44" static="1">
			<f a="this">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</area>
		<perimeter public="1" get="inline" set="null" line="48" static="1">
			<f a="this">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</perimeter>
		<fits public="1" get="inline" set="null" line="52" static="1">
			<f a="this:r">
				<c path="trilateral3.structure.XYWH_"/>
				<x path="trilateral3.structure.WH"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</fits>
	</class>
	<class path="trilateral3.target.heaps.AppHeaps" params="" file="src/trilateral3/target/heaps/AppHeaps.hx">
		<extends path="hxd.App"/>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<nodule public="1" expr="new PenNodule(false)">
			<c path="trilateral3.nodule.PenNodule"/>
			<meta><m n=":value"><e>new PenNodule(false)</e></m></meta>
		</nodule>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<tri public="1"><x path="trilateral3.geom.FlatColorTriangles"/></tri>
		<g><c path="h2d.Graphics"/></g>
		<first expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</first>
		<init set="method" line="19" override="1"><f a=""><x path="Void"/></f></init>
		<internalSetup get="inline" set="null" line="26"><f a=""><x path="Void"/></f></internalSetup>
		<firstDraw get="inline" set="null" line="35"><f a=""><x path="Void"/></f></firstDraw>
		<draw public="1" set="method" line="41"><f a=""><x path="Void"/></f></draw>
		<render public="1" set="method" line="45" override="1"><f a="_">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<internalDraw get="inline" set="null" line="54"><f a=""><x path="Void"/></f></internalDraw>
		<renderDraw public="1" set="method" line="72"><f a=""><x path="Void"/></f></renderDraw>
		<update set="method" line="76" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="trilateral3.target.nme.AppNme" params="" file="src/trilateral3/target/nme/AppNme.hx">
		<extends path="nme.display.Sprite"/>
		<main public="1" set="method" line="30" static="1"><f a=""><x path="Void"/></f></main>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<nodule public="1" expr="new PenNodule(false)">
			<c path="trilateral3.nodule.PenNodule"/>
			<meta><m n=":value"><e>new PenNodule(false)</e></m></meta>
		</nodule>
		<tri public="1"><x path="trilateral3.geom.FlatColorTriangles"/></tri>
		<g><t path="flash.display.Graphics"/></g>
		<viewSprite><t path="flash.display.Sprite"/></viewSprite>
		<_vertices expr="new flash.Vector&lt;Float&gt;()">
			<x path="nme.Vector"><x path="Float"/></x>
			<meta><m n=":value"><e><![CDATA[new flash.Vector<Float>()]]></e></m></meta>
		</_vertices>
		<_cols expr="new flash.Vector&lt;Int&gt;()">
			<x path="nme.Vector"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[new flash.Vector<Int>()]]></e></m></meta>
		</_cols>
		<_indices expr="new flash.Vector&lt;Int&gt;()">
			<x path="nme.Vector"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[new flash.Vector<Int>()]]></e></m></meta>
		</_indices>
		<internalSetup get="inline" set="null" line="38"><f a=""><x path="Void"/></f></internalSetup>
		<animate get="inline" set="null" line="47"><f a=""><x path="Void"/></f></animate>
		<firstDraw get="inline" set="null" line="51"><f a=""><x path="Void"/></f></firstDraw>
		<draw public="1" set="method" line="58"><f a=""><x path="Void"/></f></draw>
		<render get="inline" set="null" line="62"><f a=""><x path="Void"/></f></render>
		<internalDraw get="inline" set="null" line="67"><f a=""><x path="Void"/></f></internalDraw>
		<initArrays get="inline" set="null" line="98"><f a=""><x path="Void"/></f></initArrays>
		<reset get="inline" set="null" line="112"><f a=""><x path="Void"/></f></reset>
		<drawBufferGradient get="inline" set="null" line="126"><f a=""><x path="Void"/></f></drawBufferGradient>
		<renderDraw public="1" set="method" line="131"><f a=""><x path="Void"/></f></renderDraw>
		<this_onEnterFrame get="inline" set="null" line="135"><f a="event">
	<t path="flash.events.Event"/>
	<x path="Void"/>
</f></this_onEnterFrame>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="trilateral3.target.openfl.ColorPalletInt" params="" file="src/trilateral3/target/openfl/AppOpenFL.hx" module="trilateral3.target.openfl.AppOpenFL"><x path="pallette.utils.ColorInt"/></typedef>
	<class path="trilateral3.target.openfl.AppOpenFL" params="" file="src/trilateral3/target/openfl/AppOpenFL.hx">
		<extends path="nme.display.Sprite"/>
		<main public="1" set="method" line="22" static="1"><f a=""><x path="Void"/></f></main>
		<pen public="1"><c path="trilateral3.drawing.Pen"/></pen>
		<nodule public="1" expr="new PenNodule(false)">
			<c path="trilateral3.nodule.PenNodule"/>
			<meta><m n=":value"><e>new PenNodule(false)</e></m></meta>
		</nodule>
		<tri public="1"><x path="trilateral3.geom.FlatColorTriangles"/></tri>
		<g><t path="flash.display.Graphics"/></g>
		<viewSprite><t path="flash.display.Sprite"/></viewSprite>
		<internalSetup get="inline" set="null" line="30"><f a=""><x path="Void"/></f></internalSetup>
		<animate get="inline" set="null" line="38"><f a=""><x path="Void"/></f></animate>
		<firstDraw get="inline" set="null" line="42"><f a=""><x path="Void"/></f></firstDraw>
		<draw public="1" set="method" line="48"><f a=""><x path="Void"/></f></draw>
		<render get="inline" set="null" line="52"><f a=""><x path="Void"/></f></render>
		<internalDraw get="inline" set="null" line="57"><f a=""><x path="Void"/></f></internalDraw>
		<renderDraw public="1" set="method" line="81"><f a=""><x path="Void"/></f></renderDraw>
		<this_onEnterFrame get="inline" set="null" line="85"><f a="event">
	<t path="flash.events.Event"/>
	<x path="Void"/>
</f></this_onEnterFrame>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
</haxe>